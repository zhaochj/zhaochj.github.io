<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neal的点滴</title>
  
  <subtitle>Neal</subtitle>
  <link href="/index.html/atom.xml" rel="self"/>
  
  <link href="https://zhaochj.github.io/"/>
  <updated>2020-08-08T15:29:11.649Z</updated>
  <id>https://zhaochj.github.io/</id>
  
  <author>
    <name>我</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test.md</title>
    <link href="https://zhaochj.github.io/2020/08/08/test-md/"/>
    <id>https://zhaochj.github.io/2020/08/08/test-md/</id>
    <published>2020-08-08T12:15:27.000Z</published>
    <updated>2020-08-08T15:29:11.649Z</updated>
    
    <content type="html"><![CDATA[<p>#一标题</p><p>111111</p><p>##二级标题</p><p>2222222222</p><p>###三级标题</p><p>333333333</p><h4 id="四级标题">四级标题</h4><p>44444444444</p><p>hahahah</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#一标题&lt;/p&gt;
&lt;p&gt;111111&lt;/p&gt;
&lt;p&gt;##二级标题&lt;/p&gt;
&lt;p&gt;2222222222&lt;/p&gt;
&lt;p&gt;###三级标题&lt;/p&gt;
&lt;p&gt;333333333&lt;/p&gt;
&lt;h4 id=&quot;四级标题&quot;&gt;四级标题&lt;/h4&gt;
&lt;p&gt;44444444444&lt;/p&gt;
&lt;p&gt;haha
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>os模块常用方法整理</title>
    <link href="https://zhaochj.github.io/2016/09/15/2016-09-15-os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://zhaochj.github.io/2016/09/15/2016-09-15-os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2016-09-15T05:50:00.000Z</published>
    <updated>2020-08-08T15:29:11.650Z</updated>
    
    <content type="html"><![CDATA[<p>python标准库中的模块比较多，对一个python程序员来说，标准库是不得不经常检阅的资料，python语言因有了如此丰富的标准库所以才显得那么耀眼，对我这个python菜鸟而言，python之路还很长，坚持吧，坚持每天都去标准库翻阅一个模块来看看。本文记录<code>os</code>这个模块的常用方法。</p><a id="more"></a><p>os模块为用户提供一个各种各样的操作系统的一个接口抽象，这里把常用的功能整理如下。</p><h2 id="name属性">name属性</h2><p>在python语言中要使用一个模块需要使用<code>import</code>语句把此模块导进到当前的命名空间里。<code>os</code>模块中的<code>name</code>属性打印出当前操作系统所属的平台，类linux系统输出<code>posix</code>，window用户输出<code>nt</code>。</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">In [<span class="number">2</span>]: os.name</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;posix&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="uname">uname()</h2><p>返回当前操作系统的信息，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: os.uname()</span><br><span class="line">Out[<span class="number">30</span>]: posix.uname_result(sysname=<span class="string">&#x27;Linux&#x27;</span>, nodename=<span class="string">&#x27;neal-System-Product-Name&#x27;</span>, release=<span class="string">&#x27;4.4.0-36-generic&#x27;</span>, version=<span class="string">&#x27;#55-Ubuntu SMP Thu Aug 11 18:01:55 UTC 2016&#x27;</span>, machine=<span class="string">&#x27;x86_64&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="getcwd-和chdir-path">getcwd()和chdir(<em>path</em>)</h2><p>getcwd方法是获取当前的工作路径，而chdir方法是切换工作路径，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">&#x27;/home/neal/private/sync/temp/logscan-api&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">4</span>]: os.chdir(<span class="string">&#x27;/tmp&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">5</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;/tmp&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="fsencode-filename-和fsdecode-filename">fsencode(<em>filename</em>)和fsdecode(<em>filename</em>)</h2><p>表示使用文件系统来编码或解码文件名，fsencode方法接收<code>str</code>，返回<code>bytes</code>,fsdecode方法接收<code>bytes</code>，返回<code>str</code>，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: encode = os.fsencode(<span class="string">&#x27;/tmp/jdk.sh&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">8</span>]: encode</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">b&#x27;/tmp/jdk.sh&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">9</span>]: os.fsdecode(encode)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">&#x27;/tmp/jdk.sh&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="getenv-key-default-None-和getenvb-key-default-None-方法">getenv(<em>key, default=None</em>)和getenvb(<em>key, default=None</em>)方法</h2><p>表示获取指定环境变量的值，getenv方法接收<code>str</code>，返回<code>str</code>，getenvb方法接收<code>bytes</code>，返回<code>bytes</code>，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: os.getenv(<span class="string">&#x27;PATH&#x27;</span>)</span><br><span class="line">Out[<span class="number">27</span>]: <span class="string">&#x27;/home/neal/.pyenv/versions/logscan-api/bin:/home/neal/.pyenv/libexec:/home/neal/.pyenv/plugins/python-build/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/bin:/home/neal/opt/jdk1.8.0_65/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/shims:/home/neal/.pyenv/shims:/home/neal/.pyenv/bin:/home/neal/bin:/usr/local/jdk1.8.0_65/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/neal/opt/node-v6.4.0-linux-x64/bin:/home/neal/opt/pycharm/bin&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">28</span>]: os.getenvb(<span class="string">b&#x27;PATH&#x27;</span>)</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">b&#x27;/home/neal/.pyenv/versions/logscan-api/bin:/home/neal/.pyenv/libexec:/home/neal/.pyenv/plugins/python-build/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/bin:/home/neal/opt/jdk1.8.0_65/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/shims:/home/neal/.pyenv/shims:/home/neal/.pyenv/bin:/home/neal/bin:/usr/local/jdk1.8.0_65/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/neal/opt/node-v6.4.0-linux-x64/bin:/home/neal/opt/pycharm/bin&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">29</span>]: print(os.getenv(<span class="string">&#x27;PAT&#x27;</span>))</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="listdir-path-’-’">listdir(<em>path=’.’</em>)</h2><p>返回指定路径下的文件，默认是当前目录，返回的是一个list，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;/home/neal/private/sync/temp/logscan-api&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">6</span>]: os.listdir()</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">[<span class="string">&#x27;app.py&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;application.conf&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.git&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_scripts&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.gitignore&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.python-version&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;tornado-4.4.1.tar.gz&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;logscan&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.idea&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;logscan-api.xmind&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">7</span>]: os.listdir(path=<span class="string">&#x27;/tmp&#x27;</span>)</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">[<span class="string">&#x27;+~JF3877189641662443938.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;fcitx-qimpanel:0.pid&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.ICE-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.com.google.Chrome.fVrOnx&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.font-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;systemd-private-c3a4fbe0a0c643faa8d68d5d7fd1599d-rtkit-daemon.service-gcBEfw&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF8633920933949119482.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.X0-lock&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;fcitx-socket-:0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.X11-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;config-err-s5rtZ6&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hsperfdata_neal&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;systemd-private-c3a4fbe0a0c643faa8d68d5d7fd1599d-colord.service-GLdwh0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;unity_support_test.0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;orbit-neal&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF1201684757014287454.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.xrdp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;jdk.sh&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF7598506182566291945.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.wine-1000&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.Test-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;iconcache-6NAcAO&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF1811871931355839416.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.XIM-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;systemd-private-c3a4fbe0a0c643faa8d68d5d7fd1599d-systemd-timesyncd.service-ERVXh5&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="mkdir-path-mode-0o777-dir-fd-None-和makedirs-name-mode-0o777-exist-ok-False">mkdir(path, mode=0o777, *, dir_fd=None)和makedirs(name, mode=0o777, exist_ok=False)</h2><p>mkdir不能递归的创建目录，而makedirs可以递归创建，<code>mode=0o777</code>与<code>mode=0o775</code>的效果是一样的，目录的权限都是<code>drwxrwxr-x</code>，不知道为何？测试如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: []</span><br><span class="line"> </span><br><span class="line">In [<span class="number">25</span>]: os.mkdir(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">26</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">27</span>]: os.mkdir(<span class="string">&#x27;/tmp/test/b/bb&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">FileNotFoundError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-27</span><span class="number">-0</span>ce8d4717d44&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.mkdir(&#x27;/tmp/test/b/bb&#x27;)</span><br><span class="line"> </span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;/tmp/test/b/bb&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">28</span>]: os.makedirs(<span class="string">&#x27;/tmp/test/b/bb&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">29</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>再来看看创建目录的权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ <span class="built_in">pwd</span></span><br><span class="line">/tmp/<span class="built_in">test</span></span><br><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ ll</span><br><span class="line">总用量 16</span><br><span class="line">drwxrwxr-x  4 neal neal 4096 9月  15 15:32 ./</span><br><span class="line">drwxrwxrwt 17 root root 4096 9月  15 15:33 ../</span><br><span class="line">drwxrwxr-x  2 neal neal 4096 9月  15 15:31 a/</span><br><span class="line">drwxrwxr-x  3 neal neal 4096 9月  15 15:32 b/</span><br><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ ll b</span><br><span class="line">总用量 12</span><br><span class="line">drwxrwxr-x 3 neal neal 4096 9月  15 15:32 ./</span><br><span class="line">drwxrwxr-x 4 neal neal 4096 9月  15 15:32 ../</span><br><span class="line">drwxrwxr-x 2 neal neal 4096 9月  15 15:32 bb/</span><br></pre></td></tr></table></figure><h2 id="remove-path-dir-fd-None-与removedirs-name">remove(path, *, dir_fd=None)与removedirs(name)</h2><p>remove只能删除文件，如果删除的是一个目录会报错，removedirs递归的删除空目录，如果是非空目录，依然会报错，测试如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: os.listdir(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line">Out[<span class="number">35</span>]: [<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">36</span>]: os.remove(<span class="string">&#x27;/tmp/test/a/1.txt&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">37</span>]: os.listdir(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line">Out[<span class="number">37</span>]: [<span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">38</span>]: os.remove(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">IsADirectoryError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-38</span>-fdb1cdf283f6&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.remove(&#x27;/tmp/test/a&#x27;)</span><br><span class="line"> </span><br><span class="line">IsADirectoryError: [Errno <span class="number">21</span>] Is a directory: <span class="string">&#x27;/tmp/test/a&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:tmp$ <span class="built_in">pwd</span></span><br><span class="line">/tmp</span><br><span class="line">neal@neal-System-Product-Name:tmp$ tree <span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line">├── a</span><br><span class="line">│   └── aa</span><br><span class="line">└── b</span><br><span class="line">    ├── 2.txt</span><br><span class="line">    └── bb</span><br><span class="line"> </span><br><span class="line">4 directories, 1 file</span><br></pre></td></tr></table></figure><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: os.removedirs(<span class="string">&#x27;/tmp/test/a/aa&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">47</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">47</span>]: [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">48</span>]: os.removedirs(<span class="string">&#x27;/tmp/test/b/bb&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">49</span>]: os.listdir(<span class="string">&#x27;/tmp/test/b&#x27;</span>)</span><br><span class="line">Out[<span class="number">49</span>]: [<span class="string">&#x27;2.txt&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">50</span>]: os.removedirs(<span class="string">&#x27;/tmp/test/b&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">OSError                                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-50</span><span class="number">-03112</span>f9e37d0&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.removedirs(&#x27;/tmp/test/b&#x27;)</span><br><span class="line"> </span><br><span class="line">/home/neal/.pyenv/versions/<span class="number">3.5</span><span class="number">.2</span>/lib/python3<span class="number">.5</span>/os.py <span class="keyword">in</span> removedirs(name)</span><br><span class="line">    <span class="number">257</span> </span><br><span class="line">    <span class="number">258</span>     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--&gt; 259     rmdir(name)</span></span><br><span class="line"><span class="string">    260     head, tail = path.split(name)</span></span><br><span class="line"><span class="string">    261     if not tail:</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">OSError: [Errno 39] Directory not empty: &#x27;/tmp/test/b&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="rename-src-dst-src-dir-fd-None-dst-dir-fd-None-与renames-old-new">rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)与renames(old, new)</h2><p>两个方法都表示重命名文件或目录，如果dst的名称已存在，那将会被替换，测试如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ <span class="built_in">pwd</span></span><br><span class="line">/tmp/<span class="built_in">test</span></span><br><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ tree .</span><br><span class="line">.</span><br><span class="line">├── test1</span><br><span class="line">│   └── 1.txt</span><br><span class="line">└── test2</span><br><span class="line">    └── 2.txt</span><br><span class="line"> </span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: os.rename(<span class="string">&#x27;/tmp/test/test1&#x27;</span>, <span class="string">&#x27;/tmp/test/test2&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">OSError                                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-4</span><span class="number">-0</span>d34cb8a001e&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.rename(&#x27;/tmp/test/test1&#x27;, &#x27;/tmp/test/test2&#x27;)</span><br><span class="line"> </span><br><span class="line">OSError: [Errno 39] Directory not empty: &#x27;/tmp/test/test1&#x27; -&gt; &#x27;/tmp/test/test2&#x27;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">5</span>]: os.rename(<span class="string">&#x27;/tmp/test/test1&#x27;</span>, <span class="string">&#x27;/tmp/test/test3&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">neal@neal-System-Product-Name:test$ tree .</span><br><span class="line">.</span><br><span class="line">├── test2</span><br><span class="line">│   └── <span class="number">2.</span>txt</span><br><span class="line">└── test3</span><br><span class="line">    └── <span class="number">1.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span> directories, <span class="number">2</span> files</span><br><span class="line"> </span><br><span class="line">In [<span class="number">8</span>]: os.renames(<span class="string">&#x27;/tmp/test/test3&#x27;</span>, <span class="string">&#x27;/tmp/test/test1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">neal@neal-System-Product-Name:test$ tree .</span><br><span class="line">.</span><br><span class="line">├── test1</span><br><span class="line">│   └── <span class="number">1.</span>txt</span><br><span class="line">└── test2</span><br><span class="line">    └── <span class="number">2.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>两个方法使用方法相似。</p><p>更多os模块的方法请看官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python标准库中的模块比较多，对一个python程序员来说，标准库是不得不经常检阅的资料，python语言因有了如此丰富的标准库所以才显得那么耀眼，对我这个python菜鸟而言，python之路还很长，坚持吧，坚持每天都去标准库翻阅一个模块来看看。本文记录&lt;code&gt;os&lt;/code&gt;这个模块的常用方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python标准库，os模块" scheme="https://zhaochj.github.io/tags/python%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%8Cos%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python中的编码与解码</title>
    <link href="https://zhaochj.github.io/2016/09/14/2016-09-14-%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/"/>
    <id>https://zhaochj.github.io/2016/09/14/2016-09-14-%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</id>
    <published>2016-09-14T06:50:00.000Z</published>
    <updated>2020-08-08T15:29:11.647Z</updated>
    
    <content type="html"><![CDATA[<p>对python的初学者来说，对字符的<code>编码与解码</code>是一个头痛的问题，对我也是一样。python 3严格区分了<code>str</code>与<code>bytes</code>，这对Python的使用者来说一件好事。在python3中字符串是以<code>unicode</code>编码的，<code>unicode</code>是一种不会出现乱码的编码。</p><a id="more"></a><h2 id="字符串的encode与decode">字符串的encode与decode</h2><p>在python 3中可以说原生支持中文，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: str = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">51</span>]: str</span><br><span class="line">Out[<span class="number">51</span>]: <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">52</span>]: type(str)</span><br><span class="line">Out[<span class="number">52</span>]: str</span><br></pre></td></tr></table></figure><p>如果把<code>str</code>转换成<code>bytes</code>，那用<code>encode</code>方法，相反，使用<code>decode</code>方法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">53</span>]: str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Out[<span class="number">53</span>]: <span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">54</span>]: <span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode()</span><br><span class="line">Out[<span class="number">54</span>]: <span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure><p>所以在python 3中进行编码的转换记住以下要点即可：</p><p><strong>str转换成bytes，使用encode方法，bytes转换为str，使用decode方法</strong></p><p>更多关于python中字符编码问题请参考<a href="http://www.ituring.com.cn/article/1116">这里</a>和<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000">这里</a></p><h2 id="base64模块">base64模块</h2><p>在python标准库中有一个<code>base64</code>的标准库，这个模块提供的更加丰富的功能实现对数据的编码与解码，官方文档请看<a href="https://docs.python.org/3/library/base64.html#base64.urlsafe_b64decode">这里</a>，这里记录几个常用的方法 。</p><h3 id="encodebytes方法与decodebytes方法">encodebytes方法与decodebytes方法</h3><p><code>encodebytes</code>方法表示对bytes对象进行编码操作，<code>decodebytes</code>方法的功能刚好相反，是一个解码的操作，两个方法都是返回一个bytes对象，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">71</span>]: <span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line">In [<span class="number">72</span>]: s = <span class="string">b&#x27;this is test str&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">73</span>]: base64.encodebytes(s)</span><br><span class="line">Out[<span class="number">74</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==\n&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">75</span>]: encode = base64.encodebytes(s)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">76</span>]: encode</span><br><span class="line">Out[<span class="number">76</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==\n&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">77</span>]: base64.decodebytes(encode)</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="b64encode方法与b64decode方法">b64encode方法与b64decode方法</h3><p>这两个方法也是对bytest对象进行编码与解码操作，也是返回一个bytes对象，做如下测试：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">83</span>]: s</span><br><span class="line">Out[<span class="number">83</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">84</span>]: base64.b64encode(s)</span><br><span class="line">Out[<span class="number">84</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">85</span>]: base64.b64decode(base64.b64encode(s))</span><br><span class="line">Out[<span class="number">85</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br></pre></td></tr></table></figure><p>从编码的输出结果可看出与采用<code>encodebytes</code>方法编码出的结果几乎是一样的，只是最后少了<code>\n</code>这两个字符。</p><h3 id="urlsafe-b64encode与urlsafe-b64decode方法">urlsafe_b64encode与urlsafe_b64decode方法</h3><p>这两个方法也是对bytest对象进行编码和解码操作，同样返回一个bytes对象，做如下测试：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">88</span>]: s</span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">89</span>]: base64.urlsafe_b64encode(s)</span><br><span class="line">Out[<span class="number">89</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">90</span>]: url_encode = base64.urlsafe_b64encode(s)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">91</span>]: url_encode</span><br><span class="line">Out[<span class="number">91</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">92</span>]: base64.urlsafe_b64decode(url_encode)</span><br><span class="line">Out[<span class="number">92</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br></pre></td></tr></table></figure><p>发现与采用b64encode方法编码出的结果是一样的。</p><p>上边只是<code>base64</code>这个模块的一少数几个方法，更多的方法说明去看官网吧。那为什么base64这个模块提供的上面几个编码方法编码后的内容都是几乎一样的，那为什么会有一同的实现？现在我也不知道这内部的原理和原因。<code>urlsafe_b64encode</code>方法有<code>urlsafe</code>这个关键字，猜想是对url这样类似的bytes对象做编码时应该使用这个方法吧，比如<code>http://zhaochj.github.io</code>或是一个系统路径<code>/etc/test.conf</code>。这个编码方法还要在实际的项目去实践。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对python的初学者来说，对字符的&lt;code&gt;编码与解码&lt;/code&gt;是一个头痛的问题，对我也是一样。python 3严格区分了&lt;code&gt;str&lt;/code&gt;与&lt;code&gt;bytes&lt;/code&gt;，这对Python的使用者来说一件好事。在python3中字符串是以&lt;code&gt;unicode&lt;/code&gt;编码的，&lt;code&gt;unicode&lt;/code&gt;是一种不会出现乱码的编码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="encode" scheme="https://zhaochj.github.io/tags/encode/"/>
    
      <category term="decode" scheme="https://zhaochj.github.io/tags/decode/"/>
    
      <category term="base64" scheme="https://zhaochj.github.io/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>tornado配置解析</title>
    <link href="https://zhaochj.github.io/2016/09/13/2016-09-13-tornado%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://zhaochj.github.io/2016/09/13/2016-09-13-tornado%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2016-09-13T02:50:00.000Z</published>
    <updated>2020-08-08T15:29:11.648Z</updated>
    
    <content type="html"><![CDATA[<p>tornado的options模块是一个命令行解析模块，此模块不仅可以从命令行解析传递的选项，也能从配置文件解析。以下边的事例来进行说明。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>要使用tornado的配置解析功能需要从<code>options</code>模块中引入<code>options</code>和<code>define</code>两个对象，<code>define</code>函数定义全局命名空间的选项，比如上边定义的<code>port</code>选项，后边就可以使用<code>tornado.options.options.port</code>来调用，运行上边的程序可以发现，程序监听在了<code>8000</code>端口，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:~$ ss -tnlp | grep 8000</span><br><span class="line">LISTEN     0      128          *:8000                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=18033,fd=6))</span><br><span class="line">neal@neal-System-Product-Name:~$ </span><br></pre></td></tr></table></figure><p>如果要让程序可以接受命令行传递的参数，那可以这样来改造程序，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>上边加入了<code>options.parse_command_line()</code>这一行代码，表示解析命令行传递的参数，参数使用_–name=value_的格式传递，试着运行上边的代码，在命令行传递相应的选项，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8080</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=20086,fd=6))</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)</span><br><span class="line">LISTEN     0      128          *:8000                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=20034,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在了<code>8080</code>端口，是从命令行传递过来的，所以可以知道，在<code>define</code>函数中定义的选项，又定义了<code>options.parse_command_line()</code>从命令行捕获选项，那程序运行时传递了相应的选项，那程序就使用这个在命令行传递选项的值，如果程序运行时没有传递相应的选项，那就采用define中定义的默认值。</p><p>options模块不仅可以从define和命令行获取选项的值，还可以读取指定一个配置文件，从配置文件读取选项和值，请看下边代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>applications.conf格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf </span><br><span class="line">port = 8080</span><br></pre></td></tr></table></figure><p>程序运行后可发现程序监听在<code>8080</code>端口，即是从配置文件里读取的配置信息，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=22126,fd=6))</span><br></pre></td></tr></table></figure><p>如果同时定义了从配置文件读取和从命令行读取，那生效的是哪个呢？做如下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序如下运行后查看监听在哪个端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf </span><br><span class="line">port = 8080</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8005                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=23810,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在<code>8005</code>端口，如果不在命令行传递参数，那程序会监听在哪个端口？如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=24093,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在了<code>8080</code>这个配置在配置文件中的端口。如果把<code>options.parse_command_line()</code>放在<code>options.parse_config_file('./application.conf')</code>之前呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>再运行程序试试，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=8777,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在<code>8080</code>这个定义在配置文件中的端口，如果不传递命令行参数呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=8937,fd=6))</span><br></pre></td></tr></table></figure><p>同样监听在<code>8080</code>端口，依然是配置文件中定义的参数，如果把配置文件中的信息清除呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; application.conf </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8005                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=25126,fd=6))</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8000                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=25384,fd=6))</span><br></pre></td></tr></table></figure><p>在上边的程序中，当把配置文件中的配置项去除后，如果命令行传递相应选项，那程序会使用命令行传递的参数，如果命令行没有传递相应的选项，那程序会使用<code>defie</code>中定义的默认选项。经过以上的不断测试，可以总结出<code>tornado</code>在使用配置选项时是按照如下规则：</p><ol><li>配置项的读取是根据代码的定义从上往下读取，如：先定义从文件读取，再定义从命令行读取，那程序就会先从文件读取，再从命令行读取；</li><li>如果相同的选项在配置文件中有定义，再在命令行也传递相同的选项，那后一个读取到的选项的值会覆盖前一个值，即最后读取到的值是生效值；</li><li>如果配置文件和命令行都未定义选项的值，那采用<code>define</code>定义的默认值。</li></ol><p>而在实际的编程中，从配置文件读取和从命令行读取会结合起来，并且一般会从两个地方读取配置文件，一个一般存放在<code>/etc</code>目录下作为全局配置文件，另一个存放在工程的根目录下，最后再接收命令行传递的参数以便在程序调试时使用。举一个例子来说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;/etc/app.conf&#x27;</span>):</span><br><span class="line">        options.parse_config_file(<span class="string">&#x27;/etc/app.conf&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./application.conf&#x27;</span>):</span><br><span class="line">        options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat /etc/app.conf </span><br><span class="line">port = 8888</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf </span><br><span class="line">port = 8080</span><br></pre></td></tr></table></figure><p>运行程序测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8005                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=10291,fd=6))</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=10404,fd=6))</span><br></pre></td></tr></table></figure><p>这也很好的验证了是最后读取到的那个选项生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado的options模块是一个命令行解析模块，此模块不仅可以从命令行解析传递的选项，也能从配置文件解析。以下边的事例来进行说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web框架" scheme="https://zhaochj.github.io/categories/web%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="tornado" scheme="https://zhaochj.github.io/tags/tornado/"/>
    
      <category term="options" scheme="https://zhaochj.github.io/tags/options/"/>
    
      <category term="define" scheme="https://zhaochj.github.io/tags/define/"/>
    
      <category term="配置解析" scheme="https://zhaochj.github.io/tags/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>tornado怎样返回信息</title>
    <link href="https://zhaochj.github.io/2016/09/10/2016-09-10-tornado%E5%AF%B9http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E/"/>
    <id>https://zhaochj.github.io/2016/09/10/2016-09-10-tornado%E5%AF%B9http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E/</id>
    <published>2016-09-10T02:50:00.000Z</published>
    <updated>2020-08-08T15:29:11.646Z</updated>
    
    <content type="html"><![CDATA[<p>本节记录tornado返回给浏览器信息的一些方法，在上一节中反复使用了<code>tornado.web.RequestHandler</code>类的<code>write</code>方法，此方法直接把数据返回给浏览器。在官方文档中tornado把这部分的内容放在了<code>RequestHandler</code>类的<code>Output</code>这一节，官方文档请点击<a href="http://www.tornadoweb.org/en/stable/web.html#output">这里</a>。</p><a id="more"></a><h2 id="Output">Output</h2><h3 id="set-status">set_status</h3><p>此方法设置返回状态码，接收<code>status_code</code>和<code>reason</code>两个参数，使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForbiddenHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_status(<span class="number">403</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/403&#x27;</span>, ForbiddenHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>尝试访问<code>/403</code>这个路由结果如下：</p><p><img src="/images/2016-09-12-forbidden.png" alt="2016-09-12-forbidden.png"></p><p>要注意的是要显示的调用<code>self.finish()</code>方法来结束， <code>self.finish()</code>代表回应生成的终结，否则客户端还会保持连接。</p><h3 id="set-header">set_header</h3><p>此方法设置响应报文的头部信息，事例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;XXXXX&#x27;</span>)</span><br><span class="line">        self.write(<span class="string">&#x27;set header&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/head&#x27;</span>, HeaderHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序运行后访问结果如下：</p><p><img src="/images/2016-09-12-set_header-1.png" alt="2016-09-12-set_header-1.png"></p><p><img src="/images/2016-09-12-set_header-2.png" alt="2016-09-12-set_header-2.png"></p><p><code>set_header</code>方法如果多次对同一个header进行赋值，那结果是最后那一个，如下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;XXXXX&#x27;</span>)</span><br><span class="line">        self.set_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;YYYYY&#x27;</span>)</span><br><span class="line">        self.write(<span class="string">&#x27;set header&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/head&#x27;</span>, HeaderHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序启动后测试结果如下：</p><p><img src="/images/2016-09-12-set_header-3.png" alt="2016-09-12-set_header-3.png"></p><h3 id="add-header">add_header</h3><p>此方法增加给定响应头的值，测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddHeadlerHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.add_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;add-XXX&#x27;</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/addhead&#x27;</span>, AddHeadlerHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序运行访问结果如下：</p><p><img src="/images/2016-09-12-add_header-1.png" alt="2016-09-12-add_header-1.png"></p><p>如果多次调用<code>add_header</code>方法，那最后的响应头的值会被叠加，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddHeadlerHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.add_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;add-XXX&#x27;</span>)</span><br><span class="line">        self.add_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;add-YYY&#x27;</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/addhead&#x27;</span>, AddHeadlerHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序运行后访问结果如下：</p><p><img src="/images/2016-09-12-add_header-2.png" alt="2016-09-12-add_header-2.png"></p><h3 id="write">write</h3><p>此方法上边都多次用到，表示把给定的数据块写入输出缓冲区，即当用浏览器访问时直接输出到浏览器上。</p><h3 id="flush">flush</h3><p>此方法刷新当前的输出缓冲区到网络，看下边的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;start\n&#x27;</span>)</span><br><span class="line">        self.flush()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            self.write(<span class="string">&#x27;&#123;0&#125;\n&#x27;</span>.format(x))</span><br><span class="line">            self.flush()</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        self.finish(<span class="string">&#x27;stop\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/flush&#x27;</span>, FlushHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>flush这个特性在<code>postman</code>工具中不能演示出效果来，可以使用<code>curl</code>来测试，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:~$ curl http://172.20.12.174:8000/flush</span><br><span class="line">start</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">stop</span><br><span class="line">neal@neal-System-Product-Name:~$ </span><br></pre></td></tr></table></figure><p>上边的输出是有停顿的，停顿的时间就是代码中的<code>time.sleep(0.1)</code>。</p><h3 id="finish">finish</h3><p>此方法表示完成这个响应，HTTP的请求结束。前边的事例代码也有说明。</p><p>更多信息请参考<a href="http://www.tornadoweb.org/en/stable/web.html#output">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节记录tornado返回给浏览器信息的一些方法，在上一节中反复使用了&lt;code&gt;tornado.web.RequestHandler&lt;/code&gt;类的&lt;code&gt;write&lt;/code&gt;方法，此方法直接把数据返回给浏览器。在官方文档中tornado把这部分的内容放在了&lt;code&gt;RequestHandler&lt;/code&gt;类的&lt;code&gt;Output&lt;/code&gt;这一节，官方文档请点击&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#output&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web框架" scheme="https://zhaochj.github.io/categories/web%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="tornado" scheme="https://zhaochj.github.io/tags/tornado/"/>
    
      <category term="返回请求" scheme="https://zhaochj.github.io/tags/%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>tornado处理请求报文</title>
    <link href="https://zhaochj.github.io/2016/09/08/2016-09-07-tornado-http%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/"/>
    <id>https://zhaochj.github.io/2016/09/08/2016-09-07-tornado-http%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/</id>
    <published>2016-09-08T01:50:00.000Z</published>
    <updated>2020-08-08T15:29:11.645Z</updated>
    
    <content type="html"><![CDATA[<p>tornado是一个轻量、异步的web微框架，本文记录tornado怎样处理一个http请求报文。</p><a id="more"></a><h2 id="Hello-World">Hello World</h2><p>tornado使用<code>RequestHandler</code>类来处理http请求，所以在使用tornado来处理http请求时，自定义的类需要继承<code>RequestHandler</code>类。HTTP的方法，如：GET、PUT、DELETE、POST、HEAD等，都一一对应<code>RequestHandler</code>类中的方法。在使用tornado的web框架特性时一般是从<code>tornado</code>这个包中引入<code>web</code>模块里的相应类，<code>web</code>这个模块的源码请点击<a href="https://github.com/tornadoweb/tornado/blob/master/tornado/web.py">这里</a>。<br>　　接下来看一下tornado是怎样来处理http的请求的。首先来写一个经典的<code>Hello World</code>程序，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;Hello World\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>把程序启动后会监听在8000端口，使用curl来访问得到如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:~$ curl http://172.20.12.174:8000</span><br><span class="line">Hello World</span><br><span class="line">neal@neal-System-Product-Name:~$</span><br></pre></td></tr></table></figure><p>这个<code>Hello World</code>事例中首先从<code>tornado.web</code>这个模块中引入了<code>RequestHandler</code>和<code>Application</code>两个类，<code>RequestHandler</code>类用来处理HTTP的请求，<code>Application</code>用来处理路由，这个类实例化后返回一个可调用的<code>tornado.web.Application</code>类，然后调用此类的<code>listen</code>方法使用程序监听在本地任意地址的<code>8000</code>端口，最后使用<code>IOLoop.current().start()</code>来把程序运行在起来循环处理用户请求。Tornado为了实现高并发和高性能，使用了这个IOLoop来处理socket的读写事件，IOLoop基于epoll，可以高效的响应网络事件。这是Tornado高效的保证。</p><p>在tornado的官方文档中把<code>Request handlers</code>分成了<code>Entry points</code>、<code>Input</code>和<code>Output</code>等多个章节，这里只对<code>Input</code>和<code>Output</code>的某些方法进行讲解，更详细资料请看<a href="http://www.tornadoweb.org/en/stable/web.html">官方文档</a>。</p><h2 id="Input">Input</h2><h3 id="get-argument方法">get_argument方法</h3><p>此方法返回用户传递参数的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgumentHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(self.get_argument(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/arg&#x27;</span>, ArgumentHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><code>ArgumentHandler</code>类是用户自定义类，此类继承<code>RequestHandler</code>,接着对<code>get</code>方法进行重写，这就是我们在使用<code>tornado</code>进行web开发时经常需要做的工作。HTTP协议定义的<code>get</code>、<code>post</code>、<code>delete</code>等方法在<code>tornado</code>中对应的同名方法是直接返回<code>HTTPError(405)</code>，即是没有实现的方法，这些方法就需要程序员自己根据业务逻辑来实现。源码请<a href="http://www.tornadoweb.org/en/stable/_modules/tornado/web.html#RequestHandler.get">参考</a>。运行此代码再访问返回如下：</p><p><img src="/images/2016-09-08-get_argument.png" alt="2016-09-08-get_argument"></p><p>结果是直接把传递的参数<code>name</code>的值<code>zhaochj</code>直接返回。如果给<code>name</code>这个变量传递多个值呢？如下：</p><p><img src="/images/2016-09-08-get_argument-1.png" alt="2016-09-08-get_argument-1.png"></p><p>结果是得到了最后一个值。</p><h3 id="get-arguments">get_arguments</h3><p>此方法同样返回用户传递参数的内容，但与<code>get_argument</code>不同的是它能接收同名的的多个参数，并且返回一个<code>list</code>，测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgumentHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(self.get_argument(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgumentsHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;\n&#x27;</span>.format(str(type(self.get_arguments(<span class="string">&#x27;name&#x27;</span>)))))</span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(<span class="string">&#x27;, &#x27;</span>.join(self.get_arguments(<span class="string">&#x27;name&#x27;</span>))))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/arg&#x27;</span>, ArgumentHandler),</span><br><span class="line">            (<span class="string">r&#x27;/args&#x27;</span>, ArgumentsHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>运行上边代码后访问得到如下结果：</p><p><img src="/images/2016-09-08-get_arguments.png" alt="2016-09-08-get_arguments.png"></p><h3 id="args">args</h3><p>在实际编程中可能会需要捕获一个路径下的值，使用<code>args</code>就可以把捕获到一个路径下的所有内容，并会把这个值存放在一个位置参数中，通过访问<code>args[0]</code>便可访问，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathArgsHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(args[<span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/path/args/(.*)&#x27;</span>, PathArgsHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>在正规中<code>(.*)</code>表示匹配任意内容，所以在URL中<code>/path/args/</code>后的所有内容都会被捕获，访问后结果如下：</p><p>![2016-09-08 17-25-41-args.png](/images/2016-09-08 17-25-41-args.png)</p><h3 id="kwargs">kwargs</h3><p>同<code>args</code>一样，<code>kwargs</code>可以捕获一个路径下的<code>K/V</code>键值数据，并存放在字典中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathKwArgsHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(kwargs[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/path/kwargs/(?P&lt;name&gt;.*)&#x27;</span>, PathKwArgsHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><code>（?P&lt;name&gt;.*)</code>表示命名捕获，这是<code>re</code>的语法，请参照<a href="https://docs.python.org/3/library/re.html">这里</a>，程序运行后访问结果如下：</p><p><img src="/images/2016-09-08-kwargs.png" alt="2016-09-08-kwargs.png"></p><h3 id="获取请求报文的其他内容">获取请求报文的其他内容</h3><p>一个请求报文中包含了非常多的内容，如：method，uri，path，query，version，body等，详细请参考<a href="http://www.tornadoweb.org/en/stable/httputil.html#tornado.httputil.HTTPServerRequest">这里</a>，以下事例说明怎样获取请求端的IP地址有body内容，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteIpHander</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(self.request.remote_ip))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BodyHandler</span>(<span class="params">RemoteIpHander</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        body = json.loads(self.request.body.decode())</span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(body[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/ip&#x27;</span>, RemoteIpHander),</span><br><span class="line">            (<span class="string">r&#x27;/body&#x27;</span>, BodyHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><code>RemoteIpHander</code>类中直接调用<code>self.request.remote_ip</code>即可打印出客户端的IP地址，而<code>BodyHandler</code>类定义<code>post</code>方法，采用<code>json.lodads</code>来解析上传的<code>json</code>数据，注意最后的<code>decode</code>方法，因为通过客户端发送过来的数据是<code>bytes</code>，而<code>json</code>对象只能是<code>str</code>，所以需要<code>decode</code>来解码。程序运行后测试结果如下：</p><p><img src="/images/2016-09-08-remoteip.png" alt="2016-09-08-remoteip.png"></p><p><img src="/images/2016-09-08-postbody.png" alt="2016-09-08-postbody.png"></p><p><code>RequestHandler</code>这个类还有许多方法，详细信息参考<a href="http://www.tornadoweb.org/en/stable/web.html">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado是一个轻量、异步的web微框架，本文记录tornado怎样处理一个http请求报文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web框架" scheme="https://zhaochj.github.io/categories/web%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="tornado" scheme="https://zhaochj.github.io/tags/tornado/"/>
    
      <category term="处理请求" scheme="https://zhaochj.github.io/tags/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>python线程中的condition特性</title>
    <link href="https://zhaochj.github.io/2016/08/21/2016-08-21-%E7%BA%BF%E7%A8%8B%E7%9A%84condition%E7%89%B9%E6%80%A7/"/>
    <id>https://zhaochj.github.io/2016/08/21/2016-08-21-%E7%BA%BF%E7%A8%8B%E7%9A%84condition%E7%89%B9%E6%80%A7/</id>
    <published>2016-08-21T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.644Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之线程间的condition特性</p><a id="more"></a><h2 id="threading的Condition方法">threading的Condition方法</h2><p>confition方法适合<code>生产-消费</code>的工作模型，消费者会等待生产者生产数据生消费者再对数据进行处理。以下边的例子来说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Message:</span><br><span class="line">    def __init__(self, message):</span><br><span class="line">        self.message = message</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def consumer(cond, message):</span><br><span class="line">    with cond:</span><br><span class="line">        cond.wait()</span><br><span class="line">        logging.debug(<span class="string">&quot;consumer &#123;0&#125;&quot;</span>.format(message.message))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def producer(cond, message):</span><br><span class="line">    with cond:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;====&#x27;</span>)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        message.message = <span class="string">&#x27;ha ha ha &#x27;</span></span><br><span class="line">        logging.debug(<span class="string">&quot;producer &#123;0&#125;&quot;</span>.format(message.message))</span><br><span class="line">        cond.notify_all()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    message = Message(None)</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line">    c1 = threading.Thread(target=consumer, args=(cond, message), name=<span class="string">&quot;consumer-1&quot;</span>)</span><br><span class="line">    c1.start()</span><br><span class="line">    c2 = threading.Thread(target=consumer, args=(cond, message), name=<span class="string">&quot;consumer-2&quot;</span>)</span><br><span class="line">    c2.start()</span><br><span class="line"> </span><br><span class="line">    p = threading.Thread(target=producer, args=(cond, message), name=<span class="string">&quot;producer&quot;</span>)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure><p>上边的测试代码中定义了一个<code>producer</code>方法用于生产数据，<code>consumer</code>方法用于消费数据，当运行上边代码后，先是输出了<code>====</code>，再等待2秒后输出了<code>2016-08-21 17:29:16,212 DEBUG [producer] producer ha ha ha </code>，接着跟着输出了<code>2016-08-21 17:29:16,212 DEBUG [consumer-1] consumer ha ha ha</code>和<code>2016-08-21 17:29:16,212 DEBUG [consumer-2] consumer ha ha ha</code>，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">====</span><br><span class="line">2016-08-21 17:29:16,212 DEBUG [producer] producer ha ha ha </span><br><span class="line">2016-08-21 17:29:16,212 DEBUG [consumer-1] consumer ha ha ha </span><br><span class="line">2016-08-21 17:29:16,212 DEBUG [consumer-2] consumer ha ha ha </span><br></pre></td></tr></table></figure><p>可见consumer线程是在producer线程运行之后才运行，即等待生产者生产数据。</p><p>小结：</p><p><code>threading.Condition()</code>初始化一个condition对象，当生产者准备好数据后用<code>notify_all()</code>通知监听同一个condition对象的线程消费数据，如果生产方没有数据生产出来，那消费者就被阻塞等待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之线程间的condition特性&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="线程，condition" scheme="https://zhaochj.github.io/tags/%E7%BA%BF%E7%A8%8B%EF%BC%8Ccondition/"/>
    
  </entry>
  
  <entry>
    <title>线程的daemon与join特性</title>
    <link href="https://zhaochj.github.io/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84daemon%E4%B8%8Ejoin%E7%89%B9%E6%80%A7/"/>
    <id>https://zhaochj.github.io/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84daemon%E4%B8%8Ejoin%E7%89%B9%E6%80%A7/</id>
    <published>2016-08-14T14:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.643Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之多线程中的daemon与join特性</p><a id="more"></a><h2 id="none-daemon与daemon">none daemon与daemon</h2><p>在python 3中，threading属于标准库中的模块，在version 3.3中增加了daemon参数，值是一个bool值，默认为<code>False</code>。</p><p>如果一个线程的<code>daemon=False</code>，即我们说这个线程是一个<code>none daemon</code>的线程，那主线程<code>永远</code>会等待子线程全部退出后自己才退出。</p><p>看下边的例子，下边的例子全部都在pytharm的IDE中进行：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">False</span></span><br><span class="line">    t.start()</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>当运行这段代码时，先打印出了<code>主线程</code>的日志信息，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">06</span>:<span class="number">24</span>,<span class="number">358</span> DEBUG [MainThread] main thread exiting</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>主线程被阻塞，然后等待5秒后再打印出了<code>子线程</code>的日志信息，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">06</span>:<span class="number">24</span>,<span class="number">358</span> DEBUG [MainThread] main thread exiting   <span class="comment"># 被阻塞</span></span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">06</span>:<span class="number">29</span>,<span class="number">359</span> DEBUG [worker] worker <span class="keyword">is</span> started, ha,ha  <span class="comment"># 5秒后才打印出来</span></span><br></pre></td></tr></table></figure><p>所以当线程是一个<code>none daemon</code>线程时，主线程会被阻塞，直到全部子线程退出。</p><p>当线程是一个daemon线程时呢？把上边的<code>t.daemon = False</code>修改成<code>t.daemon = True</code>后再次运行代码，结果如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">39</span>,<span class="number">644</span> DEBUG [MainThread] main thread exiting</span><br><span class="line">  </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从上边输出的结果可知，主线程没有等待子线程运行结束，而主线程自己就退出了。而当主线程退出后子线程也会跟着退出。</p><p>小结：</p><p>在<code>none daemon</code>的线程中主线程永远会等待子线程退出后才退出，在<code>daemon</code>的线程中主线程不会等待子线程退出后自己才退出，在<code>none daemon</code>线程中子线程因程序bug或其他原因而不能正常的退出时，那主线程就一直被阻塞，一直等待着子线程退出，这样线程所占用的资源就一直不能被释放。join函数能解决这样的问题。</p><h2 id="join">join( )</h2><p>线程调用join函数后，主线程就会等待子线程退出后才退出，而子线程执行的代码如果不能正常退出时那主线程也一直会等待，如果在join时加上一个超时时间，那主线程只等待设置的超时时间后主线程就退出。</p><ul><li>none daemon中的join()</li></ul><p>看下边的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">False</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>当运行上边代码时，先输出了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> worker</span><br></pre></td></tr></table></figure><p>再等待5秒后输出了下边的日志信息：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">16</span>,<span class="number">925</span> DEBUG [worker] worker <span class="keyword">is</span> started, ha,ha</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">16</span>,<span class="number">925</span> DEBUG [MainThread] main thread exiting</span><br></pre></td></tr></table></figure><p>这说明当一个线程是<code>none daemon</code>时，并调用了<code>join()</code>函数，那主线程会等待子线程执行完成。这和不调用<code>join()</code>函数的<code>none daemon</code>线程是有区别的，调用<code>join()</code>函数时是主线程等待子线程完成，不调用<code>join()</code>函数时是主线程被阻塞后，一直等待子线程执行完成，从打印的日志可看出两者的区别。</p><p>join()函数可以给定一个超时时间，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">False</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join(timeout=<span class="number">2</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上边的代码后，首先输出<code>exec worker</code>，等待2秒，再输出<code>2016-08-14 16:10:59,695 DEBUG [MainThread] main thread exiting</code>,再等待3秒，最后输出<code>2016-08-14 16:11:02,692 DEBUG [worker] worker is started, ha,ha</code>，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> worker  <span class="comment"># 2秒后输出下一行</span></span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">59</span>,<span class="number">695</span> DEBUG [MainThread] main thread exiting <span class="comment"># 3秒后输出下一行</span></span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">11</span>:<span class="number">02</span>,<span class="number">692</span> DEBUG [worker] worker <span class="keyword">is</span> started, ha,ha</span><br></pre></td></tr></table></figure><p>在<code>none daemon</code>的线程中，如果给<code>join()</code>函数一个超时时间，当超过这个时间后，即使这个线程没有执行完成，程序就直接输出了<code>2016-08-14 16:10:59,695 DEBUG [MainThread] main thread exiting</code>，并且被阻塞在这里等待子线程的完成，因为线程是<code>none daemon</code>的。这种场景在现实的编程中应该不多。</p><ul><li>daemon中的join()</li></ul><p>在实际的编程中，一般会把线程设置成daemon，并启用<code>join()</code>函数，并适当给一个超时时间，这样主线程即能等待子线程，又能兼顾子线程因一些原因被卡住后无法退出时导致主线程也无法退出的情况。如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">True</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join(timeout=<span class="number">6</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上边的代码，先是输出<code>exec worker</code>，再等待5秒，依次输出<code>2016-08-14 16:31:59,287 DEBUG [worker] worker is started, ha,ha</code>和<code>2016-08-14 16:31:59,287 DEBUG [MainThread] main thread exiting</code>。这样，采用join的方式让主线程等待子线程正常退出，如果在调用worker函数时有bug，执行时一直退不出来，那到join的超时时间后，主线程同样能退出，把上边的<code>t.join(timeout=6)</code>修改成<code>t.join(timeout=3)</code>来模拟这样一个场景，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">True</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join(timeout=<span class="number">3</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行上边的代码后，先是输出<code>exec worker</code>,再等待3秒后直接输出<code>2016-08-14 16:36:23,608 DEBUG [MainThread] main thread exiting</code>,worker函数里的内容没有被执行，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> worker</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">23</span>,<span class="number">608</span> DEBUG [MainThread] main thread exiting</span><br><span class="line">  </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之多线程中的daemon与join特性&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="多线程" scheme="https://zhaochj.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python多线程间通信机制-event</title>
    <link href="https://zhaochj.github.io/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84event%E7%89%B9%E6%80%A7/"/>
    <id>https://zhaochj.github.io/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84event%E7%89%B9%E6%80%A7/</id>
    <published>2016-08-14T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.643Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之多线程间通信-event</p><a id="more"></a><h2 id="线程间的通讯-event">线程间的通讯-- event</h2><p>event是多线程间通信的一种简单机制，一个线程发出event信号，其他线程等待这个信号。</p><p>以一个例子来说明，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        logging.debug(<span class="string">&#x27;in worker fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line">    logging.debug(<span class="string">&#x27;event is set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">event</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    event.set()</span><br><span class="line">    logging.debug(<span class="string">&#x27;in set fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    w = threading.Thread(target=worker, args=(event,), name=<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    w.start()</span><br><span class="line">    s = threading.Thread(target=set, args=(event,), name=<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure><p>在上边的代码中定义了两个函数，并在测试代码上启用两个线程分别调用这两个函数，在调用前要初始化<code>event</code>对象。运行上边的代码会发现一直输出<code>2016-08-14 20:36:49,059 DEBUG [worker] in worker fun, event is set ? False</code>,即是调用<code>worker</code>函数的线程在不断执行，1秒后输出了<code>2016-08-14 20:36:49,063 DEBUG [set] in set fun, event is set ? True</code>，紧跟着输出<code>2016-08-14 20:36:49,063 DEBUG [worker] event is set</code>，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">....略.....</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,063 DEBUG [set] in set fun, event is set ? True</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">49</span>,<span class="number">063</span> DEBUG [worker] event <span class="keyword">is</span> set</span><br></pre></td></tr></table></figure><p>为什么会这样？</p><p>因为在测试代码中启动了两个线程分别调用<code>worker</code>和<code>set</code>函数，<code>worker</code>函数判断当event没有被set时打印类似这样日志<code>in worker fun, event is set ? False</code>。而<code>set</code>函数负责将线程内部的标志设置为<code>true</code>，即执行<code>event.set()</code>语句，它将唤醒所有线程并告知<code>event</code>的内部标志已为<code>true</code>，<code>set</code>函数只是sleep了1秒钟，调用<code>woker</code>函数的线程就执行了很多次了。此时执行<code>worker函数</code>的线程收到这个信号后执行到<code>while not event.is_set()</code>语句时，<code>event.is_set()</code>返回了<code>true</code>，所以整个while语句返回<code>False</code>，那while循环中的语句将被跳过，而去执行<code>logging.debug('event is set')</code>。</p><ul><li>event.wait()</li></ul><p>wait方法表示阻塞直到线程内部的标志为<code>true</code>，即有线程调用<code>set()</code>方法。以下边的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        event.wait()</span><br><span class="line">        logging.debug(<span class="string">&#x27;in worker fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line">    logging.debug(<span class="string">&#x27;event is set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">event</span>):</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    event.set()</span><br><span class="line">    logging.debug(<span class="string">&#x27;in set fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    w = threading.Thread(target=worker, args=(event,), name=<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    w.start()</span><br><span class="line">    s = threading.Thread(target=set, args=(event,), name=<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure><p>执行上边的代码时，<code>w</code>线程会被一直阻塞，直到4秒种之后，<code>set</code>函数执行到<code>event.set()</code>，内部标志被设置成为<code>true</code>，通知其他所有线程，<code>w</code>线程收到信号后不再阻塞。输出如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-08-14 21:45:26,326 DEBUG [set] in set fun, event is set ? True</span><br><span class="line">2016-08-14 21:45:26,326 DEBUG [worker] in worker fun, event is set ? True</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">26</span>,<span class="number">326</span> DEBUG [worker] event <span class="keyword">is</span> set</span><br><span class="line"> </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>wait可以设置超时时间，表示只阻塞线程一定的时间，如果收到了<code>event.set()</code>信号，线程退出，否则线程被阻塞，只是不是一直阻塞，而是按照设定的时间阻塞线程，如下设置<code>wait</code>时间，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        event.wait(timeout=<span class="number">1</span>)</span><br><span class="line">        logging.debug(<span class="string">&#x27;in worker fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line">    logging.debug(<span class="string">&#x27;event is set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">event</span>):</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    event.set()</span><br><span class="line">    logging.debug(<span class="string">&#x27;in set fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    w = threading.Thread(target=worker, args=(event,), name=<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    w.start()</span><br><span class="line">    s = threading.Thread(target=set, args=(event,), name=<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure><p>当执行上边代码时，每隔一秒执行<code>worker</code>函数，当到第4秒时，<code>event</code>对象被<code>set</code>，<code>w</code>线程收到信号就退出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之多线程间通信-event&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="多线程，event特性" scheme="https://zhaochj.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8Cevent%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://zhaochj.github.io/2016/06/24/docker/2016-06-24-docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhaochj.github.io/2016/06/24/docker/2016-06-24-docker%E5%9F%BA%E7%A1%80/</id>
    <published>2016-06-24T05:40:00.000Z</published>
    <updated>2020-08-08T15:29:11.653Z</updated>
    
    <content type="html"><![CDATA[<p>docker越来越流行，这里介绍一点关于docker的基础知识。</p><a id="more"></a><h1>Docker基础篇</h1><ul><li>[x] docker简介</li><li>[x] 安装docker服务</li></ul><h2 id="docker简介">docker简介</h2><blockquote><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。-- 百度百科</p></blockquote><p><img src="/images/2016-06-24-docker-01.png" alt="docker_vs_vm"></p><p>上图来自docker<a href="https://www.docker.com/what-docker#/VM">官网</a>截图，整体上说明了传统的虚拟机与docker的区别，传统的虚拟机包括应用程序，必要的二进制文件和库文件以及一个完整的操作系统，这样一个虚拟机文件会有上GB的大小。而docker容器则包含应用程序以及依赖包，但容器间共享操作系统的kernel,在宿主机上以一个进程体现一个docker容器，各个容器间是相互隔离的，容器不依赖任何特定的基础设施，这样方便于迁移。</p><p>已下所有操作基于Debain 8 x 64</p><p>docker服务器需要安装包：</p><p>dialog</p><p>perl-base</p><p>apt-utils</p><h2 id="安装docker服务">安装docker服务</h2><p>先删除旧包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-get purge lxc-docker*</span></span><br><span class="line">root@haproxy-01:~<span class="comment"># apt-get purge docker.io*</span></span><br></pre></td></tr></table></figure><p>再使apt能工作在https方式及安装CA证书，如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-get update</span></span><br><span class="line">root@haproxy-01:~<span class="comment"># apt-get install apt-transport-https ca-certificates</span></span><br></pre></td></tr></table></figure><p>增加新的GPG key</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span></span><br></pre></td></tr></table></figure><p>根据系统的发行版本增加相应的docker源，我这里使用的是Debian Jessie</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment">#  vim /etc/apt/sources.list.d/docker.list  #增加下边的地址</span></span><br><span class="line">deb https://apt.dockerproject.org/repo debian-jessie main</span><br><span class="line">root@haproxy-01:~<span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure><p>可用以下命令验证<code>docker-engine</code>软件将会从哪个存储库下载及相应软件版本的列表</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-cache policy docker-engine</span></span><br></pre></td></tr></table></figure><p>安装<code>docker-engine</code>，这里安装目前最新的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-get install docker-engine=1.11.2-0~jessie</span></span><br><span class="line">root@haproxy-01:~<span class="comment"># docker version</span></span><br><span class="line">Client:</span><br><span class="line"> Version:      1.11.2</span><br><span class="line"> API version:  1.23</span><br><span class="line"> Go version:   go1.5.4</span><br><span class="line"> Git commit:   b9f10c9</span><br><span class="line"> Built:        Wed Jun  1 21:23:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.11.2</span><br><span class="line"> API version:  1.23</span><br><span class="line"> Go version:   go1.5.4</span><br><span class="line"> Git commit:   b9f10c9</span><br><span class="line"> Built:        Wed Jun  1 21:23:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure><p>以上操作可以用如下脚本完成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: install_docker.sh</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: sky_551@163.com</span></span><br><span class="line"><span class="comment">#Date: 2016-06-16</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"><span class="comment"># for debina jessie x64</span></span><br><span class="line"></span><br><span class="line">version=1.11.2-0~jessie</span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># del old pkg</span></span><br><span class="line">apt-get purge lxc-docker*</span><br><span class="line">apt-get purge docker.io*</span><br><span class="line"></span><br><span class="line"><span class="comment"># install apt-transport-https ca-certificates</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install apt-transport-https ca-certificates</span><br><span class="line"></span><br><span class="line"><span class="comment"># add GPG key</span></span><br><span class="line">apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br><span class="line"></span><br><span class="line"><span class="comment"># add docker.list for Debian Jessie</span></span><br><span class="line">rm -f /etc/apt/sources.list.d/*</span><br><span class="line">cat &lt;&lt;- EOF &gt;&gt; /etc/apt/sources.list.d/docker.list</span><br><span class="line">deb https://apt.dockerproject.org/repo debian-jessie main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># install docker-engine</span></span><br><span class="line">apt-get install docker-engine=<span class="variable">$&#123;version&#125;</span></span><br><span class="line"></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p><strong>在docker中进入一个已运行的容器</strong></p><ul><li><p>首先确保系统已安装有<code>nsenter</code>命令，此命令由<code>util-linux</code>包安装得来，安装命令为<code>apt-get install util-linux</code></p></li><li><p>先得到container id</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                CREATED             STATUS              PORTS                                          NAMES</span><br><span class="line">d924adae5ff6        nginx:latest                    <span class="string">&quot;nginx -g &#x27;daemon of   18 hours ago        Up 18 hours         80/tcp, 443/tcp                                r-WEB-Server_Nginx-cluster_1</span></span><br></pre></td></tr></table></figure><ul><li>计算出指定container id容器的PID</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># docker inspect --format &#123;&#123;.State.Pid&#125;&#125; d924adae5ff6</span></span><br><span class="line">20272</span><br></pre></td></tr></table></figure><ul><li>进入到容器中</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># nsenter --target 20272 --mount --uts --ipc --net --pid</span></span><br><span class="line">root@d924adae5ff6:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>上边的命令似乎过于复杂，有前辈给我们准备好了便捷的工具，脚本如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Some useful commands to use docker.</span></span><br><span class="line"><span class="comment"># Author: yeasy@github</span></span><br><span class="line"><span class="comment"># Created:2014-09-25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> docker-pid=<span class="string">&quot;sudo docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;&quot;</span></span><br><span class="line"><span class="built_in">alias</span> docker-ip=<span class="string">&quot;sudo docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#the implementation refs from https://github.com/jpetazzo/nsenter/blob/master/docker-enter</span></span><br><span class="line"><span class="keyword">function</span> docker-<span class="function"><span class="title">enter</span></span>() &#123;</span><br><span class="line">    <span class="comment">#if [ -e $(dirname &quot;$0&quot;)/nsenter ]; then</span></span><br><span class="line">    <span class="comment">#Change for centos bash running</span></span><br><span class="line">    <span class="keyword">if</span> [ -e $(dirname <span class="string">&#x27;$0&#x27;</span>)/nsenter ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># with boot2docker, nsenter is not in the PATH but it is in the same folder</span></span><br><span class="line">        NSENTER=$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)/nsenter</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># if nsenter has already been installed with path notified, here will be clarified</span></span><br><span class="line">        NSENTER=$(<span class="built_in">which</span> nsenter)</span><br><span class="line">        <span class="comment">#NSENTER=nsenter</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    [ -z <span class="string">&quot;<span class="variable">$NSENTER</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;WARN Cannot find nsenter&quot;</span> &amp;&amp; <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Usage: `basename &quot;</span><span class="variable">$0</span><span class="string">&quot;` CONTAINER [COMMAND [ARG]...]&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Enters the Docker CONTAINER and executes the specified COMMAND.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;If COMMAND is not specified, runs an interactive shell in CONTAINER.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PID=$(sudo docker inspect --format <span class="string">&quot;&#123;&#123;.State.Pid&#125;&#125;&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$PID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;WARN Cannot find the given container&quot;</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line"></span><br><span class="line">        OPTS=<span class="string">&quot;--target <span class="variable">$PID</span> --mount --uts --ipc --net --pid&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="comment"># No command given.</span></span><br><span class="line">            <span class="comment"># Use su to clear all host environment variables except for TERM,</span></span><br><span class="line">            <span class="comment"># initialize the environment variables HOME, SHELL, USER, LOGNAME, PATH,</span></span><br><span class="line">            <span class="comment"># and start a login shell.</span></span><br><span class="line">            <span class="comment">#sudo $NSENTER &quot;$OPTS&quot; su - root</span></span><br><span class="line">            sudo <span class="variable">$NSENTER</span> --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid su - root</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># Use env to clear all host environment variables.</span></span><br><span class="line">            sudo <span class="variable">$NSENTER</span> --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid env -i <span class="variable">$@</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上边的脚本内容保存在用户家目录下，文件名为<code>.bashrc_docker</code>，或直接运行<code>wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker</code>命令把此脚本文件下载到用户家目录下，再运行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[ -f ~/.bashrc_docker ] &amp;&amp; source ~/.bashrc_docker&quot;</span> &gt;&gt; ~/.bashrc; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这样用户每次登陆时都会执行<code>.bashrc_docker</code>文件，此工具使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@cst004:~<span class="comment"># docker-pid &lt;container&gt;   # docker-pid 跟上容器的name即可获得容器的pid</span></span><br><span class="line">root@cst004:~<span class="comment"># docker-enter &lt;container&gt;    # 直接进入容器</span></span><br><span class="line">root@cst004:~<span class="comment"># docker-enter &lt;container&gt; COMMAND   # 直接进入容器执行一个命令</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker越来越流行，这里介绍一点关于docker的基础知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化" scheme="https://zhaochj.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="docker基础" scheme="https://zhaochj.github.io/tags/docker%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构-双端队列-环状队列</title>
    <link href="https://zhaochj.github.io/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-%E7%8E%AF%E7%8A%B6%E9%98%9F%E5%88%97/"/>
    <id>https://zhaochj.github.io/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-%E7%8E%AF%E7%8A%B6%E9%98%9F%E5%88%97/</id>
    <published>2016-05-16T13:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.641Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之双端队列与环状队列</p><a id="more"></a><h2 id="数据结构-双端队列-环状队列">数据结构-双端队列-环状队列</h2><h3 id="双端队列">双端队列</h3><p>单端队列数据只能从队尾进，从队头出数据。而双端队列表示数据两端都可以进，两端都可以出。</p><p>双端队列里依然有两个指针，<code>head</code>和<code>backend</code>指针，一个空队列时，两个指针都指向<code>None</code>,从队列的前端增加数据时，<code>head</code>指针向前移动，当从队列的后端增加元素时，<code>backend</code>指针向后移动元素。如果要弹出队头的元素，那先把<code>head</code>往<code>backend</code>方向移动，再弹出此元素，如果要弹出队尾的元素，那行把<code>backend</code>指针往<code>head</code>所在方向移动。当两个指针指向<code>None</code>时，表示已是一个空队列。</p><p>可以用示意图来表达这一过程：</p><p><img src="/images/2016-05-16-05.jpg" alt="双端队列"></p><p><img src="/images/2016-05-16-06.jpg" alt="双端队列"></p><p>当删除元素元素时就是一个与增加元素相反的过程。</p><p>在<code>python</code>的标准库中已实现了<code>双端队列</code>，可以用<code>from collections import deque</code>导入。<code>deque</code>常用属性：</p><p>创建一个空队列：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: dq = deque()</span><br><span class="line">In [<span class="number">11</span>]: dq</span><br><span class="line">Out[<span class="number">11</span>]: deque([])</span><br></pre></td></tr></table></figure><p>使用<code>append</code>方法向队列增加元素，此方法是向队尾增加元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: dq.append(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">13</span>]: dq.append(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">14</span>]: dq</span><br><span class="line">Out[<span class="number">14</span>]: deque([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用<code>appendleft</code>方法向队列增加元素，此方法是向队头增加元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: dq.appendleft(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">16</span>]: dq.appendleft(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">17</span>]: dq</span><br><span class="line">Out[<span class="number">17</span>]: deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用<code>pop</code>方法弹出一个元素，此方法是在队尾方向弹出元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: dq.pop()</span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">19</span>]: dq</span><br><span class="line">Out[<span class="number">19</span>]: deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用<code>popleft</code>方法弹出一个元素，此方法是在队头方向弹出元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: dq.popleft()</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">21</span>]: dq</span><br><span class="line">Out[<span class="number">21</span>]: deque([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="环状队列">环状队列</h3><p>环状队列在初始化时会生成指定数量的槽位，如果有元素<code>append</code>进来时，按照顺序依次加入到这些空的槽位中，当槽位被占满时，再<code>append</code>元素时会把最老的那个元素踢掉，再把新元素放入到槽位中，依此类推，环状队列最多保存初始化时指定槽位的数据。</p><p>可以用一个简单的示意图来表示：</p><p><img src="/images/2016-05-16-07.jpg" alt="环状队列"></p><p>标准库的<code>deque</code>不仅是双端队列，也是一个环状队列。只要初始化队列时加上<code>maxlen</code>参数即可。</p><p>创建一个槽位为5的环境队列：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: ring = deque(maxlen=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">24</span>]: ring</span><br><span class="line">Out[<span class="number">24</span>]: deque([])</span><br></pre></td></tr></table></figure><p>向队列增加5个元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: ring.append(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">26</span>]: ring.append(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">27</span>]: ring.append(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">28</span>]: ring.append(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">29</span>]: ring.append(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">30</span>]: ring</span><br><span class="line">Out[<span class="number">30</span>]: deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>当再增加一个元素时：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: ring.append(<span class="number">6</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">32</span>]: ring</span><br><span class="line">Out[<span class="number">32</span>]: deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>第一个元素被覆盖了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之双端队列与环状队列&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="双端队列，环状队列" scheme="https://zhaochj.github.io/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%8C%E7%8E%AF%E7%8A%B6%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构-hash</title>
    <link href="https://zhaochj.github.io/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash/"/>
    <id>https://zhaochj.github.io/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash/</id>
    <published>2016-05-16T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.640Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之hash</p><a id="more"></a><h2 id="拉链法实现hash表数据结构">拉链法实现hash表数据结构</h2><h3 id="什么叫Hash">什么叫Hash</h3><blockquote><p>Hash一般翻译做“散列”，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p></blockquote><p>一个输入通过散列算法得到一个固定长宽的输出，这个散列值是有可能冲突的，也就是说输入值不同，而通过计算后得到的散列值有可能相同了，这样就产生了冲突，拉链法就能解决这样的冲突。拉链法把散列值所对应的数据又放在了一个链表里，放在链表的位置就是以散列值作为索引值，这样就能解决散列冲突的问题，要以下边的示意图来展示：</p><p><img src="/images/2016-05-19-01.jpg" alt="hash"></p><p>左边就是hash表的尺寸大小，可以把它看成一个数组，数组的每个成员指向一个链表，也可以指向一个空链表，链表里的元素主是实际存放的数据。</p><p>Hash表常用的方法：</p><ul><li>Map()方法，创建一个空Hash表</li><li>put(key, value)方法，接收一个key和value，没有返回值</li><li>get(key)方法，接收key，返回key对应的value值，如果没有此值默认返回None</li><li>remove(key)方法，接收key，删除key对应的value</li></ul><p>先来实现一个存放在链表中的元素类：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure><p>Node类接收两个参数，一个是key，另一个Key对应的value。</p><h4 id="Map类的实现">Map类的实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, init_size, hash=hash</span>):</span></span><br><span class="line">        self.__slot = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(init_size)]</span><br><span class="line">        self.__size = init_size</span><br><span class="line">        self.hash = hash</span><br></pre></td></tr></table></figure><p>如果计算散列值的函数不使用pyton的内建的hash函数，可以自己传入一个函数，这里默认采用hash函数。代码中的列表解析<code>self.__slot = [[] for _ in range(init_size)]</code>与下边的代码块等价，都是生成一个包含<code>init_size</code>个<code>[]</code>元素的列表。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.__slot = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(init_size):</span><br><span class="line">   self.__slot.append([])</span><br></pre></td></tr></table></figure><h4 id="put方法实现">put方法实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">    node = Node(key, value)</span><br><span class="line">    address = self.hash(node.key) % self.__size</span><br><span class="line">    self.__slot[address].append(node)</span><br></pre></td></tr></table></figure><p>这里的<code>address = self.hash(node.key) % self.__size</code>是把散列值与Hash表尺寸做取模运算，这样<code>address</code>就一定能落到如上图中的数组元素中，接着再把<code>node</code>对象<code>append</code>到链表中。</p><h4 id="get方法实现">get方法实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=None</span>):</span></span><br><span class="line">    _key = self.hash(key)</span><br><span class="line">    address = _key % self.__size</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> self.__slot[address]:</span><br><span class="line">        <span class="keyword">if</span> node.key == key:</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">    <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure><p>要得到一个<code>key</code>的<code>value</code>值，首先得采用相同的hash函数计算出散列地址，再在这个地址上的链表中遍历<code>key</code>，有则返回其<code>value</code>，否则返回一个默认值。</p><h4 id="remove方法实现">remove方法实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    address = self.hash(key) % self.__size</span><br><span class="line">    <span class="keyword">for</span> idx, node <span class="keyword">in</span> enumerate(self.__slot[address].copy()):</span><br><span class="line">        <span class="keyword">if</span> node.key == key:</span><br><span class="line">            self.__slot[address].pop(idx)</span><br></pre></td></tr></table></figure><p>此方法同样需要得到<code>key</code>的散列地址，再遍历链表，只是这里会删除<code>key</code>所对应的<code>value</code>。在使用python的可迭代对象时有一条定律，那就是永远都不要对迭代对象进行数据的修改，所以这里把链表进行了<code>copy()</code>，生成一个副本，对这个副本进行遍历，如果链表中有<code>key</code>，那就在原链表里弹出此<code>key</code>。</p><h4 id="完整的代码如下：">完整的代码如下：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, init_size, hash=hash</span>):</span></span><br><span class="line">        self.__slot = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(init_size)]</span><br><span class="line">        <span class="comment">#self.__slot = []</span></span><br><span class="line">        <span class="comment">#for _ in range(init_size):</span></span><br><span class="line">        <span class="comment">#   self.__slot.append([])</span></span><br><span class="line">        self.__size = init_size</span><br><span class="line">        self.hash = hash</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        address = self.hash(node.key) % self.__size</span><br><span class="line">        self.__slot[address].append(node)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=None</span>):</span></span><br><span class="line">        _key = self.hash(key)</span><br><span class="line">        address = _key % self.__size</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.__slot[address]:</span><br><span class="line">            <span class="keyword">if</span> node.key == key:</span><br><span class="line">                <span class="keyword">return</span> node.value</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        address = self.hash(key) % self.__size</span><br><span class="line">        <span class="keyword">for</span> idx, node <span class="keyword">in</span> enumerate(self.__slot[address].copy()):</span><br><span class="line">            <span class="keyword">if</span> node.key == key:</span><br><span class="line">                self.__slot[address].pop(idx)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    map = Map(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        map.put(i, i)</span><br><span class="line"> </span><br><span class="line">    map.remove(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(map.get(i, <span class="string">&#x27;not set&#x27;</span>))</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之hash&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hash" scheme="https://zhaochj.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构之队列</title>
    <link href="https://zhaochj.github.io/2016/05/15/2016-05-15-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <id>https://zhaochj.github.io/2016/05/15/2016-05-15-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E7%AB%AF%E9%98%9F%E5%88%97/</id>
    <published>2016-05-15T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.640Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之队列</p><a id="more"></a><h2 id="数据结构-队列">数据结构-队列</h2><p>队列是有序数据集合，队列的特点，删除数据项是在头部，称为前端(front)，增加数据在尾部，称为后端(rear)。数据项总是开始排在队伍的后端，慢慢向前走，直到排到最前面，轮到它的时候离开队列。</p><p>刚进来的数据排在后端，待在队伍里时间最长的在前端，这种排列规则叫做FIFO(first-in first-out)，意思是“先进先出”，或者叫做“先来先服务”(first-come first-served)</p><p>队列一般提供以下接口：</p><ol><li>Queue() 定义一个空队列，无参数，返回值是空队列</li><li>enqueue(item)  在队列尾部加入一个数据项，参数是数据项，无返回值</li><li>dequeue()  删除队列头部的数据项，不需要参数，返回值是被删除的数据，队列本身有变化。</li><li>isEmpty()  检测队列是否为空。无参数，返回布尔值。</li><li>size() 返回队列数据项的数量。无参数，返回一个整数。</li></ol><p>用python的list数据类型能比较容易的实现队列数据模型，但这里不以list来实现。我们假设队列里的元素有一个指针，最先加进元素的指针指向它下一个元素，依次类推，最后一个元素的指针是指向None。所以队列里的元素可以抽象出一个类来，同样像链表时的Node类一样，Node类里有自己的数据和一个指向None的指针。一个Node对象如下示意图：</p><p><img src="/images/2016-05-16-01.jpg" alt="node"></p><p>而队列里分为两端，一端叫前端，这一端做数据的删除操作，另一端叫后端，做数据的增加操作。数据只能从后端加入，并只能从前端删除。为了抽象这个<code>Queue</code>类，会创建两个指针，一个<code>head</code>，指向队头的元素，一个<code>tail</code>，指向队尾的元素。如果是一个空的队列，那<code>head</code>和<code>tail</code>都指向<code>None</code>。</p><p>一个空队列示意图：</p><p><img src="/images/2016-05-16-02.jpg" alt="node"></p><p>当队列里有一个元素时，<code>head</code>和<code>tail</code>两个指针都指向这个元素，示意图是这样的：</p><p><img src="/images/2016-05-16-03.jpg" alt="node"></p><p>当队列再增加一个元素时，<code>tail</code>指针会移动到新增加的这个元素，前一个元素的<code>next</code>指针也会指向新元素，而<code>head</code>指针不会发生改变，如下图：</p><p><img src="/images/2016-05-16-04.jpg" alt="node"></p><p>不断向队列增加元素时，各个指针移动方式如上。</p><p>当是删除元素时，直接把<code>head</code>指针移动到下一个元素，再把值弹出即可。</p><p>来看一个最简单队列的代码实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is a empty queue&#x27;</span>)</span><br><span class="line">        cur = self.head</span><br><span class="line">        self.head = cur.next</span><br><span class="line">        <span class="keyword">return</span> cur.value</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        q.enqueue(i)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(q.dequeue())</span><br><span class="line">    print(q.is_empty())</span><br><span class="line">    print(q.size())</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在实际编码中不会自己来实现一个队列，而是使用标准库中的<code>queue</code>，通过<code>from queue import Queue</code>来导入Queue类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之队列&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="队列" scheme="https://zhaochj.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈的运用-表达式解析</title>
    <link href="https://zhaochj.github.io/2016/05/14/2016-05-14-%E6%A0%88%E8%BF%90%E7%94%A8-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>https://zhaochj.github.io/2016/05/14/2016-05-14-%E6%A0%88%E8%BF%90%E7%94%A8-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2016-05-14T14:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.639Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之数据结构栈实现表达式解析。</p><a id="more"></a><h2 id="栈运用-表达式解析">栈运用-表达式解析</h2><p>以一个表达式解析的例子来说明栈的运用，比如要解析<code>(3 + 4) * 5 / ((2 + 3) *3)</code>这样一个数字表达式，观察这个表达式可知道一个正确的表达式括号是成对出现的，如果不是，那表达式是有误。</p><p>用静态的示意图不好表达这个过程，这里就来描述一下这个过程：</p><ol><li><p>表达式是一个字符串，可以用for循环得到表达式中每一个元素，因空白字符不会参与计算，所以空白字符不需要处理</p></li><li><p>如果是&quot;(+/-=*&quot;这样的字符时直接就入栈</p></li><li><p>如果元素不是’)’，说明字符是个数字，此有以下几种情况：</p><p>3.1、此时栈顶元素是“+/-*”这样的计算符号，把符号pop出来，接着再判断栈顶元素是不是数字，不是数字则表达式是错误的，如果是数字，那也把此数字pop出来，按照pop出的计算符号与前边的数字进行计算，得到结果后把此数字push回栈。</p><p>3.2、如果栈顶元素不是“+/-*”这样的计算符号，直接入栈</p></li><li><p>如果元素是’)’，判断栈顶元素是不是数字，如果不是就抛出异常，说明表达是有问题的。如果是一个数字，则把栈顶的数字元素pop出，再判断栈顶元素是不是’(’，如果不是，抛出异常说明表达式有误，如果是’(’，那也把’('元素pop出来，再把之前弹出的数字元素push回栈</p></li><li><p>通过上边的计算和判断后栈里可能剩下的就是一个含有一个计算符号的表达式，此时再把栈顶pop出来并判断这是不是一个数字，如果是，则把栈顶元素pop出来，得到一个计算符号，接着再把栈顶元素pop，此时这个栈顶元素应该是一个数字，这样根据计算符号就可以得到最终的结果。</p></li></ol><p>代码如下：</p><p>stack.py模块</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stack <span class="keyword">import</span> Stack</span><br><span class="line"> </span><br><span class="line">func_map = &#123;</span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: <span class="keyword">lambda</span> x, y: x+y,</span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: <span class="keyword">lambda</span> x, y: x-y,</span><br><span class="line">    <span class="string">&#x27;*&#x27;</span>: <span class="keyword">lambda</span> x, y: x*y,</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="keyword">lambda</span> x, y: x/y</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cacl</span>(<span class="params">expr</span>):</span></span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> expr:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&#x27;(+-*/&#x27;</span>:</span><br><span class="line">            stack.push(c)</span><br><span class="line">        <span class="keyword">elif</span> c.strip() == <span class="string">&#x27;&#x27;</span>:   <span class="comment"># 对空格的处理</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                c = int(c)</span><br><span class="line">                <span class="keyword">if</span> stack.top.value <span class="keyword">in</span> <span class="string">&#x27;+/-*&#x27;</span>:</span><br><span class="line">                    s = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(stack.top.value, (int, float)):</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">                    v = stack.pop()</span><br><span class="line">                    v = func_map[s](v, c)</span><br><span class="line">                    stack.push(v)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.push(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> isinstance(stack.top.value, (int, float)):</span><br><span class="line">                    v = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack.top.value == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        stack.push(v)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> stack.top:</span><br><span class="line">        c = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(c, (int,float)):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> stack.top.value <span class="keyword">in</span> <span class="string">&#x27;+/-*&#x27;</span>:</span><br><span class="line">            s = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(stack.top.value, (int, float)):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">            v = stack.pop()</span><br><span class="line">            v = func_map[s](v, c)</span><br><span class="line">            <span class="keyword">if</span> stack.top <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 栈顶是None时才表明表达式解析完成</span></span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    expr = <span class="string">&#x27;(3 + 4) * 5 / ((2 + 3) *3)&#x27;</span></span><br><span class="line">    print(cacl(expr))</span><br></pre></td></tr></table></figure><p>此代码中的<code>func_map</code>函数算是一个技巧，这样就可以方便的为两个数字进行加减乘除运算，少去了用多个<code>if</code>语句来做判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之数据结构栈实现表达式解析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="栈运用，表达式解析" scheme="https://zhaochj.github.io/tags/%E6%A0%88%E8%BF%90%E7%94%A8%EF%BC%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构之栈</title>
    <link href="https://zhaochj.github.io/2016/05/14/2016-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>https://zhaochj.github.io/2016/05/14/2016-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</id>
    <published>2016-05-14T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.637Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之<code>数据结构-栈</code></p><a id="more"></a><h2 id="数据结构-栈">数据结构-栈</h2><p>栈（也叫“push-down stack”-下推栈）一种线性有序的数据元素集合，它的特点是，数据的增加删除操作都在同一端进行。进行操作的这一端，我们一般叫做“顶”，另一端叫做“底”。</p><p>栈的底部很有象征性，因为元素越接近底部，就意味着在栈里的时间越长。最近进来的，总是最早被移走，这种排列规律叫做先进后出，综合为LIFO( last-in first-out)。所以栈的排序是按时间长短来排列元素的。新来的在栈顶，老家伙们在栈底。</p><p>下图反应了栈中数据加入和移走的顺序：</p><p><img src="/images/2016-05-13-12.jpg" alt="栈"></p><p>一个栈一般会实现以下方法：</p><ol><li>Stack(),构造方法，创建一个空栈，无参数，返回值是空栈</li><li>push(value) 向栈顶压入一个新数据项，需要一个数据项参数，无返回值</li><li>pop() 抛出栈顶数据项，无参数，返回被抛出的数据项，栈本身发生变化</li><li>peek() 返回栈顶数据项，但不删除。不需要参数，栈不变</li><li>is_empty() 测试栈是否空栈。不需要参数，返回布尔值。</li><li>size() 返回栈内数据项的数目，不需要参数，返回值是整数</li></ol><p>在python中栈的实现有多种，可以用内置的list数据结构实现，只要约定一个列表的一堆为栈顶，那可以利用现成的<code>append</code>和<code>pop</code>方法对列表(栈)进行操作，这里以另外的方式实现。</p><h3 id="Node类实现">Node类实现</h3><p>栈中的节点具有两个部份，这与链表中的节点类似，一个<code>数据域</code>，一个<code>指针域</code>。先看<code>Node</code>类的代码实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>Node类接收一个value参数，实例化后生成一个<code>数据域</code>为<code>value</code>，<code>next</code>指针指向<code>None</code>的对象。<br>用以下代码实例化后生成一个节点：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = Node(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>一个节点可以用一个示意图表示，如下：</p><p><img src="/images/2016-05-14-01.jpg" alt="node"></p><h3 id="Stack类实现">Stack类实现</h3><h4 id="构建函数实现">构建函数实现</h4><p>构建函数的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>构建函数初始化时创建了一个栈顶指针<code>top</code>，并指向<code>None</code>，如果栈里有数据，<code>top</code>指针会指向靠近栈顶的元素。此类执行以下代码实例化后生成一个空栈：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = Stack()</span><br></pre></td></tr></table></figure><p>一个空栈可以用以下示意图表示：</p><p><img src="/images/2016-05-13-13.jpg" alt="空栈"></p><h4 id="push方法实现">push方法实现</h4><p><code>push</code>方法实现向栈增加元素，这个过程叫做<code>押栈</code>，有以下操作要做：</p><ol><li>既然是增加元素，当然要实例化Node类，这里以node变量表示指向Node类的实例化对象</li><li>把node的next指针指向栈的top指针指向的对象</li><li>移动top指针移动到栈顶元素</li></ol><p>代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br></pre></td></tr></table></figure><p>如执行以下代码，向栈内增加一个元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.push(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>此时栈内可用以下示意图来表示这个过程：</p><p><img src="/images/2016-05-14-02.jpg" alt="node"></p><p>当不断向栈内增加数据，如下操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>这样会出现类似下图的数据结构：</p><p><img src="/images/2016-05-14-03.jpg" alt="node"></p><h4 id="pop方法实现">pop方法实现</h4><p>pop方法返回栈顶元素的值，此过程需要把top指针指向栈顶指向元素的下一个元素，然后把栈顶元素返回。也要考虑是对空栈的操作。</p><p><code>pop</code>方法的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><p>代码中使用了一个临时变量<code>node</code>，先让此变量指向栈顶元素，这样<code>node</code>这个对象就可以调用<code>next</code>属性，即可以再把栈的<code>top</code>指针指向栈顶元素的下一个元素。其实质就是移动了<code>top</code>指针的位置。比如执行如下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.pop()</span><br></pre></td></tr></table></figure><p>这个过程如下示意图：</p><p><img src="/images/2016-05-14-04.jpg" alt="node"></p><p>栈顶指针移动后，栈顶元素会被垃圾回收器回收掉。</p><h4 id="peek方法实现">peek方法实现</h4><p>peek方法直接返回栈顶元素。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><h4 id="is-empty方法实现">is_empty方法实现</h4><p>is_empty方法判断是否为空栈，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.top</span><br></pre></td></tr></table></figure><h4 id="size方法实现">size方法实现</h4><p>size方法返回栈内元素的个数，和链表的size方法类似，也用一个累加器完成计数。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="Node类和Stack类的完整代码">Node类和Stack类的完整代码</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.top</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#    print(stack.pop())</span></span><br><span class="line"><span class="comment">#    print(stack.top.value)</span></span><br><span class="line">    print(stack.peek())</span><br><span class="line">    print(stack.is_empty())</span><br><span class="line">    print(stack.size())</span><br></pre></td></tr></table></figure><h3 id="栈运用-平衡符号">栈运用-平衡符号</h3><p>平衡符号是栈的一种运用。像<code>[]、()、&#123;&#125;</code>这样符号都是成对出现的，我们可以用下边的代码来检测一个表达式所使用的这种成对出现的符号是否正确，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.top</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    exp = <span class="string">&#x27;&#123;a * [x/(x+y)]&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> exp:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&#x27;&#123;[(&#x27;</span>:</span><br><span class="line">            stack.push(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;&#125;])&#x27;</span>:</span><br><span class="line">            v = stack.top.value</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> v != <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;]&#x27;</span> <span class="keyword">and</span> v != <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> v != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">if</span> stack.top <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之&lt;code&gt;数据结构-栈&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="栈" scheme="https://zhaochj.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构-链表</title>
    <link href="https://zhaochj.github.io/2016/05/12/2016-05-12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>https://zhaochj.github.io/2016/05/12/2016-05-12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</id>
    <published>2016-05-12T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.635Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之链表</p><a id="more"></a><h2 id="数据结构-链表">数据结构-链表</h2><p>什么是链表，我对这个概念非常陌生。</p><p>链表是实现了数据之间保持逻辑顺序，但存储空间不必按顺序的方法。可以用一个图来表示这种链表的数据结构：</p><p><img src="/images/2016-05-13-01.jpg" alt="链表"><br>　　　　　　　　　　　　　　　　图１：链表</p><p>链表中的基本要素：</p><ol><li>结点(也可以叫节点或元素)，每一个结点有两个域，左边部份叫<code>值域</code>，用于存放用户数据；右边叫<code>指针域</code>，一般是存储着到下一个元素的指针</li><li>head结点，head是一个特殊的结节，head结点永远指向第一个结点</li><li>tail结点，tail结点也是一个特殊的结点，tail结点永远指向最后一个节点</li><li>None，链表中最后一个结点指针域的指针指向None值，因也叫<code>接地点</code>，所以有些资料上用电气上的接地符号代表None</li></ol><p>链表的常用方法：</p><ol><li>LinkedList() 创建空链表，不需要参数，返回值是空链表</li><li>is_empty() 测试链表是否为空，不需要参数，返回值是布尔值</li><li>append(data) 在尾部增加一个元素作为列表最后一个。参数是要追加的元素，无返回值</li><li>iter() 遍历链表，无参数，无返回值，此方法一般是一个生成器</li><li>insert(idx,value) 插入一个元素，参数为插入元素的索引和值</li><li>remove(idx)移除1个元素，参数为要移除的元素或索引，并修改链表</li><li>size() 返回链表的元素数，不需要参数，返回值是个整数</li><li>search(item) 查找链表某元素，参数为要查找的元素或索引，返回是布尔值</li></ol><h3 id="节点类">节点类</h3><p>python用类来实现链表的数据结构，节点（Node）是实现链表的基本模块，每个节点至少包括两个重要部分。首先，包括节点自身的数据，称为“数据域”(也叫值域)。其次，每个节点包括下一个节点的“引用”(也叫指针)</p><p>下边的代码用于实现一个Node类：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>此节点类只有一个构建函数，接收一个数据参数，其中<code>next</code>表示指针域的指针，实例化后得到一个节点对象，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = Node(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>此节点对象数据为<code>4</code>，指针指向None。</p><p>这样一个节点对象可以用一个图例来更形象的说明，如下：</p><p><img src="/images/2016-05-13-02.jpg" alt="链表"><br>　　　　　　　　　　　　　　图2:　节点</p><h3 id="链表类">链表类</h3><p>先来看LinkedList类的构建函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>此类实例后会生成一个链表对象，初始化了<code>head</code>和<code>tail</code>节点，且两节点都指向<code>None</code>，实例化代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list = LinkedList()</span><br></pre></td></tr></table></figure><p>也可以用图形象的表示这个链表对象，如下：</p><p><img src="/images/2016-05-13-03.jpg" alt="链表"><br>　　　　　　　　　　　　　　　　　　　图3：空链表</p><h4 id="is-empty方法实现">is_empty方法实现</h4><p>is_empty方法检查链表是否是一个空链表，这个方法只需要检查<code>head</code>节点是否指向<code>None</code>即可，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>如果是空列表返回<code>True</code>，否则返回<code>False</code></p><h4 id="append方法实现">append方法实现</h4><p>append方法表示增加元素到链表，这和insert方法不同，前者使新增加的元素成为链表中第一个节点，而后者是根据索引值来判断插入到链表的哪个位置。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br></pre></td></tr></table></figure><p>既然要新增加节点，首先把Node类实例化得到一个node对象。这里有两种情况需要考虑，一是链表是一个空链表时怎样append一个节点；二是当链表不是空链表时又怎样append一个节点？</p><p>当<code>if self.head is None:</code>为<code>True</code>时，把链表的<code>head</code>和<code>tail</code>都指向了<code>node</code>，假如我们执行了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list(append(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>此时的链表结构如下图：</p><p><img src="/images/2016-05-13-04.jpg" alt="链表"><br>　　　　　　　　　　　　　　　　图4：append-1</p><p>当<code>if self.head is None:</code>为<code>False</code>时,说明链表已经增加了一个节点了，再增加一个节点时<code>head</code>已经指向了第一个节点，所以不为<code>None</code>，比如增加的第二个节点为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list(append(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>增加第二个节点的操作需要分两步完成，第一步：<code>self.tail.next = node</code>，即把上一个节点的<code>next</code>指针指向当前<code>node</code>；第二步：<code>self.tail = node</code>，把<code>tail</code>移动到<code>node</code>，如下图：</p><p><img src="/images/2016-05-13-05.jpg" alt="链表"></p><p>移动完成后就成这样了：</p><p><img src="/images/2016-05-13-06.jpg" alt="链表"></p><p>当增加第三个、第四个等节点时，按照上边的操作依次类推。</p><h3 id="iter方法实现">iter方法实现</h3><p>iter方法表示遍历链表。在遍历链表时也要首先考虑空链表的情况。遍历链表时从<code>head</code>开始，直到一个节点的<code>next</code>指向<code>None</code>结束，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">yield</span> cur.data</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">yield</span> cur.data</span><br></pre></td></tr></table></figure><p>当是遍历一个空链表时，<code>if not self.head:</code>为<code>True</code>，直接返回<code>None</code>；如果不是空链表就让一个局部变量<code>cur</code>指向<code>head</code>,并把<code>head</code>的<code>data</code>属性<code>yield</code>出来，再对<code>cur</code>的<code>next</code>指针指向的对象做<code>while</code>循环，直到<code>next</code>指向<code>None</code>，这样就遍历了链表。</p><h3 id="insert方法实现">insert方法实现</h3><p>假如采取<code>append</code>方法又增加了两个节点，增加完成后如下图：</p><p><img src="/images/2016-05-13-07.jpg" alt="链表"></p><p>如果想在数据域为<code>6</code>的那节点处插入一个节点，需要做的操作有两步：</p><ol><li>把新节点的next指针指向数据域为<code>6</code>的这个节点，即为数据域为<code>5</code>节点的next指向指向的对象</li><li>把数据域为<code>5</code>节点的next指针指向新加的节点</li></ol><p>注： 这两个步骤不能颠倒，如果颠倒，数据域为<code>6</code>的节点会被丢失，数据域为<code>7</code>的节点不再是链表的节点。</p><p>示意图如下：</p><p><img src="/images/2016-05-13-08.jpg" alt="链表"></p><p>还要额外考虑两种情况：</p><ol><li>空链表时</li><li>插入位置超出链表节点的长度时</li><li>插入位置是链表的最后一个节点时，需要移动tail</li></ol><p>当是在链表最后一个节点插入时，示意图如下：</p><p><img src="/images/2016-05-13-09.jpg" alt="链表"></p><p>要在指定的索引位置插入一个节点，前提是需要找到这个位置，在链表中只有采用遍历的方式，具有O(n)的速度，最糟糕时会遍历链表的所有节点，而当找到插入点时，我们并不需要当前节点的信息，而是需要前一个节点的信息，所以代码中巧妙的使用了<code>while cur_idx &lt; idx-1:</code>的方式，这样能使用<code>cur</code>这个变量能指向插入点上一个节点对象。</p><p>实现<code>insert</code>方法的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, idx, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">            cur_idx += <span class="number">1</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">        <span class="keyword">if</span> node.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.tail = node</span><br></pre></td></tr></table></figure><h3 id="remove方法实现">remove方法实现</h3><p>remove方法接收一个idx参数，表示要删除节点的索引，此方法要考虑以下几种情况：</p><ol><li>空链表，直接抛出异常</li><li>删除第一个节点时，移动head到删除节点的next指针指向的对象</li><li>链表只有一个节点时，把head与tail都指向None即可</li><li>删除最后一个节点时，需要移动tail到上一个节点</li><li>遍历链表时要判断给定的索引是否大于链表的长度，如果大于则抛出异常信息</li></ol><p>请看下边图例：</p><p><img src="/images/2016-05-13-10.jpg" alt="链表"></p><p><img src="/images/2016-05-13-11.jpg" alt="链表"></p><p>以下为remove函数的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">       cur = self.head</span><br><span class="line">       cur_idx = <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空链表时</span></span><br><span class="line">           <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">       <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:</span><br><span class="line">           cur = cur.next</span><br><span class="line">           <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">               <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">           cur_idx += <span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> idx == <span class="number">0</span>:   <span class="comment"># 当删除第一个节点时</span></span><br><span class="line">           self.head = cur.next</span><br><span class="line">           cur = cur.next</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       <span class="keyword">if</span> self.head <span class="keyword">is</span> self.tail:   <span class="comment"># 当只有一个节点的链表时</span></span><br><span class="line">           self.head = <span class="literal">None</span></span><br><span class="line">           self.tail = <span class="literal">None</span></span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       cur.next = cur.next.next</span><br><span class="line">       <span class="keyword">if</span> cur.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 当删除的节点是链表最后一个节点时</span></span><br><span class="line">           self.tail = cur</span><br></pre></td></tr></table></figure><h3 id="size函数实现">size函数实现</h3><p>size函数不接收参数，返回链表中节点的个数，要获得链表的节点个数，必定会遍历链表，直到最后一个节点的<code>next</code>指针指向<code>None</code>时链表遍历完成，遍历时可以用一个累加器来计算节点的个数，如下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;The list is an empty list&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            current = current.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="search函数实现">search函数实现</h3><p>search函数接收一个item参数，表示查找节点中数据域的值。search函数遍历链表，每到一个节点把当前节点的<code>data</code>值与<code>item</code>作比较，最糟糕的情况下会全遍历链表。如果查找到有些数据则返回<code>True</code>，否则返回<code>False</code>，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> current.data == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.next</span><br><span class="line">        <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h3 id="Node类与LinkedList类完整代码">Node类与LinkedList类完整代码</h3><p>最后把<code>Node类</code>和<code>LinkedList类</code>的完整代码整理如下：</p><p>Node类：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>LinkedList类及调度代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">yield</span> cur.data</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">yield</span> cur.data</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, idx, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:             <span class="comment"># 判断是否是空链表</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:   <span class="comment"># 遍历链表</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 判断是不是最后一个元素</span></span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">            cur_idx += <span class="number">1</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">        <span class="keyword">if</span> node.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.tail = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空链表时</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">            cur_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span>:   <span class="comment"># 当删除第一个节点时</span></span><br><span class="line">            self.head = cur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> self.tail:   <span class="comment"># 当只有一个节点的链表时</span></span><br><span class="line">            self.head = <span class="literal">None</span></span><br><span class="line">            self.tail = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur.next = cur.next.next</span><br><span class="line">        <span class="keyword">if</span> cur.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 当删除的节点是链表最后一个节点时</span></span><br><span class="line">            self.tail = cur</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;The list is an empty list&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            current = current.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> current.data == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.next</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    link_list = LinkedList()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">150</span>):</span><br><span class="line">        link_list.append(i)</span><br><span class="line"><span class="comment">#    print(link_list.is_empty())</span></span><br><span class="line"><span class="comment">#    link_list.insert(10, 30)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#    link_list.remove(0)</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> link_list.iter():</span><br><span class="line">        print(<span class="string">&#x27;node is &#123;0&#125;&#x27;</span>.format(node))</span><br><span class="line">    print(link_list.size())</span><br><span class="line"><span class="comment">#    print(link_list.search(20))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之链表&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="链表" scheme="https://zhaochj.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>python的模块化</title>
    <link href="https://zhaochj.github.io/2016/05/12/2016-05-12-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://zhaochj.github.io/2016/05/12/2016-05-12-%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2016-05-12T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.636Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之模块化</p><a id="more"></a><h2 id="模块化">模块化</h2><h3 id="基本概念">基本概念</h3><ul><li>在python中，模块、包和库的概念并没有那么清晰</li><li>一个文件就是一个模块，模块名就是文件名</li><li>一个目录，包含了<code>__init__.py</code>就是一个包</li><li>通常的当一个包或者若干包，包含一个<code>setup.py</code>就认为是一个可分发的库</li></ul><h3 id="导入模块">导入模块</h3><p>导入模块有两种方式，如下：</p><p>import <em>module</em></p><p>from <em>module</em> import <em>submodule</em></p><p>这两种导入方式的命名空间是不同的，以一个例子说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.basename(<span class="string">&#x27;/usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">&#x27;usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> basename</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename(<span class="string">&#x27;usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br></pre></td></tr></table></figure><p>上边的多种引用模块的方式都可以让我们使用<code>basename</code>，但各自的命名空间不一样。</p><h3 id="重命名">重命名</h3><p>引入模块的重命名用<code>as</code>语法，看下边的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> basename <span class="keyword">as</span> os_basename</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_basename(<span class="string">&#x27;/usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><p>当然直接用<code>import</code>导入模块时也可以用<code>as</code>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys <span class="keyword">as</span> system</span><br></pre></td></tr></table></figure><p>这样sys模块的名称被重命名为system了</p><p>当一个模块被导入时，真正发生了什么呢？看下边的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># pwd</span></span><br><span class="line">/root/virtual_env/fourth_week/learning</span><br><span class="line"> </span><br><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># ls</span></span><br><span class="line">foo.py  main.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># cat foo.py </span></span><br><span class="line"><span class="comment">#!/root/.pyenv/versions/pythv_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am bar in foo&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># cat main.py </span></span><br><span class="line"><span class="comment">#!/root/.pyenv/versions/pythv_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"> </span><br><span class="line">foo.bar()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># python3 main.py </span></span><br><span class="line">ha ha ha</span><br><span class="line">i am bar <span class="keyword">in</span> foo</span><br></pre></td></tr></table></figure><p>在<code>main.py</code>文件中用<code>import foo</code>的方式导入了<code>foo</code>模块，接着再调用了<code>foo</code>模块的<code>bar</code>函数，当执行<code>main.py</code>文件时，首先执行了<code>foo</code>模块的<code>print('ha ha ha')</code>语句，再执行了<code>bar</code>函数。</p><p>这说明当导入一个模块时，其实是执行了此模块，所以当一个文件是以模块的形式被导入时，应避免此模块中有一些全局性的语句，比如这时的<code>print('ha ha ha')</code>语句。</p><p>用<code>from foo import bar</code>的导入方式也是执行了<code>foo</code>文件，作如下验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># cat main.py </span></span><br><span class="line"><span class="comment">#!/root/.pyenv/versions/pythv_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># python3 main.py </span></span><br><span class="line">ha ha ha</span><br></pre></td></tr></table></figure><h2 id="相对导入和绝对导入">相对导入和绝对导入</h2><p>在接下来的代码示例不再方便使用jumper来展示，开始用pycharm开发工具来展示代码。</p><p>为了说明模块的相对导入和绝对导入，在pycharm中创建了一个<code>reference</code>包，包内有<code>bar.py</code>和<code>foo.py</code>两个模块，在<code>reference</code>包外有一个<code>main.py</code>模块。目录结构如下图：</p><p><img src="/images/2016-05-12-01.png" alt="目录结构"></p><p>各个模块中的内容如下：</p><p><a href="http://foo.py">foo.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am in reference.foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://bar.py">bar.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> reference.foo <span class="keyword">import</span> fn</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    fn()</span><br></pre></td></tr></table></figure><p><a href="http://main.py">main.py</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from reference.bar import bar</span><br><span class="line"> </span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>当运行<code>main.py</code>时会得到下边的输出内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am <span class="keyword">in</span> reference.foo</span><br></pre></td></tr></table></figure><p>上边的<code>bar.py</code>和<code>main.py</code>模块中的<code>from</code>语句都是从包名<code>reference</code>这里开始引用的，这种引用就是<code>绝对引用</code>。</p><p>因<code>foo.py</code>和<code>bar.py</code>两个模块都是在包<code>reference</code>内，所以<code>bar.py</code>里引用<code>foo</code>模块时可以使用相对引用的方式，如下：</p><p><a href="http://bar.py">bar.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .foo <span class="keyword">import</span> fn</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    fn()</span><br></pre></td></tr></table></figure><p>这样就是<code>相对引用</code>的方式。</p><h3 id="循环导入">循环导入</h3><p>在实际编码中要避免循环导入的，举一个例子说明什么是循环引入。</p><p><a href="http://xn--foo-cy0e153b.py">假如foo.py</a>、<a href="http://bar.py">bar.py</a>、<a href="http://main.py">main.py</a>，这三个模块都在同一个包内，各自的代码如下：</p><p><a href="http://foo.py">foo.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bar <span class="keyword">import</span> fn <span class="keyword">as</span> bar</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    bar()</span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://bar.py">bar.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> fn <span class="keyword">as</span> foo</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    foo()</span><br><span class="line">    print(<span class="string">&#x27;i am bar&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://main.py">main.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> fn</span><br><span class="line"> </span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>当运行main.py时，抛出以下异常：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/pythonlearning/fourth_week/reference/main.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> foo <span class="keyword">import</span> fn</span><br><span class="line">  File <span class="string">&quot;D:\pythonlearning\fourth_week\reference\foo.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> bar <span class="keyword">import</span> fn <span class="keyword">as</span> bar</span><br><span class="line">  File <span class="string">&quot;D:\pythonlearning\fourth_week\reference\bar.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> foo <span class="keyword">import</span> fn <span class="keyword">as</span> foo</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;fn&#x27;</span></span><br></pre></td></tr></table></figure><p>上边的foo模块和bar模块就发生了循环引用的情况，这样在执行main.py时，解释器就会抛出上边的异常信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之模块化&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模块化" scheme="https://zhaochj.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>python异常处理</title>
    <link href="https://zhaochj.github.io/2016/05/12/2016-05-12-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://zhaochj.github.io/2016/05/12/2016-05-12-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2016-05-12T09:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.634Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之异常处理</p><a id="more"></a><h2 id="异常处理">异常处理</h2><h3 id="错误与异常">错误与异常</h3><p>错误：通常指程序运行中不可恢复的问题</p><p>异常：通常指可以在程序运行时恢复的问题</p><p>异常处理的一般语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try: (1)</span><br><span class="line">    block</span><br><span class="line">except ExceptionClass as e:  (2)</span><br><span class="line">    pass</span><br><span class="line">finally:  (3)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><ol><li>异常处理以<code>try</code>开始</li><li>当异常发生时按照一定的规则执行<code>except</code>块，可以存在多个<code>except</code>块</li><li>可选的<code>finally</code>块，无论如何都会被执行，通常用于清理工作</li></ol><p>以一个例子来说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------ZeroDivisionError                         Traceback (most recent call last)&lt;ipython-input-3-a0641230c7a8&gt; in &lt;module&gt;()----&gt; 1 3/0ZeroDivisionError: division by zero</code></pre><p>显然，数字0是不能做除数的，这里会抛出<code>ZeroDivisionError</code>错误，程序执行被中止。如果我们想执行<code>3/0</code>时不抛出这样的异常，而是可以人为处理，这时就需要做异常处理了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="number">3</span>/<span class="number">0</span></span><br><span class="line">    print(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&#x27;finally&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>startdivision by zerofinally</code></pre><p>上边代码中人为加入了两个<code>print</code>语句是为了看清代码的执行流程。解释器当执行到<code>3/0</code>时，会抛出上边的<code>ZeroDivisionError</code>异常，此时解释器就不会在执行<code>try</code>语句中的<code>print('end')</code>语句了，而是被<code>except</code>语句捕捉到，执行此代码块中的语句<code>print(e)</code>，这里的<code>e</code>是一个变量，表示把异常的信息保存到这个变量上，这是一个可选择参数，如果没有<code>as e</code>，那异常信息就不会被保存。最后再执行了<code>finally</code>代码块中的语句。</p><p><code>except</code>代码是一个类型匹配的过程，可以允许多次出现，但要注意匹配的顺序，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">3</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">&#x27;Exception&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">&#x27;ZeroDivisionError&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Exception</code></pre><p><code>3/0</code>不是会抛出<code>ZeroDivisionError</code>的异常吗？这里怎么没有被捕捉到，而是被<code>except Exception:</code>语句捕捉到了？这是因为异常在python也是一个class，决大多数的异常都是在<code>Exception</code>类中的，<code>ZeroDivisionError</code>是<code>Exception</code>的子类，所以在实际编码中，当有多个<code>except</code>语句时应该把子类放在前面，父类写在后边。</p><p>如果<code>except</code>后边不接任何类名，表示可以捕捉任何的异常信息。</p><p>再来看一下<code>finally</code>语句，它在异常处理中不管是否捕捉到异常，<code>finally</code>语句都会被执行，以下边的例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call p function&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> p()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">main()</span><br></pre></td></tr></table></figure><pre><code>call p functionfinally...</code></pre><p>在<code>main</code>函数中有一个<code>return</code>语句，执照常理来说，在一个函数中执行<code>return</code>语句时，此函数就执行结束了，但这里为什么还会执行<code>finally</code>语句呢？</p><p>执行流程大致是这样的：</p><p>当解释器执行到<code>return p()</code>语句时，先调用<code>p</code>函数，输出了<code>call p function</code>，接着并没有把结果return回去，而是把此时的状态保存起来后去执行<code>finally</code>语句，执行完成后把之前保存的状态恢复后再执行<code>return</code>操作，这样就成上边调用<code>main</code>函数的输出信息了。</p><h3 id="抛出异常">抛出异常</h3><p>抛出异常使用<code>raise</code>语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;i &lt; 0&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">fn(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------Exception                                 Traceback (most recent call last)&lt;ipython-input-3-87e48ca0d898&gt; in &lt;module&gt;()      3         raise Exception('i &lt; 0')      4 ----&gt; 5 fn(-4)&lt;ipython-input-3-87e48ca0d898&gt; in fn(i)      1 def fn(i):      2     if i &lt; 0:----&gt; 3         raise Exception('i &lt; 0')      4       5 fn(-4)Exception: i &lt; 0</code></pre><p><code>raise Exception('i &lt; 0')</code>语句就是抛出一个自定义异常信息，<code>Exception</code>是类，其实质是抛出了<code>Exception</code>类的一个实例。</p><h3 id="未处理异常">未处理异常</h3><p>异常未处理时会往上层抛出，如果都没有异常处理时会交给python解释器处理，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    <span class="number">3</span>/<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    fn()</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------ZeroDivisionError                         Traceback (most recent call last)&lt;ipython-input-5-57d9f8a0a6b1&gt; in &lt;module&gt;()      5     fn()      6 ----&gt; 7 main()&lt;ipython-input-5-57d9f8a0a6b1&gt; in main()      3       4 def main():----&gt; 5     fn()      6       7 main()&lt;ipython-input-5-57d9f8a0a6b1&gt; in fn()      1 def fn():----&gt; 2     3/0      3       4 def main():      5     fn()ZeroDivisionError: division by zero</code></pre><p>上边的异常信息就一层层的往上层抛出，最后由解释器处理了。如果要在<code>main()</code>捕捉异常呢，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><pre><code>division by zero</code></pre><h3 id="自定义异常">自定义异常</h3><p>自定义异常：当一个类继承自Exception类或其派生类时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> MyException(<span class="string">&#x27;exception&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------MyException                               Traceback (most recent call last)&lt;ipython-input-8-c6b10bf8a778&gt; in &lt;module&gt;()----&gt; 1 raise MyException('exception')MyException: exception</code></pre><p><code>MyException</code>类继承自<code>Exception</code>类，所以<code>MyException</code>类是一个自定义异常类，当执行<code>raise MyException('exception')</code>语句时抛出的异常就是自定义的异常类。</p><p>捕获自定义异常，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyException(<span class="string">&#x27;exception&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> MyException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><pre><code>exception</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之异常处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="异常" scheme="https://zhaochj.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>python的property实现原理</title>
    <link href="https://zhaochj.github.io/2016/05/10/2016-05-10-property%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhaochj.github.io/2016/05/10/2016-05-10-property%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2016-05-10T12:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.635Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之property的实现原理</p><a id="more"></a><p>以实际的例子来说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,fget=None,fset=None,fdel=None</span>):</span></span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fget(instance)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.fset(instance,value)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.fdel(instance)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fget = fn</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fset = fn</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deler</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fdel = fn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.__val = val</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @val.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_val</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        self.__val = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Spam(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.val   <span class="comment">#Spam.val.__get__(s,Spam)</span></span><br></pre></td></tr></table></figure><pre><code>4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.val = <span class="number">3</span>  <span class="comment">#Spam.val.__set__(s,3)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.val</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><p>现在来分析一下上边的代码：</p><p>当执行<code>s = Spam(4)</code>时，调用比较简单，就是直接执行类<code>Spam</code>的构建函数<code>__init__</code>，这样就得到一个私有变量<code>__val</code>，值为<code>4</code>。</p><p>当执行<code>s.val</code>时，因<code>val</code>函数被<code>Property</code>所装饰，所以<code>val</code>函数可以像属性一样调用；因<code>Property</code>类是一个描述器，所以<code>s.val</code>操作首先会实例化<code>Property</code>类，把<code>__init__</code>函数中的<code>fget</code>指向<code>Spam</code>类的<code>val</code>函数，把<code>fset</code>指向<code>Spam</code>类的<code>set_val</code>函数，接着就去调用<code>Property</code>类的<code>__get__</code>函数代码块，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">       <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> self.fget(instance)</span><br></pre></td></tr></table></figure><p>这里的<code>instance</code>指向<code>Spam</code>类的实例<code>s</code>，<code>cls</code>指向<code>Spam</code>类，因<code>fget</code>已指向了<code>Spam</code>类的<code>val</code>函数，所以if语句为True，执行<code>return self.fget(instance)</code>语句，这里的<code>self.fget</code>指向了<code>Spam</code>类的<code>val</code>函数，<code>instance</code>指向了<code>Spam</code>类的实例<code>s</code>，其实质就是调用<code>Spam</code>类的<code>val</code>函数，即返回<code>__val</code>的值。这个调用过程其实质与<code>Spam.val.__get__(s,Spam)</code>相同。</p><p>当执行<code>s.val = 3</code>时，整个调用过程与执行<code>s.val</code>的过程类似，只是把调用<code>__get__</code>换成了调用<code>__set__</code>函数，这个调用过程其实质与<code>Spam.val__set__(s,3)</code>相同。</p><p><strong>有个疑问？</strong></p><p>在<code>2016-05-06-面向对象-封装-property.md</code>中讲如何使用<code>@property</code>这个装饰器时说被<code>@property</code>装饰的函数名(<em>FunName</em>)与被&quot;@<em>FunName</em>.setter&quot;装饰器装饰的函数名要相同，但今天这里讲<code>property</code>的是如何实现时，又需要把两个函数的名称设置成不同，比如上边的<code>val</code>和<code>set_val</code>，这是为什么？</p><p>既然可以对一个类的实例变量做装饰，那对类变量也是一样的，如下边代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassProperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fn = fn</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.fn(cls)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam1</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__name__.lower()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = Spam1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.val</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.name</span><br></pre></td></tr></table></figure><pre><code>'spam1'</code></pre><p>分析一下上边的代码：</p><p>当python解释器执行到下边代码块时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam1</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__name__.lower()</span><br></pre></td></tr></table></figure><p>解释器会创建一个名为<code>Spam1</code>的类空间，在此空间中创建一个<code>__val</code>的私有变量；当执行到第一个被<code>@ClassProperty</code>装饰器装饰的<code>val</code>函数时，会把<code>val</code>这个函数名称传递给<code>ClassProperty</code>类的<code>fn</code>参数，接着下边的函数<code>name</code>也会被传递给<code>ClassProperty</code>类的<code>fn</code>参数，这样函数<code>val</code>已不再是原先的函数了，而是一个被<code>ClassProperty</code>装饰过的函数。</p><p>当执行<code>s1 = Spam1()</code>时，只是实例化了一个类，比较好理解。</p><p>当执行<code>s1.val</code>时，是去调用<code>ClassProperty</code>类的<code>__get__</code>函数，把<code>Spam1</code>的实例<code>s1</code>传递给<code>instance</code>参数，把<code>Spam1</code>传递给<code>cls</code>参数，当执行<code>return self.fn(cls)</code>语句时其实质是执行<code>val(cls)</code>，所以是返回一个函数，此时解释器回到<code>Spam1</code>类中的<code>val</code>函数，执行<code>return cls.__val</code>，所以就输出了<code>3</code>。</p><p>执行<code>s1.name</code>语句也是类似的调用过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之property的实现原理&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="property实现" scheme="https://zhaochj.github.io/tags/property%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>python描述器</title>
    <link href="https://zhaochj.github.io/2016/05/09/2016-05-09-%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    <id>https://zhaochj.github.io/2016/05/09/2016-05-09-%E6%8F%8F%E8%BF%B0%E5%99%A8/</id>
    <published>2016-05-09T14:00:00.000Z</published>
    <updated>2020-08-08T15:29:11.633Z</updated>
    
    <content type="html"><![CDATA[<p>python学习笔记之描述器</p><a id="more"></a><h2 id="描述器">描述器</h2><p>一个类实现了<code>__get__</code>、<code>__set__</code>、<code>__delete__</code>三个方法，这个类就叫描述器</p><p>直接来看一个描述器的实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __get__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __set__&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> isinstance(value,(int,float)):</span><br><span class="line">            instance.__dict__[self.name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;execepted int or float&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Number(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = Number(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><p>这样就定义了一个描述器<code>Number</code>类，这个类的作用是描述实例化<code>Point</code>类时<code>x</code>和<code>y</code>变量的类型必须为整型或浮点型，如果不满足这两种类型中的一个，那抛出TypeError的异常。为了验证代码的调用关系，有意在<code>Number</code>类中加了一些<code>print</code>语句，在实例代码中应该把这语句去除。现在来实际实例化<code>Point</code>类试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = Point(<span class="number">2</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure><pre><code>call __set__call __set__</code></pre><p>当执行<code>p1 = Point(2,8)</code>时发生了什么呢？</p><p>1.当python解释器解析到</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Number(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = Number(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><p>代码块时，解释器会创建一个<code>Point</code>类对象，此对象中有<code>x</code>类变量，且此变量指向<code>Number</code>类的一个实例，有<code>y</code>类变量，且此变量指向<code>Number</code>类的另一个实例；解释器还会创建一个<code>__init__</code>函数，此函数接收两个参数。</p><p>2.当解释器执行到<code>p1 = Point(2,8)</code>时，<code>Point</code>类中的<code>__init__</code>构建函数被执行，执行以下两代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.x = x</span><br><span class="line">self.y = y</span><br></pre></td></tr></table></figure><p>解释器先执行<code>self.x = x</code>代码，这里的<code>self.x</code>是一个变量对象，等号后边的<code>x</code>是指向类变量<code>x = Number('x')</code>中的<code>Number</code>类实例，这时解释器会执行<code>Number</code>类中的<code>__set__</code>函数，把<code>p1</code>实例传递给<code>instance</code>这个形参，把<code>2</code>传递给<code>value</code>这个形参，执行此函数体的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def __set__(self,instance,value):</span><br><span class="line">        print(&#39;call __set__&#39;)</span><br><span class="line">        if isinstance(value,(int,float)):</span><br><span class="line">            instance.__dict__[self.name] &#x3D; value</span><br><span class="line">        else:</span><br><span class="line">            raise TypeError(&#39;execepted int or float&#39;)</span><br></pre></td></tr></table></figure><p>首先打印出<code>call __set__</code>，再执行if语句，为True时把<code>p1</code>实例中<code>__dict__</code>这个特殊方法中key为<code>x</code>的值指向<code>2</code>；如果if语句的判断结果为False，那抛出异常。</p><p>接着解释器往下执行代码，开始执行构建函数中的<code>self.y = y</code>语句，这个过程与执行<code>self.x = x</code>语句一样。这样就完成了<code>p1 = Point(2,8)</code>这个语句的执行，其<strong>实质就是会去执行Number类的<code>__set__</code>函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br></pre></td></tr></table></figure><pre><code>call __get__2</code></pre><p>当执行上边的<code>p1.x</code>时发生了什么？</p><p>执行<code>p1.x</code>是去调用<code>Point</code>类的实例变量<code>x</code>，从上边的分析可知，这个实例变量是指向<code>Number('x')</code>这个实例，这时解释器会执行<code>Number</code>类的<code>__get__</code>方法，会把<code>p1</code>这个实例名作为变量传递给<code>instance</code>这个形参，把<code>p1</code>的类名作为变量传递给<code>cls</code>，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __get__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><p>先打印出<code>call __get__</code>，然后取出<code>p1</code>实例中<code>__dict__</code>中key为<code>x</code>的值返回，这样就得到执行<code>p1 = Point(2,8)</code>语句时<code>2</code>这个数字。</p><p>总结起来，访问一个使用了描述器的类的实例属性时，<strong>其实质是访问了描述器的<code>__get__</code>函数</strong>。</p><p>其实访问<code>p1.x</code>和访问<code>Point.x.__get__(p1,Point)</code>的过程是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x = <span class="number">10</span></span><br></pre></td></tr></table></figure><pre><code>call __set__</code></pre><p>当执行上边的<code>p1.x = 10</code>语句时发生了什么呢？</p><p>执行<code>p1.x = 10</code>是想把<code>Point</code>类的<code>p1</code>实例的实例变量指向一个数字<code>10</code>，实例变量<code>x</code>是指向<code>Number('x')</code>这个实例，其实质是去调用<code>Number</code>类的<code>__set__</code>方法，上边已对调用<code>__set__</code>函数进行了详细了分析，不再赘述。</p><p>其实执行<code>p1.x = 10</code>和执行<code>Point.x.__set__(p1.10)</code>的过程是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br></pre></td></tr></table></figure><pre><code>call __get__10</code></pre><p>再来给<code>x</code>一个不是<code>int</code>或<code>float</code>型的字符，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x = <span class="string">&#x27;zhaochj&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>call __set__---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-8-47a1681546d4&gt; in &lt;module&gt;()----&gt; 1 p1.x = 'zhaochj'&lt;ipython-input-2-087bfda6d4c9&gt; in __set__(self, instance, value)     12             instance.__dict__[self.name] = value     13         else:---&gt; 14             raise TypeError('execepted int or float')     15      16     def __delete__(self,instance):TypeError: execepted int or float</code></pre><p>在类型检查时没有通过，所以抛出我们自定义的异常信息。</p><p>在<code>Point</code>类中，按理说<code>类变量x</code>是可以像<code>Point.x</code>来访问的，但执行时，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.x</span><br></pre></td></tr></table></figure><pre><code>call __get__---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-9-7a7eae6dfbec&gt; in &lt;module&gt;()----&gt; 1 Point.x&lt;ipython-input-2-087bfda6d4c9&gt; in __get__(self, instance, cls)      5     def __get__(self,instance,cls):      6         print('call __get__')----&gt; 7         return instance.__dict__[self.name]      8       9     def __set__(self,instance,value):AttributeError: 'NoneType' object has no attribute '__dict__'</code></pre><p>这是因为在调用<code>__get__</code>方法时<code>instance</code>参数接收到了一个<code>None</code>对象，这是因为类<code>Point</code>并没有被实例化，所以<code>return</code>时会报错。可以对<code>__get__</code>函数做如下修正，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberFix</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __get__&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __set__&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> isinstance(value,(int,float)):</span><br><span class="line">            instance.__dict__[self.name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;execepted int or float&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2</span>:</span></span><br><span class="line">    x = NumberFix(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = NumberFix(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__&lt;__main__.NumberFix at 0x7f8030321550&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = Point2(<span class="number">4</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><pre><code>call __set__call __set__</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__&lt;__main__.NumberFix at 0x7f8030321550&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.x = <span class="number">30</span></span><br></pre></td></tr></table></figure><pre><code>call __set__</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__30</code></pre><p>这样，<code>NumberFix</code>算是一个完整的描述器。</p><p>这样，<code>NumberFix</code>这个描述器就完成了对实例化类<code>Point2</code>时传入参数类型的限制，允许的类型在描述器<code>NumberFix</code>的<code>__set__</code>函数中进行设置。</p><p>上边的例子中都是对各个参数进行同一类型的检查，如果我们要对每个参数都做不同的类型检查呢？比如要求<code>x</code>参数为<code>int</code>型，<code>y</code>参数为<code>str</code>型。对上边的描述器做如下改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeCheck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,expected_type</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.expected_type = expected_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;expected type &#123;0&#125;&#x27;</span>.format(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3</span>:</span></span><br><span class="line">    x = TypeCheck(<span class="string">&#x27;x&#x27;</span>,(int,))</span><br><span class="line">    y = TypeCheck(<span class="string">&#x27;y&#x27;</span>,(str,))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 = Point3(<span class="number">10</span>,<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.x</span><br></pre></td></tr></table></figure><pre><code>10</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.y</span><br></pre></td></tr></table></figure><pre><code>'zhaochj'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.x = <span class="number">40</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.x</span><br></pre></td></tr></table></figure><pre><code>40</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p4 = Point3(<span class="number">10</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-67-7765c7ef841b&gt; in &lt;module&gt;()----&gt; 1 p4 = Point3(10,30)&lt;ipython-input-58-20cc1f0ef40f&gt; in __init__(self, x, y)      5     def __init__(self,x,y):      6         self.x = x----&gt; 7         self.y = y&lt;ipython-input-51-d7bab526d123&gt; in __set__(self, instance, value)     11     def __set__(self,instance,value):     12         if not isinstance(value,self.expected_type):---&gt; 13             raise TypeError('expected type &#123;0&#125;'.format(self.expected_type))     14         instance.__dict__[self.name] = value     15 TypeError: expected type (&lt;class 'str'&gt;,)</code></pre><p>这样就可以实现对不同的变量限制不同的类型，当对<code>x</code>和<code>y</code>的类型有变更时只需要修改<code>Point3</code>类即可。</p><p>其实还可以使用装饰器来达到同样的效果，这是一个装饰类<code>TypeCheck</code>的装饰器，代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeinsert</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">        @wraps(cls)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">                setattr(cls,k,TypeCheck(k,v))</span><br><span class="line">            <span class="keyword">return</span> cls</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@typeinsert(x=int,y=float,z=str,m=str)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y,z,m</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.z = z</span><br><span class="line">        self.m = m</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Spam(x=<span class="string">&#x27;dfd&#x27;</span>,y=<span class="number">10</span>,z=<span class="number">10</span>,m=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>好像没有达到预想的效果，没有想明白，相关视频在“09-面向对象-8”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python学习笔记之描述器&lt;/p&gt;
    
    </summary>
    
    
      <category term="python学习笔记" scheme="https://zhaochj.github.io/categories/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="描述器" scheme="https://zhaochj.github.io/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
  </entry>
  
</feed>
