<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test.md</title>
      <link href="/2020/08/08/test-md/"/>
      <url>/2020/08/08/test-md/</url>
      
        <content type="html"><![CDATA[<p>#一标题</p><p>111111</p><p>##二级标题</p><p>2222222222</p><p>###三级标题</p><p>333333333</p><h4 id="四级标题">四级标题</h4><p>44444444444</p><p>hahahah</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>os模块常用方法整理</title>
      <link href="/2016/09/15/2016-09-15-os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2016/09/15/2016-09-15-os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>python标准库中的模块比较多，对一个python程序员来说，标准库是不得不经常检阅的资料，python语言因有了如此丰富的标准库所以才显得那么耀眼，对我这个python菜鸟而言，python之路还很长，坚持吧，坚持每天都去标准库翻阅一个模块来看看。本文记录<code>os</code>这个模块的常用方法。</p><a id="more"></a><p>os模块为用户提供一个各种各样的操作系统的一个接口抽象，这里把常用的功能整理如下。</p><h2 id="name属性">name属性</h2><p>在python语言中要使用一个模块需要使用<code>import</code>语句把此模块导进到当前的命名空间里。<code>os</code>模块中的<code>name</code>属性打印出当前操作系统所属的平台，类linux系统输出<code>posix</code>，window用户输出<code>nt</code>。</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line">In [<span class="number">2</span>]: os.name</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;posix&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="uname">uname()</h2><p>返回当前操作系统的信息，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: os.uname()</span><br><span class="line">Out[<span class="number">30</span>]: posix.uname_result(sysname=<span class="string">&#x27;Linux&#x27;</span>, nodename=<span class="string">&#x27;neal-System-Product-Name&#x27;</span>, release=<span class="string">&#x27;4.4.0-36-generic&#x27;</span>, version=<span class="string">&#x27;#55-Ubuntu SMP Thu Aug 11 18:01:55 UTC 2016&#x27;</span>, machine=<span class="string">&#x27;x86_64&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="getcwd-和chdir-path">getcwd()和chdir(<em>path</em>)</h2><p>getcwd方法是获取当前的工作路径，而chdir方法是切换工作路径，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">&#x27;/home/neal/private/sync/temp/logscan-api&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">4</span>]: os.chdir(<span class="string">&#x27;/tmp&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">5</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;/tmp&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="fsencode-filename-和fsdecode-filename">fsencode(<em>filename</em>)和fsdecode(<em>filename</em>)</h2><p>表示使用文件系统来编码或解码文件名，fsencode方法接收<code>str</code>，返回<code>bytes</code>,fsdecode方法接收<code>bytes</code>，返回<code>str</code>，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: encode = os.fsencode(<span class="string">&#x27;/tmp/jdk.sh&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">8</span>]: encode</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">b&#x27;/tmp/jdk.sh&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">9</span>]: os.fsdecode(encode)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">&#x27;/tmp/jdk.sh&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="getenv-key-default-None-和getenvb-key-default-None-方法">getenv(<em>key, default=None</em>)和getenvb(<em>key, default=None</em>)方法</h2><p>表示获取指定环境变量的值，getenv方法接收<code>str</code>，返回<code>str</code>，getenvb方法接收<code>bytes</code>，返回<code>bytes</code>，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: os.getenv(<span class="string">&#x27;PATH&#x27;</span>)</span><br><span class="line">Out[<span class="number">27</span>]: <span class="string">&#x27;/home/neal/.pyenv/versions/logscan-api/bin:/home/neal/.pyenv/libexec:/home/neal/.pyenv/plugins/python-build/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/bin:/home/neal/opt/jdk1.8.0_65/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/shims:/home/neal/.pyenv/shims:/home/neal/.pyenv/bin:/home/neal/bin:/usr/local/jdk1.8.0_65/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/neal/opt/node-v6.4.0-linux-x64/bin:/home/neal/opt/pycharm/bin&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">28</span>]: os.getenvb(<span class="string">b&#x27;PATH&#x27;</span>)</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">b&#x27;/home/neal/.pyenv/versions/logscan-api/bin:/home/neal/.pyenv/libexec:/home/neal/.pyenv/plugins/python-build/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/bin:/home/neal/opt/jdk1.8.0_65/bin:/home/neal/.pyenv/plugins/pyenv-virtualenv/shims:/home/neal/.pyenv/shims:/home/neal/.pyenv/bin:/home/neal/bin:/usr/local/jdk1.8.0_65/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/home/neal/opt/node-v6.4.0-linux-x64/bin:/home/neal/opt/pycharm/bin&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">29</span>]: print(os.getenv(<span class="string">&#x27;PAT&#x27;</span>))</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="listdir-path-’-’">listdir(<em>path=’.’</em>)</h2><p>返回指定路径下的文件，默认是当前目录，返回的是一个list，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;/home/neal/private/sync/temp/logscan-api&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">6</span>]: os.listdir()</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">[<span class="string">&#x27;app.py&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;application.conf&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.git&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_scripts&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.gitignore&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.python-version&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;tornado-4.4.1.tar.gz&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;logscan&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.idea&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;logscan-api.xmind&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">7</span>]: os.listdir(path=<span class="string">&#x27;/tmp&#x27;</span>)</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">[<span class="string">&#x27;+~JF3877189641662443938.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;fcitx-qimpanel:0.pid&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.ICE-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.com.google.Chrome.fVrOnx&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.font-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;systemd-private-c3a4fbe0a0c643faa8d68d5d7fd1599d-rtkit-daemon.service-gcBEfw&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF8633920933949119482.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.X0-lock&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;fcitx-socket-:0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.X11-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;config-err-s5rtZ6&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hsperfdata_neal&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;systemd-private-c3a4fbe0a0c643faa8d68d5d7fd1599d-colord.service-GLdwh0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;unity_support_test.0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;orbit-neal&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF1201684757014287454.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.xrdp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;jdk.sh&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF7598506182566291945.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.wine-1000&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.Test-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;iconcache-6NAcAO&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;+~JF1811871931355839416.tmp&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;.XIM-unix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;systemd-private-c3a4fbe0a0c643faa8d68d5d7fd1599d-systemd-timesyncd.service-ERVXh5&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="mkdir-path-mode-0o777-dir-fd-None-和makedirs-name-mode-0o777-exist-ok-False">mkdir(path, mode=0o777, *, dir_fd=None)和makedirs(name, mode=0o777, exist_ok=False)</h2><p>mkdir不能递归的创建目录，而makedirs可以递归创建，<code>mode=0o777</code>与<code>mode=0o775</code>的效果是一样的，目录的权限都是<code>drwxrwxr-x</code>，不知道为何？测试如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: []</span><br><span class="line"> </span><br><span class="line">In [<span class="number">25</span>]: os.mkdir(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">26</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">27</span>]: os.mkdir(<span class="string">&#x27;/tmp/test/b/bb&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">FileNotFoundError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-27</span><span class="number">-0</span>ce8d4717d44&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.mkdir(&#x27;/tmp/test/b/bb&#x27;)</span><br><span class="line"> </span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;/tmp/test/b/bb&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">28</span>]: os.makedirs(<span class="string">&#x27;/tmp/test/b/bb&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">29</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>再来看看创建目录的权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ <span class="built_in">pwd</span></span><br><span class="line">/tmp/<span class="built_in">test</span></span><br><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ ll</span><br><span class="line">总用量 16</span><br><span class="line">drwxrwxr-x  4 neal neal 4096 9月  15 15:32 ./</span><br><span class="line">drwxrwxrwt 17 root root 4096 9月  15 15:33 ../</span><br><span class="line">drwxrwxr-x  2 neal neal 4096 9月  15 15:31 a/</span><br><span class="line">drwxrwxr-x  3 neal neal 4096 9月  15 15:32 b/</span><br><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ ll b</span><br><span class="line">总用量 12</span><br><span class="line">drwxrwxr-x 3 neal neal 4096 9月  15 15:32 ./</span><br><span class="line">drwxrwxr-x 4 neal neal 4096 9月  15 15:32 ../</span><br><span class="line">drwxrwxr-x 2 neal neal 4096 9月  15 15:32 bb/</span><br></pre></td></tr></table></figure><h2 id="remove-path-dir-fd-None-与removedirs-name">remove(path, *, dir_fd=None)与removedirs(name)</h2><p>remove只能删除文件，如果删除的是一个目录会报错，removedirs递归的删除空目录，如果是非空目录，依然会报错，测试如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: os.listdir(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line">Out[<span class="number">35</span>]: [<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">36</span>]: os.remove(<span class="string">&#x27;/tmp/test/a/1.txt&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">37</span>]: os.listdir(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line">Out[<span class="number">37</span>]: [<span class="string">&#x27;aa&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">38</span>]: os.remove(<span class="string">&#x27;/tmp/test/a&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">IsADirectoryError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-38</span>-fdb1cdf283f6&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.remove(&#x27;/tmp/test/a&#x27;)</span><br><span class="line"> </span><br><span class="line">IsADirectoryError: [Errno <span class="number">21</span>] Is a directory: <span class="string">&#x27;/tmp/test/a&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:tmp$ <span class="built_in">pwd</span></span><br><span class="line">/tmp</span><br><span class="line">neal@neal-System-Product-Name:tmp$ tree <span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">test</span>/</span><br><span class="line">├── a</span><br><span class="line">│   └── aa</span><br><span class="line">└── b</span><br><span class="line">    ├── 2.txt</span><br><span class="line">    └── bb</span><br><span class="line"> </span><br><span class="line">4 directories, 1 file</span><br></pre></td></tr></table></figure><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">46</span>]: os.removedirs(<span class="string">&#x27;/tmp/test/a/aa&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">47</span>]: os.listdir(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line">Out[<span class="number">47</span>]: [<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">48</span>]: os.removedirs(<span class="string">&#x27;/tmp/test/b/bb&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">49</span>]: os.listdir(<span class="string">&#x27;/tmp/test/b&#x27;</span>)</span><br><span class="line">Out[<span class="number">49</span>]: [<span class="string">&#x27;2.txt&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">In [<span class="number">50</span>]: os.removedirs(<span class="string">&#x27;/tmp/test/b&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">OSError                                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-50</span><span class="number">-03112</span>f9e37d0&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.removedirs(&#x27;/tmp/test/b&#x27;)</span><br><span class="line"> </span><br><span class="line">/home/neal/.pyenv/versions/<span class="number">3.5</span><span class="number">.2</span>/lib/python3<span class="number">.5</span>/os.py <span class="keyword">in</span> removedirs(name)</span><br><span class="line">    <span class="number">257</span> </span><br><span class="line">    <span class="number">258</span>     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--&gt; 259     rmdir(name)</span></span><br><span class="line"><span class="string">    260     head, tail = path.split(name)</span></span><br><span class="line"><span class="string">    261     if not tail:</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">OSError: [Errno 39] Directory not empty: &#x27;/tmp/test/b&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="rename-src-dst-src-dir-fd-None-dst-dir-fd-None-与renames-old-new">rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)与renames(old, new)</h2><p>两个方法都表示重命名文件或目录，如果dst的名称已存在，那将会被替换，测试如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ <span class="built_in">pwd</span></span><br><span class="line">/tmp/<span class="built_in">test</span></span><br><span class="line">neal@neal-System-Product-Name:<span class="built_in">test</span>$ tree .</span><br><span class="line">.</span><br><span class="line">├── test1</span><br><span class="line">│   └── 1.txt</span><br><span class="line">└── test2</span><br><span class="line">    └── 2.txt</span><br><span class="line"> </span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: os.rename(<span class="string">&#x27;/tmp/test/test1&#x27;</span>, <span class="string">&#x27;/tmp/test/test2&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">OSError                                   Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-4</span><span class="number">-0</span>d34cb8a001e&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 os.rename(&#x27;/tmp/test/test1&#x27;, &#x27;/tmp/test/test2&#x27;)</span><br><span class="line"> </span><br><span class="line">OSError: [Errno 39] Directory not empty: &#x27;/tmp/test/test1&#x27; -&gt; &#x27;/tmp/test/test2&#x27;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">5</span>]: os.rename(<span class="string">&#x27;/tmp/test/test1&#x27;</span>, <span class="string">&#x27;/tmp/test/test3&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">neal@neal-System-Product-Name:test$ tree .</span><br><span class="line">.</span><br><span class="line">├── test2</span><br><span class="line">│   └── <span class="number">2.</span>txt</span><br><span class="line">└── test3</span><br><span class="line">    └── <span class="number">1.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span> directories, <span class="number">2</span> files</span><br><span class="line"> </span><br><span class="line">In [<span class="number">8</span>]: os.renames(<span class="string">&#x27;/tmp/test/test3&#x27;</span>, <span class="string">&#x27;/tmp/test/test1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">neal@neal-System-Product-Name:test$ tree .</span><br><span class="line">.</span><br><span class="line">├── test1</span><br><span class="line">│   └── <span class="number">1.</span>txt</span><br><span class="line">└── test2</span><br><span class="line">    └── <span class="number">2.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>两个方法使用方法相似。</p><p>更多os模块的方法请看官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python标准库，os模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中的编码与解码</title>
      <link href="/2016/09/14/2016-09-14-%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/"/>
      <url>/2016/09/14/2016-09-14-%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>对python的初学者来说，对字符的<code>编码与解码</code>是一个头痛的问题，对我也是一样。python 3严格区分了<code>str</code>与<code>bytes</code>，这对Python的使用者来说一件好事。在python3中字符串是以<code>unicode</code>编码的，<code>unicode</code>是一种不会出现乱码的编码。</p><a id="more"></a><h2 id="字符串的encode与decode">字符串的encode与decode</h2><p>在python 3中可以说原生支持中文，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: str = <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">51</span>]: str</span><br><span class="line">Out[<span class="number">51</span>]: <span class="string">&#x27;中文&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">52</span>]: type(str)</span><br><span class="line">Out[<span class="number">52</span>]: str</span><br></pre></td></tr></table></figure><p>如果把<code>str</code>转换成<code>bytes</code>，那用<code>encode</code>方法，相反，使用<code>decode</code>方法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">53</span>]: str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Out[<span class="number">53</span>]: <span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">54</span>]: <span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.decode()</span><br><span class="line">Out[<span class="number">54</span>]: <span class="string">&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure><p>所以在python 3中进行编码的转换记住以下要点即可：</p><p><strong>str转换成bytes，使用encode方法，bytes转换为str，使用decode方法</strong></p><p>更多关于python中字符编码问题请参考<a href="http://www.ituring.com.cn/article/1116">这里</a>和<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000">这里</a></p><h2 id="base64模块">base64模块</h2><p>在python标准库中有一个<code>base64</code>的标准库，这个模块提供的更加丰富的功能实现对数据的编码与解码，官方文档请看<a href="https://docs.python.org/3/library/base64.html#base64.urlsafe_b64decode">这里</a>，这里记录几个常用的方法 。</p><h3 id="encodebytes方法与decodebytes方法">encodebytes方法与decodebytes方法</h3><p><code>encodebytes</code>方法表示对bytes对象进行编码操作，<code>decodebytes</code>方法的功能刚好相反，是一个解码的操作，两个方法都是返回一个bytes对象，如下：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">71</span>]: <span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line">In [<span class="number">72</span>]: s = <span class="string">b&#x27;this is test str&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">73</span>]: base64.encodebytes(s)</span><br><span class="line">Out[<span class="number">74</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==\n&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">75</span>]: encode = base64.encodebytes(s)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">76</span>]: encode</span><br><span class="line">Out[<span class="number">76</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==\n&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">77</span>]: base64.decodebytes(encode)</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="b64encode方法与b64decode方法">b64encode方法与b64decode方法</h3><p>这两个方法也是对bytest对象进行编码与解码操作，也是返回一个bytes对象，做如下测试：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">83</span>]: s</span><br><span class="line">Out[<span class="number">83</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">84</span>]: base64.b64encode(s)</span><br><span class="line">Out[<span class="number">84</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">85</span>]: base64.b64decode(base64.b64encode(s))</span><br><span class="line">Out[<span class="number">85</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br></pre></td></tr></table></figure><p>从编码的输出结果可看出与采用<code>encodebytes</code>方法编码出的结果几乎是一样的，只是最后少了<code>\n</code>这两个字符。</p><h3 id="urlsafe-b64encode与urlsafe-b64decode方法">urlsafe_b64encode与urlsafe_b64decode方法</h3><p>这两个方法也是对bytest对象进行编码和解码操作，同样返回一个bytes对象，做如下测试：</p><figure class="highlight ipython"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">88</span>]: s</span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">89</span>]: base64.urlsafe_b64encode(s)</span><br><span class="line">Out[<span class="number">89</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">90</span>]: url_encode = base64.urlsafe_b64encode(s)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">91</span>]: url_encode</span><br><span class="line">Out[<span class="number">91</span>]: <span class="string">b&#x27;dGhpcyBpcyB0ZXN0IHN0cg==&#x27;</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">92</span>]: base64.urlsafe_b64decode(url_encode)</span><br><span class="line">Out[<span class="number">92</span>]: <span class="string">b&#x27;this is test str&#x27;</span></span><br></pre></td></tr></table></figure><p>发现与采用b64encode方法编码出的结果是一样的。</p><p>上边只是<code>base64</code>这个模块的一少数几个方法，更多的方法说明去看官网吧。那为什么base64这个模块提供的上面几个编码方法编码后的内容都是几乎一样的，那为什么会有一同的实现？现在我也不知道这内部的原理和原因。<code>urlsafe_b64encode</code>方法有<code>urlsafe</code>这个关键字，猜想是对url这样类似的bytes对象做编码时应该使用这个方法吧，比如<code>http://zhaochj.github.io</code>或是一个系统路径<code>/etc/test.conf</code>。这个编码方法还要在实际的项目去实践。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encode </tag>
            
            <tag> decode </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado配置解析</title>
      <link href="/2016/09/13/2016-09-13-tornado%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/09/13/2016-09-13-tornado%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>tornado的options模块是一个命令行解析模块，此模块不仅可以从命令行解析传递的选项，也能从配置文件解析。以下边的事例来进行说明。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>要使用tornado的配置解析功能需要从<code>options</code>模块中引入<code>options</code>和<code>define</code>两个对象，<code>define</code>函数定义全局命名空间的选项，比如上边定义的<code>port</code>选项，后边就可以使用<code>tornado.options.options.port</code>来调用，运行上边的程序可以发现，程序监听在了<code>8000</code>端口，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:~$ ss -tnlp | grep 8000</span><br><span class="line">LISTEN     0      128          *:8000                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=18033,fd=6))</span><br><span class="line">neal@neal-System-Product-Name:~$ </span><br></pre></td></tr></table></figure><p>如果要让程序可以接受命令行传递的参数，那可以这样来改造程序，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>上边加入了<code>options.parse_command_line()</code>这一行代码，表示解析命令行传递的参数，参数使用_–name=value_的格式传递，试着运行上边的代码，在命令行传递相应的选项，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8080</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=20086,fd=6))</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)</span><br><span class="line">LISTEN     0      128          *:8000                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=20034,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在了<code>8080</code>端口，是从命令行传递过来的，所以可以知道，在<code>define</code>函数中定义的选项，又定义了<code>options.parse_command_line()</code>从命令行捕获选项，那程序运行时传递了相应的选项，那程序就使用这个在命令行传递选项的值，如果程序运行时没有传递相应的选项，那就采用define中定义的默认值。</p><p>options模块不仅可以从define和命令行获取选项的值，还可以读取指定一个配置文件，从配置文件读取选项和值，请看下边代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>applications.conf格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf </span><br><span class="line">port = 8080</span><br></pre></td></tr></table></figure><p>程序运行后可发现程序监听在<code>8080</code>端口，即是从配置文件里读取的配置信息，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=22126,fd=6))</span><br></pre></td></tr></table></figure><p>如果同时定义了从配置文件读取和从命令行读取，那生效的是哪个呢？做如下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序如下运行后查看监听在哪个端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf </span><br><span class="line">port = 8080</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8005                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=23810,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在<code>8005</code>端口，如果不在命令行传递参数，那程序会监听在哪个端口？如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=24093,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在了<code>8080</code>这个配置在配置文件中的端口。如果把<code>options.parse_command_line()</code>放在<code>options.parse_config_file('./application.conf')</code>之前呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>再运行程序试试，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=8777,fd=6))</span><br></pre></td></tr></table></figure><p>程序监听在<code>8080</code>这个定义在配置文件中的端口，如果不传递命令行参数呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=8937,fd=6))</span><br></pre></td></tr></table></figure><p>同样监听在<code>8080</code>端口，依然是配置文件中定义的参数，如果把配置文件中的信息清除呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; application.conf </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8005                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=25126,fd=6))</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8000                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=25384,fd=6))</span><br></pre></td></tr></table></figure><p>在上边的程序中，当把配置文件中的配置项去除后，如果命令行传递相应选项，那程序会使用命令行传递的参数，如果命令行没有传递相应的选项，那程序会使用<code>defie</code>中定义的默认选项。经过以上的不断测试，可以总结出<code>tornado</code>在使用配置选项时是按照如下规则：</p><ol><li>配置项的读取是根据代码的定义从上往下读取，如：先定义从文件读取，再定义从命令行读取，那程序就会先从文件读取，再从命令行读取；</li><li>如果相同的选项在配置文件中有定义，再在命令行也传递相同的选项，那后一个读取到的选项的值会覆盖前一个值，即最后读取到的值是生效值；</li><li>如果配置文件和命令行都未定义选项的值，那采用<code>define</code>定义的默认值。</li></ol><p>而在实际的编程中，从配置文件读取和从命令行读取会结合起来，并且一般会从两个地方读取配置文件，一个一般存放在<code>/etc</code>目录下作为全局配置文件，另一个存放在工程的根目录下，最后再接收命令行传递的参数以便在程序调试时使用。举一个例子来说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> options, define</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application, RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">define(<span class="string">&quot;port&quot;</span>, default=<span class="number">8000</span>, type=int, help=<span class="string">&quot;listen port&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;/etc/app.conf&#x27;</span>):</span><br><span class="line">        options.parse_config_file(<span class="string">&#x27;/etc/app.conf&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./application.conf&#x27;</span>):</span><br><span class="line">        options.parse_config_file(<span class="string">&#x27;./application.conf&#x27;</span>)</span><br><span class="line">    options.parse_command_line()</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ], debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">    app.listen(port=options.port, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat /etc/app.conf </span><br><span class="line">port = 8888</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf </span><br><span class="line">port = 8080</span><br></pre></td></tr></table></figure><p>运行程序测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8005                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=10291,fd=6))</span><br><span class="line"> </span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py</span><br><span class="line">(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python</span><br><span class="line">LISTEN     0      128          *:8080                     *:*                   users:((<span class="string">&quot;python&quot;</span>,pid=10404,fd=6))</span><br></pre></td></tr></table></figure><p>这也很好的验证了是最后读取到的那个选项生效。</p>]]></content>
      
      
      <categories>
          
          <category> web框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tornado </tag>
            
            <tag> options </tag>
            
            <tag> define </tag>
            
            <tag> 配置解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado怎样返回信息</title>
      <link href="/2016/09/10/2016-09-10-tornado%E5%AF%B9http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E/"/>
      <url>/2016/09/10/2016-09-10-tornado%E5%AF%B9http%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<p>本节记录tornado返回给浏览器信息的一些方法，在上一节中反复使用了<code>tornado.web.RequestHandler</code>类的<code>write</code>方法，此方法直接把数据返回给浏览器。在官方文档中tornado把这部分的内容放在了<code>RequestHandler</code>类的<code>Output</code>这一节，官方文档请点击<a href="http://www.tornadoweb.org/en/stable/web.html#output">这里</a>。</p><a id="more"></a><h2 id="Output">Output</h2><h3 id="set-status">set_status</h3><p>此方法设置返回状态码，接收<code>status_code</code>和<code>reason</code>两个参数，使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForbiddenHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_status(<span class="number">403</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/403&#x27;</span>, ForbiddenHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>尝试访问<code>/403</code>这个路由结果如下：</p><p><img src="/images/2016-09-12-forbidden.png" alt="2016-09-12-forbidden.png"></p><p>要注意的是要显示的调用<code>self.finish()</code>方法来结束， <code>self.finish()</code>代表回应生成的终结，否则客户端还会保持连接。</p><h3 id="set-header">set_header</h3><p>此方法设置响应报文的头部信息，事例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;XXXXX&#x27;</span>)</span><br><span class="line">        self.write(<span class="string">&#x27;set header&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/head&#x27;</span>, HeaderHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序运行后访问结果如下：</p><p><img src="/images/2016-09-12-set_header-1.png" alt="2016-09-12-set_header-1.png"></p><p><img src="/images/2016-09-12-set_header-2.png" alt="2016-09-12-set_header-2.png"></p><p><code>set_header</code>方法如果多次对同一个header进行赋值，那结果是最后那一个，如下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;XXXXX&#x27;</span>)</span><br><span class="line">        self.set_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;YYYYY&#x27;</span>)</span><br><span class="line">        self.write(<span class="string">&#x27;set header&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/head&#x27;</span>, HeaderHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序启动后测试结果如下：</p><p><img src="/images/2016-09-12-set_header-3.png" alt="2016-09-12-set_header-3.png"></p><h3 id="add-header">add_header</h3><p>此方法增加给定响应头的值，测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddHeadlerHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.add_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;add-XXX&#x27;</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/addhead&#x27;</span>, AddHeadlerHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序运行访问结果如下：</p><p><img src="/images/2016-09-12-add_header-1.png" alt="2016-09-12-add_header-1.png"></p><p>如果多次调用<code>add_header</code>方法，那最后的响应头的值会被叠加，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddHeadlerHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.add_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;add-XXX&#x27;</span>)</span><br><span class="line">        self.add_header(<span class="string">&#x27;X-Header&#x27;</span>, <span class="string">&#x27;add-YYY&#x27;</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/addhead&#x27;</span>, AddHeadlerHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>程序运行后访问结果如下：</p><p><img src="/images/2016-09-12-add_header-2.png" alt="2016-09-12-add_header-2.png"></p><h3 id="write">write</h3><p>此方法上边都多次用到，表示把给定的数据块写入输出缓冲区，即当用浏览器访问时直接输出到浏览器上。</p><h3 id="flush">flush</h3><p>此方法刷新当前的输出缓冲区到网络，看下边的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;start\n&#x27;</span>)</span><br><span class="line">        self.flush()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            self.write(<span class="string">&#x27;&#123;0&#125;\n&#x27;</span>.format(x))</span><br><span class="line">            self.flush()</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        self.finish(<span class="string">&#x27;stop\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/flush&#x27;</span>, FlushHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>flush这个特性在<code>postman</code>工具中不能演示出效果来，可以使用<code>curl</code>来测试，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:~$ curl http://172.20.12.174:8000/flush</span><br><span class="line">start</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">stop</span><br><span class="line">neal@neal-System-Product-Name:~$ </span><br></pre></td></tr></table></figure><p>上边的输出是有停顿的，停顿的时间就是代码中的<code>time.sleep(0.1)</code>。</p><h3 id="finish">finish</h3><p>此方法表示完成这个响应，HTTP的请求结束。前边的事例代码也有说明。</p><p>更多信息请参考<a href="http://www.tornadoweb.org/en/stable/web.html#output">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> web框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tornado </tag>
            
            <tag> 返回请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado处理请求报文</title>
      <link href="/2016/09/08/2016-09-07-tornado-http%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/"/>
      <url>/2016/09/08/2016-09-07-tornado-http%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>tornado是一个轻量、异步的web微框架，本文记录tornado怎样处理一个http请求报文。</p><a id="more"></a><h2 id="Hello-World">Hello World</h2><p>tornado使用<code>RequestHandler</code>类来处理http请求，所以在使用tornado来处理http请求时，自定义的类需要继承<code>RequestHandler</code>类。HTTP的方法，如：GET、PUT、DELETE、POST、HEAD等，都一一对应<code>RequestHandler</code>类中的方法。在使用tornado的web框架特性时一般是从<code>tornado</code>这个包中引入<code>web</code>模块里的相应类，<code>web</code>这个模块的源码请点击<a href="https://github.com/tornadoweb/tornado/blob/master/tornado/web.py">这里</a>。<br>　　接下来看一下tornado是怎样来处理http的请求的。首先来写一个经典的<code>Hello World</code>程序，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;Hello World\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/&#x27;</span>, MainHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>把程序启动后会监听在8000端口，使用curl来访问得到如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neal@neal-System-Product-Name:~$ curl http://172.20.12.174:8000</span><br><span class="line">Hello World</span><br><span class="line">neal@neal-System-Product-Name:~$</span><br></pre></td></tr></table></figure><p>这个<code>Hello World</code>事例中首先从<code>tornado.web</code>这个模块中引入了<code>RequestHandler</code>和<code>Application</code>两个类，<code>RequestHandler</code>类用来处理HTTP的请求，<code>Application</code>用来处理路由，这个类实例化后返回一个可调用的<code>tornado.web.Application</code>类，然后调用此类的<code>listen</code>方法使用程序监听在本地任意地址的<code>8000</code>端口，最后使用<code>IOLoop.current().start()</code>来把程序运行在起来循环处理用户请求。Tornado为了实现高并发和高性能，使用了这个IOLoop来处理socket的读写事件，IOLoop基于epoll，可以高效的响应网络事件。这是Tornado高效的保证。</p><p>在tornado的官方文档中把<code>Request handlers</code>分成了<code>Entry points</code>、<code>Input</code>和<code>Output</code>等多个章节，这里只对<code>Input</code>和<code>Output</code>的某些方法进行讲解，更详细资料请看<a href="http://www.tornadoweb.org/en/stable/web.html">官方文档</a>。</p><h2 id="Input">Input</h2><h3 id="get-argument方法">get_argument方法</h3><p>此方法返回用户传递参数的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgumentHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(self.get_argument(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/arg&#x27;</span>, ArgumentHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><code>ArgumentHandler</code>类是用户自定义类，此类继承<code>RequestHandler</code>,接着对<code>get</code>方法进行重写，这就是我们在使用<code>tornado</code>进行web开发时经常需要做的工作。HTTP协议定义的<code>get</code>、<code>post</code>、<code>delete</code>等方法在<code>tornado</code>中对应的同名方法是直接返回<code>HTTPError(405)</code>，即是没有实现的方法，这些方法就需要程序员自己根据业务逻辑来实现。源码请<a href="http://www.tornadoweb.org/en/stable/_modules/tornado/web.html#RequestHandler.get">参考</a>。运行此代码再访问返回如下：</p><p><img src="/images/2016-09-08-get_argument.png" alt="2016-09-08-get_argument"></p><p>结果是直接把传递的参数<code>name</code>的值<code>zhaochj</code>直接返回。如果给<code>name</code>这个变量传递多个值呢？如下：</p><p><img src="/images/2016-09-08-get_argument-1.png" alt="2016-09-08-get_argument-1.png"></p><p>结果是得到了最后一个值。</p><h3 id="get-arguments">get_arguments</h3><p>此方法同样返回用户传递参数的内容，但与<code>get_argument</code>不同的是它能接收同名的的多个参数，并且返回一个<code>list</code>，测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgumentHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(self.get_argument(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgumentsHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;\n&#x27;</span>.format(str(type(self.get_arguments(<span class="string">&#x27;name&#x27;</span>)))))</span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(<span class="string">&#x27;, &#x27;</span>.join(self.get_arguments(<span class="string">&#x27;name&#x27;</span>))))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/arg&#x27;</span>, ArgumentHandler),</span><br><span class="line">            (<span class="string">r&#x27;/args&#x27;</span>, ArgumentsHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>运行上边代码后访问得到如下结果：</p><p><img src="/images/2016-09-08-get_arguments.png" alt="2016-09-08-get_arguments.png"></p><h3 id="args">args</h3><p>在实际编程中可能会需要捕获一个路径下的值，使用<code>args</code>就可以把捕获到一个路径下的所有内容，并会把这个值存放在一个位置参数中，通过访问<code>args[0]</code>便可访问，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathArgsHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(args[<span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/path/args/(.*)&#x27;</span>, PathArgsHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>在正规中<code>(.*)</code>表示匹配任意内容，所以在URL中<code>/path/args/</code>后的所有内容都会被捕获，访问后结果如下：</p><p>![2016-09-08 17-25-41-args.png](/images/2016-09-08 17-25-41-args.png)</p><h3 id="kwargs">kwargs</h3><p>同<code>args</code>一样，<code>kwargs</code>可以捕获一个路径下的<code>K/V</code>键值数据，并存放在字典中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathKwArgsHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(kwargs[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/path/kwargs/(?P&lt;name&gt;.*)&#x27;</span>, PathKwArgsHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><code>（?P&lt;name&gt;.*)</code>表示命名捕获，这是<code>re</code>的语法，请参照<a href="https://docs.python.org/3/library/re.html">这里</a>，程序运行后访问结果如下：</p><p><img src="/images/2016-09-08-kwargs.png" alt="2016-09-08-kwargs.png"></p><h3 id="获取请求报文的其他内容">获取请求报文的其他内容</h3><p>一个请求报文中包含了非常多的内容，如：method，uri，path，query，version，body等，详细请参考<a href="http://www.tornadoweb.org/en/stable/httputil.html#tornado.httputil.HTTPServerRequest">这里</a>，以下事例说明怎样获取请求端的IP地址有body内容，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteIpHander</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(self.request.remote_ip))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BodyHandler</span>(<span class="params">RemoteIpHander</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        body = json.loads(self.request.body.decode())</span><br><span class="line">        self.write(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.format(body[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = Application(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">r&#x27;/ip&#x27;</span>, RemoteIpHander),</span><br><span class="line">            (<span class="string">r&#x27;/body&#x27;</span>, BodyHandler)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    app.listen(port=<span class="number">8000</span>, address=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><code>RemoteIpHander</code>类中直接调用<code>self.request.remote_ip</code>即可打印出客户端的IP地址，而<code>BodyHandler</code>类定义<code>post</code>方法，采用<code>json.lodads</code>来解析上传的<code>json</code>数据，注意最后的<code>decode</code>方法，因为通过客户端发送过来的数据是<code>bytes</code>，而<code>json</code>对象只能是<code>str</code>，所以需要<code>decode</code>来解码。程序运行后测试结果如下：</p><p><img src="/images/2016-09-08-remoteip.png" alt="2016-09-08-remoteip.png"></p><p><img src="/images/2016-09-08-postbody.png" alt="2016-09-08-postbody.png"></p><p><code>RequestHandler</code>这个类还有许多方法，详细信息参考<a href="http://www.tornadoweb.org/en/stable/web.html">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> web框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tornado </tag>
            
            <tag> 处理请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python线程中的condition特性</title>
      <link href="/2016/08/21/2016-08-21-%E7%BA%BF%E7%A8%8B%E7%9A%84condition%E7%89%B9%E6%80%A7/"/>
      <url>/2016/08/21/2016-08-21-%E7%BA%BF%E7%A8%8B%E7%9A%84condition%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之线程间的condition特性</p><a id="more"></a><h2 id="threading的Condition方法">threading的Condition方法</h2><p>confition方法适合<code>生产-消费</code>的工作模型，消费者会等待生产者生产数据生消费者再对数据进行处理。以下边的例子来说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Message:</span><br><span class="line">    def __init__(self, message):</span><br><span class="line">        self.message = message</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def consumer(cond, message):</span><br><span class="line">    with cond:</span><br><span class="line">        cond.wait()</span><br><span class="line">        logging.debug(<span class="string">&quot;consumer &#123;0&#125;&quot;</span>.format(message.message))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def producer(cond, message):</span><br><span class="line">    with cond:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;====&#x27;</span>)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        message.message = <span class="string">&#x27;ha ha ha &#x27;</span></span><br><span class="line">        logging.debug(<span class="string">&quot;producer &#123;0&#125;&quot;</span>.format(message.message))</span><br><span class="line">        cond.notify_all()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    message = Message(None)</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line">    c1 = threading.Thread(target=consumer, args=(cond, message), name=<span class="string">&quot;consumer-1&quot;</span>)</span><br><span class="line">    c1.start()</span><br><span class="line">    c2 = threading.Thread(target=consumer, args=(cond, message), name=<span class="string">&quot;consumer-2&quot;</span>)</span><br><span class="line">    c2.start()</span><br><span class="line"> </span><br><span class="line">    p = threading.Thread(target=producer, args=(cond, message), name=<span class="string">&quot;producer&quot;</span>)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure><p>上边的测试代码中定义了一个<code>producer</code>方法用于生产数据，<code>consumer</code>方法用于消费数据，当运行上边代码后，先是输出了<code>====</code>，再等待2秒后输出了<code>2016-08-21 17:29:16,212 DEBUG [producer] producer ha ha ha </code>，接着跟着输出了<code>2016-08-21 17:29:16,212 DEBUG [consumer-1] consumer ha ha ha</code>和<code>2016-08-21 17:29:16,212 DEBUG [consumer-2] consumer ha ha ha</code>，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">====</span><br><span class="line">2016-08-21 17:29:16,212 DEBUG [producer] producer ha ha ha </span><br><span class="line">2016-08-21 17:29:16,212 DEBUG [consumer-1] consumer ha ha ha </span><br><span class="line">2016-08-21 17:29:16,212 DEBUG [consumer-2] consumer ha ha ha </span><br></pre></td></tr></table></figure><p>可见consumer线程是在producer线程运行之后才运行，即等待生产者生产数据。</p><p>小结：</p><p><code>threading.Condition()</code>初始化一个condition对象，当生产者准备好数据后用<code>notify_all()</code>通知监听同一个condition对象的线程消费数据，如果生产方没有数据生产出来，那消费者就被阻塞等待。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程，condition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的daemon与join特性</title>
      <link href="/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84daemon%E4%B8%8Ejoin%E7%89%B9%E6%80%A7/"/>
      <url>/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84daemon%E4%B8%8Ejoin%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之多线程中的daemon与join特性</p><a id="more"></a><h2 id="none-daemon与daemon">none daemon与daemon</h2><p>在python 3中，threading属于标准库中的模块，在version 3.3中增加了daemon参数，值是一个bool值，默认为<code>False</code>。</p><p>如果一个线程的<code>daemon=False</code>，即我们说这个线程是一个<code>none daemon</code>的线程，那主线程<code>永远</code>会等待子线程全部退出后自己才退出。</p><p>看下边的例子，下边的例子全部都在pytharm的IDE中进行：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">False</span></span><br><span class="line">    t.start()</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>当运行这段代码时，先打印出了<code>主线程</code>的日志信息，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">06</span>:<span class="number">24</span>,<span class="number">358</span> DEBUG [MainThread] main thread exiting</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>主线程被阻塞，然后等待5秒后再打印出了<code>子线程</code>的日志信息，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">06</span>:<span class="number">24</span>,<span class="number">358</span> DEBUG [MainThread] main thread exiting   <span class="comment"># 被阻塞</span></span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">06</span>:<span class="number">29</span>,<span class="number">359</span> DEBUG [worker] worker <span class="keyword">is</span> started, ha,ha  <span class="comment"># 5秒后才打印出来</span></span><br></pre></td></tr></table></figure><p>所以当线程是一个<code>none daemon</code>线程时，主线程会被阻塞，直到全部子线程退出。</p><p>当线程是一个daemon线程时呢？把上边的<code>t.daemon = False</code>修改成<code>t.daemon = True</code>后再次运行代码，结果如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">39</span>,<span class="number">644</span> DEBUG [MainThread] main thread exiting</span><br><span class="line">  </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从上边输出的结果可知，主线程没有等待子线程运行结束，而主线程自己就退出了。而当主线程退出后子线程也会跟着退出。</p><p>小结：</p><p>在<code>none daemon</code>的线程中主线程永远会等待子线程退出后才退出，在<code>daemon</code>的线程中主线程不会等待子线程退出后自己才退出，在<code>none daemon</code>线程中子线程因程序bug或其他原因而不能正常的退出时，那主线程就一直被阻塞，一直等待着子线程退出，这样线程所占用的资源就一直不能被释放。join函数能解决这样的问题。</p><h2 id="join">join( )</h2><p>线程调用join函数后，主线程就会等待子线程退出后才退出，而子线程执行的代码如果不能正常退出时那主线程也一直会等待，如果在join时加上一个超时时间，那主线程只等待设置的超时时间后主线程就退出。</p><ul><li>none daemon中的join()</li></ul><p>看下边的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">False</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>当运行上边代码时，先输出了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> worker</span><br></pre></td></tr></table></figure><p>再等待5秒后输出了下边的日志信息：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">16</span>,<span class="number">925</span> DEBUG [worker] worker <span class="keyword">is</span> started, ha,ha</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">16</span>,<span class="number">925</span> DEBUG [MainThread] main thread exiting</span><br></pre></td></tr></table></figure><p>这说明当一个线程是<code>none daemon</code>时，并调用了<code>join()</code>函数，那主线程会等待子线程执行完成。这和不调用<code>join()</code>函数的<code>none daemon</code>线程是有区别的，调用<code>join()</code>函数时是主线程等待子线程完成，不调用<code>join()</code>函数时是主线程被阻塞后，一直等待子线程执行完成，从打印的日志可看出两者的区别。</p><p>join()函数可以给定一个超时时间，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">False</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join(timeout=<span class="number">2</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上边的代码后，首先输出<code>exec worker</code>，等待2秒，再输出<code>2016-08-14 16:10:59,695 DEBUG [MainThread] main thread exiting</code>,再等待3秒，最后输出<code>2016-08-14 16:11:02,692 DEBUG [worker] worker is started, ha,ha</code>，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> worker  <span class="comment"># 2秒后输出下一行</span></span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">10</span>:<span class="number">59</span>,<span class="number">695</span> DEBUG [MainThread] main thread exiting <span class="comment"># 3秒后输出下一行</span></span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">11</span>:<span class="number">02</span>,<span class="number">692</span> DEBUG [worker] worker <span class="keyword">is</span> started, ha,ha</span><br></pre></td></tr></table></figure><p>在<code>none daemon</code>的线程中，如果给<code>join()</code>函数一个超时时间，当超过这个时间后，即使这个线程没有执行完成，程序就直接输出了<code>2016-08-14 16:10:59,695 DEBUG [MainThread] main thread exiting</code>，并且被阻塞在这里等待子线程的完成，因为线程是<code>none daemon</code>的。这种场景在现实的编程中应该不多。</p><ul><li>daemon中的join()</li></ul><p>在实际的编程中，一般会把线程设置成daemon，并启用<code>join()</code>函数，并适当给一个超时时间，这样主线程即能等待子线程，又能兼顾子线程因一些原因被卡住后无法退出时导致主线程也无法退出的情况。如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">True</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join(timeout=<span class="number">6</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上边的代码，先是输出<code>exec worker</code>，再等待5秒，依次输出<code>2016-08-14 16:31:59,287 DEBUG [worker] worker is started, ha,ha</code>和<code>2016-08-14 16:31:59,287 DEBUG [MainThread] main thread exiting</code>。这样，采用join的方式让主线程等待子线程正常退出，如果在调用worker函数时有bug，执行时一直退不出来，那到join的超时时间后，主线程同样能退出，把上边的<code>t.join(timeout=6)</code>修改成<code>t.join(timeout=3)</code>来模拟这样一个场景，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">message</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;exec worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;worker is started, &#123;0&#125;&quot;</span>.format(message))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>, kwargs=&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ha,ha&#x27;</span>&#125;)</span><br><span class="line">    t.daemon = <span class="literal">True</span></span><br><span class="line">    t.start()</span><br><span class="line">    t.join(timeout=<span class="number">3</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;main thread exiting&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行上边的代码后，先是输出<code>exec worker</code>,再等待3秒后直接输出<code>2016-08-14 16:36:23,608 DEBUG [MainThread] main thread exiting</code>,worker函数里的内容没有被执行，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> worker</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">23</span>,<span class="number">608</span> DEBUG [MainThread] main thread exiting</span><br><span class="line">  </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程间通信机制-event</title>
      <link href="/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84event%E7%89%B9%E6%80%A7/"/>
      <url>/2016/08/14/2016-08-14-%E7%BA%BF%E7%A8%8B%E7%9A%84event%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之多线程间通信-event</p><a id="more"></a><h2 id="线程间的通讯-event">线程间的通讯-- event</h2><p>event是多线程间通信的一种简单机制，一个线程发出event信号，其他线程等待这个信号。</p><p>以一个例子来说明，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        logging.debug(<span class="string">&#x27;in worker fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line">    logging.debug(<span class="string">&#x27;event is set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">event</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    event.set()</span><br><span class="line">    logging.debug(<span class="string">&#x27;in set fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    w = threading.Thread(target=worker, args=(event,), name=<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    w.start()</span><br><span class="line">    s = threading.Thread(target=set, args=(event,), name=<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure><p>在上边的代码中定义了两个函数，并在测试代码上启用两个线程分别调用这两个函数，在调用前要初始化<code>event</code>对象。运行上边的代码会发现一直输出<code>2016-08-14 20:36:49,059 DEBUG [worker] in worker fun, event is set ? False</code>,即是调用<code>worker</code>函数的线程在不断执行，1秒后输出了<code>2016-08-14 20:36:49,063 DEBUG [set] in set fun, event is set ? True</code>，紧跟着输出<code>2016-08-14 20:36:49,063 DEBUG [worker] event is set</code>，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,061 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">....略.....</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,062 DEBUG [worker] in worker fun, event is set ? False</span><br><span class="line">2016-08-14 20:36:49,063 DEBUG [set] in set fun, event is set ? True</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">49</span>,<span class="number">063</span> DEBUG [worker] event <span class="keyword">is</span> set</span><br></pre></td></tr></table></figure><p>为什么会这样？</p><p>因为在测试代码中启动了两个线程分别调用<code>worker</code>和<code>set</code>函数，<code>worker</code>函数判断当event没有被set时打印类似这样日志<code>in worker fun, event is set ? False</code>。而<code>set</code>函数负责将线程内部的标志设置为<code>true</code>，即执行<code>event.set()</code>语句，它将唤醒所有线程并告知<code>event</code>的内部标志已为<code>true</code>，<code>set</code>函数只是sleep了1秒钟，调用<code>woker</code>函数的线程就执行了很多次了。此时执行<code>worker函数</code>的线程收到这个信号后执行到<code>while not event.is_set()</code>语句时，<code>event.is_set()</code>返回了<code>true</code>，所以整个while语句返回<code>False</code>，那while循环中的语句将被跳过，而去执行<code>logging.debug('event is set')</code>。</p><ul><li>event.wait()</li></ul><p>wait方法表示阻塞直到线程内部的标志为<code>true</code>，即有线程调用<code>set()</code>方法。以下边的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        event.wait()</span><br><span class="line">        logging.debug(<span class="string">&#x27;in worker fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line">    logging.debug(<span class="string">&#x27;event is set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">event</span>):</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    event.set()</span><br><span class="line">    logging.debug(<span class="string">&#x27;in set fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    w = threading.Thread(target=worker, args=(event,), name=<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    w.start()</span><br><span class="line">    s = threading.Thread(target=set, args=(event,), name=<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure><p>执行上边的代码时，<code>w</code>线程会被一直阻塞，直到4秒种之后，<code>set</code>函数执行到<code>event.set()</code>，内部标志被设置成为<code>true</code>，通知其他所有线程，<code>w</code>线程收到信号后不再阻塞。输出如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-08-14 21:45:26,326 DEBUG [set] in set fun, event is set ? True</span><br><span class="line">2016-08-14 21:45:26,326 DEBUG [worker] in worker fun, event is set ? True</span><br><span class="line"><span class="number">2016</span><span class="number">-08</span><span class="number">-14</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">26</span>,<span class="number">326</span> DEBUG [worker] event <span class="keyword">is</span> set</span><br><span class="line"> </span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>wait可以设置超时时间，表示只阻塞线程一定的时间，如果收到了<code>event.set()</code>信号，线程退出，否则线程被阻塞，只是不是一直阻塞，而是按照设定的时间阻塞线程，如下设置<code>wait</code>时间，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=<span class="string">&#x27;%(asctime)s %(levelname)s [%(threadName)s] %(message)s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        event.wait(timeout=<span class="number">1</span>)</span><br><span class="line">        logging.debug(<span class="string">&#x27;in worker fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line">    logging.debug(<span class="string">&#x27;event is set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">event</span>):</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    event.set()</span><br><span class="line">    logging.debug(<span class="string">&#x27;in set fun, event is set ? &#123;0&#125;&#x27;</span>.format(event.is_set()))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    w = threading.Thread(target=worker, args=(event,), name=<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    w.start()</span><br><span class="line">    s = threading.Thread(target=set, args=(event,), name=<span class="string">&quot;set&quot;</span>)</span><br><span class="line">    s.start()</span><br></pre></td></tr></table></figure><p>当执行上边代码时，每隔一秒执行<code>worker</code>函数，当到第4秒时，<code>event</code>对象被<code>set</code>，<code>w</code>线程收到信号就退出。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程，event特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="/2016/06/24/docker/2016-06-24-docker%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/06/24/docker/2016-06-24-docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>docker越来越流行，这里介绍一点关于docker的基础知识。</p><a id="more"></a><h1>Docker基础篇</h1><ul><li>[x] docker简介</li><li>[x] 安装docker服务</li></ul><h2 id="docker简介">docker简介</h2><blockquote><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。-- 百度百科</p></blockquote><p><img src="/images/2016-06-24-docker-01.png" alt="docker_vs_vm"></p><p>上图来自docker<a href="https://www.docker.com/what-docker#/VM">官网</a>截图，整体上说明了传统的虚拟机与docker的区别，传统的虚拟机包括应用程序，必要的二进制文件和库文件以及一个完整的操作系统，这样一个虚拟机文件会有上GB的大小。而docker容器则包含应用程序以及依赖包，但容器间共享操作系统的kernel,在宿主机上以一个进程体现一个docker容器，各个容器间是相互隔离的，容器不依赖任何特定的基础设施，这样方便于迁移。</p><p>已下所有操作基于Debain 8 x 64</p><p>docker服务器需要安装包：</p><p>dialog</p><p>perl-base</p><p>apt-utils</p><h2 id="安装docker服务">安装docker服务</h2><p>先删除旧包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-get purge lxc-docker*</span></span><br><span class="line">root@haproxy-01:~<span class="comment"># apt-get purge docker.io*</span></span><br></pre></td></tr></table></figure><p>再使apt能工作在https方式及安装CA证书，如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-get update</span></span><br><span class="line">root@haproxy-01:~<span class="comment"># apt-get install apt-transport-https ca-certificates</span></span><br></pre></td></tr></table></figure><p>增加新的GPG key</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span></span><br></pre></td></tr></table></figure><p>根据系统的发行版本增加相应的docker源，我这里使用的是Debian Jessie</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment">#  vim /etc/apt/sources.list.d/docker.list  #增加下边的地址</span></span><br><span class="line">deb https://apt.dockerproject.org/repo debian-jessie main</span><br><span class="line">root@haproxy-01:~<span class="comment"># apt-get update</span></span><br></pre></td></tr></table></figure><p>可用以下命令验证<code>docker-engine</code>软件将会从哪个存储库下载及相应软件版本的列表</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-cache policy docker-engine</span></span><br></pre></td></tr></table></figure><p>安装<code>docker-engine</code>，这里安装目前最新的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># apt-get install docker-engine=1.11.2-0~jessie</span></span><br><span class="line">root@haproxy-01:~<span class="comment"># docker version</span></span><br><span class="line">Client:</span><br><span class="line"> Version:      1.11.2</span><br><span class="line"> API version:  1.23</span><br><span class="line"> Go version:   go1.5.4</span><br><span class="line"> Git commit:   b9f10c9</span><br><span class="line"> Built:        Wed Jun  1 21:23:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.11.2</span><br><span class="line"> API version:  1.23</span><br><span class="line"> Go version:   go1.5.4</span><br><span class="line"> Git commit:   b9f10c9</span><br><span class="line"> Built:        Wed Jun  1 21:23:39 2016</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure><p>以上操作可以用如下脚本完成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: install_docker.sh</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: sky_551@163.com</span></span><br><span class="line"><span class="comment">#Date: 2016-06-16</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"><span class="comment"># for debina jessie x64</span></span><br><span class="line"></span><br><span class="line">version=1.11.2-0~jessie</span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># del old pkg</span></span><br><span class="line">apt-get purge lxc-docker*</span><br><span class="line">apt-get purge docker.io*</span><br><span class="line"></span><br><span class="line"><span class="comment"># install apt-transport-https ca-certificates</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install apt-transport-https ca-certificates</span><br><span class="line"></span><br><span class="line"><span class="comment"># add GPG key</span></span><br><span class="line">apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br><span class="line"></span><br><span class="line"><span class="comment"># add docker.list for Debian Jessie</span></span><br><span class="line">rm -f /etc/apt/sources.list.d/*</span><br><span class="line">cat &lt;&lt;- EOF &gt;&gt; /etc/apt/sources.list.d/docker.list</span><br><span class="line">deb https://apt.dockerproject.org/repo debian-jessie main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># install docker-engine</span></span><br><span class="line">apt-get install docker-engine=<span class="variable">$&#123;version&#125;</span></span><br><span class="line"></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p><strong>在docker中进入一个已运行的容器</strong></p><ul><li><p>首先确保系统已安装有<code>nsenter</code>命令，此命令由<code>util-linux</code>包安装得来，安装命令为<code>apt-get install util-linux</code></p></li><li><p>先得到container id</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                CREATED             STATUS              PORTS                                          NAMES</span><br><span class="line">d924adae5ff6        nginx:latest                    <span class="string">&quot;nginx -g &#x27;daemon of   18 hours ago        Up 18 hours         80/tcp, 443/tcp                                r-WEB-Server_Nginx-cluster_1</span></span><br></pre></td></tr></table></figure><ul><li>计算出指定container id容器的PID</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># docker inspect --format &#123;&#123;.State.Pid&#125;&#125; d924adae5ff6</span></span><br><span class="line">20272</span><br></pre></td></tr></table></figure><ul><li>进入到容器中</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@haproxy-01:~<span class="comment"># nsenter --target 20272 --mount --uts --ipc --net --pid</span></span><br><span class="line">root@d924adae5ff6:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>上边的命令似乎过于复杂，有前辈给我们准备好了便捷的工具，脚本如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Some useful commands to use docker.</span></span><br><span class="line"><span class="comment"># Author: yeasy@github</span></span><br><span class="line"><span class="comment"># Created:2014-09-25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> docker-pid=<span class="string">&quot;sudo docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;&quot;</span></span><br><span class="line"><span class="built_in">alias</span> docker-ip=<span class="string">&quot;sudo docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#the implementation refs from https://github.com/jpetazzo/nsenter/blob/master/docker-enter</span></span><br><span class="line"><span class="keyword">function</span> docker-<span class="function"><span class="title">enter</span></span>() &#123;</span><br><span class="line">    <span class="comment">#if [ -e $(dirname &quot;$0&quot;)/nsenter ]; then</span></span><br><span class="line">    <span class="comment">#Change for centos bash running</span></span><br><span class="line">    <span class="keyword">if</span> [ -e $(dirname <span class="string">&#x27;$0&#x27;</span>)/nsenter ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># with boot2docker, nsenter is not in the PATH but it is in the same folder</span></span><br><span class="line">        NSENTER=$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)/nsenter</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># if nsenter has already been installed with path notified, here will be clarified</span></span><br><span class="line">        NSENTER=$(<span class="built_in">which</span> nsenter)</span><br><span class="line">        <span class="comment">#NSENTER=nsenter</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    [ -z <span class="string">&quot;<span class="variable">$NSENTER</span>&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;WARN Cannot find nsenter&quot;</span> &amp;&amp; <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Usage: `basename &quot;</span><span class="variable">$0</span><span class="string">&quot;` CONTAINER [COMMAND [ARG]...]&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Enters the Docker CONTAINER and executes the specified COMMAND.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;If COMMAND is not specified, runs an interactive shell in CONTAINER.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PID=$(sudo docker inspect --format <span class="string">&quot;&#123;&#123;.State.Pid&#125;&#125;&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$PID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;WARN Cannot find the given container&quot;</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line"></span><br><span class="line">        OPTS=<span class="string">&quot;--target <span class="variable">$PID</span> --mount --uts --ipc --net --pid&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="comment"># No command given.</span></span><br><span class="line">            <span class="comment"># Use su to clear all host environment variables except for TERM,</span></span><br><span class="line">            <span class="comment"># initialize the environment variables HOME, SHELL, USER, LOGNAME, PATH,</span></span><br><span class="line">            <span class="comment"># and start a login shell.</span></span><br><span class="line">            <span class="comment">#sudo $NSENTER &quot;$OPTS&quot; su - root</span></span><br><span class="line">            sudo <span class="variable">$NSENTER</span> --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid su - root</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># Use env to clear all host environment variables.</span></span><br><span class="line">            sudo <span class="variable">$NSENTER</span> --target <span class="variable">$PID</span> --mount --uts --ipc --net --pid env -i <span class="variable">$@</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上边的脚本内容保存在用户家目录下，文件名为<code>.bashrc_docker</code>，或直接运行<code>wget -P ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker</code>命令把此脚本文件下载到用户家目录下，再运行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[ -f ~/.bashrc_docker ] &amp;&amp; source ~/.bashrc_docker&quot;</span> &gt;&gt; ~/.bashrc; <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这样用户每次登陆时都会执行<code>.bashrc_docker</code>文件，此工具使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@cst004:~<span class="comment"># docker-pid &lt;container&gt;   # docker-pid 跟上容器的name即可获得容器的pid</span></span><br><span class="line">root@cst004:~<span class="comment"># docker-enter &lt;container&gt;    # 直接进入容器</span></span><br><span class="line">root@cst004:~<span class="comment"># docker-enter &lt;container&gt; COMMAND   # 直接进入容器执行一个命令</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构-双端队列-环状队列</title>
      <link href="/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-%E7%8E%AF%E7%8A%B6%E9%98%9F%E5%88%97/"/>
      <url>/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-%E7%8E%AF%E7%8A%B6%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之双端队列与环状队列</p><a id="more"></a><h2 id="数据结构-双端队列-环状队列">数据结构-双端队列-环状队列</h2><h3 id="双端队列">双端队列</h3><p>单端队列数据只能从队尾进，从队头出数据。而双端队列表示数据两端都可以进，两端都可以出。</p><p>双端队列里依然有两个指针，<code>head</code>和<code>backend</code>指针，一个空队列时，两个指针都指向<code>None</code>,从队列的前端增加数据时，<code>head</code>指针向前移动，当从队列的后端增加元素时，<code>backend</code>指针向后移动元素。如果要弹出队头的元素，那先把<code>head</code>往<code>backend</code>方向移动，再弹出此元素，如果要弹出队尾的元素，那行把<code>backend</code>指针往<code>head</code>所在方向移动。当两个指针指向<code>None</code>时，表示已是一个空队列。</p><p>可以用示意图来表达这一过程：</p><p><img src="/images/2016-05-16-05.jpg" alt="双端队列"></p><p><img src="/images/2016-05-16-06.jpg" alt="双端队列"></p><p>当删除元素元素时就是一个与增加元素相反的过程。</p><p>在<code>python</code>的标准库中已实现了<code>双端队列</code>，可以用<code>from collections import deque</code>导入。<code>deque</code>常用属性：</p><p>创建一个空队列：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: dq = deque()</span><br><span class="line">In [<span class="number">11</span>]: dq</span><br><span class="line">Out[<span class="number">11</span>]: deque([])</span><br></pre></td></tr></table></figure><p>使用<code>append</code>方法向队列增加元素，此方法是向队尾增加元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: dq.append(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">13</span>]: dq.append(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">14</span>]: dq</span><br><span class="line">Out[<span class="number">14</span>]: deque([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用<code>appendleft</code>方法向队列增加元素，此方法是向队头增加元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: dq.appendleft(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">16</span>]: dq.appendleft(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">17</span>]: dq</span><br><span class="line">Out[<span class="number">17</span>]: deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用<code>pop</code>方法弹出一个元素，此方法是在队尾方向弹出元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: dq.pop()</span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">19</span>]: dq</span><br><span class="line">Out[<span class="number">19</span>]: deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用<code>popleft</code>方法弹出一个元素，此方法是在队头方向弹出元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: dq.popleft()</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">21</span>]: dq</span><br><span class="line">Out[<span class="number">21</span>]: deque([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="环状队列">环状队列</h3><p>环状队列在初始化时会生成指定数量的槽位，如果有元素<code>append</code>进来时，按照顺序依次加入到这些空的槽位中，当槽位被占满时，再<code>append</code>元素时会把最老的那个元素踢掉，再把新元素放入到槽位中，依此类推，环状队列最多保存初始化时指定槽位的数据。</p><p>可以用一个简单的示意图来表示：</p><p><img src="/images/2016-05-16-07.jpg" alt="环状队列"></p><p>标准库的<code>deque</code>不仅是双端队列，也是一个环状队列。只要初始化队列时加上<code>maxlen</code>参数即可。</p><p>创建一个槽位为5的环境队列：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: ring = deque(maxlen=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">24</span>]: ring</span><br><span class="line">Out[<span class="number">24</span>]: deque([])</span><br></pre></td></tr></table></figure><p>向队列增加5个元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: ring.append(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">26</span>]: ring.append(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">27</span>]: ring.append(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">28</span>]: ring.append(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">29</span>]: ring.append(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">30</span>]: ring</span><br><span class="line">Out[<span class="number">30</span>]: deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>当再增加一个元素时：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: ring.append(<span class="number">6</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">32</span>]: ring</span><br><span class="line">Out[<span class="number">32</span>]: deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>第一个元素被覆盖了。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双端队列，环状队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构-hash</title>
      <link href="/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash/"/>
      <url>/2016/05/16/2016-05-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之hash</p><a id="more"></a><h2 id="拉链法实现hash表数据结构">拉链法实现hash表数据结构</h2><h3 id="什么叫Hash">什么叫Hash</h3><blockquote><p>Hash一般翻译做“散列”，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p></blockquote><p>一个输入通过散列算法得到一个固定长宽的输出，这个散列值是有可能冲突的，也就是说输入值不同，而通过计算后得到的散列值有可能相同了，这样就产生了冲突，拉链法就能解决这样的冲突。拉链法把散列值所对应的数据又放在了一个链表里，放在链表的位置就是以散列值作为索引值，这样就能解决散列冲突的问题，要以下边的示意图来展示：</p><p><img src="/images/2016-05-19-01.jpg" alt="hash"></p><p>左边就是hash表的尺寸大小，可以把它看成一个数组，数组的每个成员指向一个链表，也可以指向一个空链表，链表里的元素主是实际存放的数据。</p><p>Hash表常用的方法：</p><ul><li>Map()方法，创建一个空Hash表</li><li>put(key, value)方法，接收一个key和value，没有返回值</li><li>get(key)方法，接收key，返回key对应的value值，如果没有此值默认返回None</li><li>remove(key)方法，接收key，删除key对应的value</li></ul><p>先来实现一个存放在链表中的元素类：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure><p>Node类接收两个参数，一个是key，另一个Key对应的value。</p><h4 id="Map类的实现">Map类的实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, init_size, hash=hash</span>):</span></span><br><span class="line">        self.__slot = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(init_size)]</span><br><span class="line">        self.__size = init_size</span><br><span class="line">        self.hash = hash</span><br></pre></td></tr></table></figure><p>如果计算散列值的函数不使用pyton的内建的hash函数，可以自己传入一个函数，这里默认采用hash函数。代码中的列表解析<code>self.__slot = [[] for _ in range(init_size)]</code>与下边的代码块等价，都是生成一个包含<code>init_size</code>个<code>[]</code>元素的列表。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.__slot = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(init_size):</span><br><span class="line">   self.__slot.append([])</span><br></pre></td></tr></table></figure><h4 id="put方法实现">put方法实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">    node = Node(key, value)</span><br><span class="line">    address = self.hash(node.key) % self.__size</span><br><span class="line">    self.__slot[address].append(node)</span><br></pre></td></tr></table></figure><p>这里的<code>address = self.hash(node.key) % self.__size</code>是把散列值与Hash表尺寸做取模运算，这样<code>address</code>就一定能落到如上图中的数组元素中，接着再把<code>node</code>对象<code>append</code>到链表中。</p><h4 id="get方法实现">get方法实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=None</span>):</span></span><br><span class="line">    _key = self.hash(key)</span><br><span class="line">    address = _key % self.__size</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> self.__slot[address]:</span><br><span class="line">        <span class="keyword">if</span> node.key == key:</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">    <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure><p>要得到一个<code>key</code>的<code>value</code>值，首先得采用相同的hash函数计算出散列地址，再在这个地址上的链表中遍历<code>key</code>，有则返回其<code>value</code>，否则返回一个默认值。</p><h4 id="remove方法实现">remove方法实现</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key</span>):</span></span><br><span class="line">    address = self.hash(key) % self.__size</span><br><span class="line">    <span class="keyword">for</span> idx, node <span class="keyword">in</span> enumerate(self.__slot[address].copy()):</span><br><span class="line">        <span class="keyword">if</span> node.key == key:</span><br><span class="line">            self.__slot[address].pop(idx)</span><br></pre></td></tr></table></figure><p>此方法同样需要得到<code>key</code>的散列地址，再遍历链表，只是这里会删除<code>key</code>所对应的<code>value</code>。在使用python的可迭代对象时有一条定律，那就是永远都不要对迭代对象进行数据的修改，所以这里把链表进行了<code>copy()</code>，生成一个副本，对这个副本进行遍历，如果链表中有<code>key</code>，那就在原链表里弹出此<code>key</code>。</p><h4 id="完整的代码如下：">完整的代码如下：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, init_size, hash=hash</span>):</span></span><br><span class="line">        self.__slot = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(init_size)]</span><br><span class="line">        <span class="comment">#self.__slot = []</span></span><br><span class="line">        <span class="comment">#for _ in range(init_size):</span></span><br><span class="line">        <span class="comment">#   self.__slot.append([])</span></span><br><span class="line">        self.__size = init_size</span><br><span class="line">        self.hash = hash</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        address = self.hash(node.key) % self.__size</span><br><span class="line">        self.__slot[address].append(node)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key, default=None</span>):</span></span><br><span class="line">        _key = self.hash(key)</span><br><span class="line">        address = _key % self.__size</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.__slot[address]:</span><br><span class="line">            <span class="keyword">if</span> node.key == key:</span><br><span class="line">                <span class="keyword">return</span> node.value</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        address = self.hash(key) % self.__size</span><br><span class="line">        <span class="keyword">for</span> idx, node <span class="keyword">in</span> enumerate(self.__slot[address].copy()):</span><br><span class="line">            <span class="keyword">if</span> node.key == key:</span><br><span class="line">                self.__slot[address].pop(idx)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    map = Map(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        map.put(i, i)</span><br><span class="line"> </span><br><span class="line">    map.remove(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(map.get(i, <span class="string">&#x27;not set&#x27;</span>))</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构之队列</title>
      <link href="/2016/05/15/2016-05-15-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2016/05/15/2016-05-15-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之队列</p><a id="more"></a><h2 id="数据结构-队列">数据结构-队列</h2><p>队列是有序数据集合，队列的特点，删除数据项是在头部，称为前端(front)，增加数据在尾部，称为后端(rear)。数据项总是开始排在队伍的后端，慢慢向前走，直到排到最前面，轮到它的时候离开队列。</p><p>刚进来的数据排在后端，待在队伍里时间最长的在前端，这种排列规则叫做FIFO(first-in first-out)，意思是“先进先出”，或者叫做“先来先服务”(first-come first-served)</p><p>队列一般提供以下接口：</p><ol><li>Queue() 定义一个空队列，无参数，返回值是空队列</li><li>enqueue(item)  在队列尾部加入一个数据项，参数是数据项，无返回值</li><li>dequeue()  删除队列头部的数据项，不需要参数，返回值是被删除的数据，队列本身有变化。</li><li>isEmpty()  检测队列是否为空。无参数，返回布尔值。</li><li>size() 返回队列数据项的数量。无参数，返回一个整数。</li></ol><p>用python的list数据类型能比较容易的实现队列数据模型，但这里不以list来实现。我们假设队列里的元素有一个指针，最先加进元素的指针指向它下一个元素，依次类推，最后一个元素的指针是指向None。所以队列里的元素可以抽象出一个类来，同样像链表时的Node类一样，Node类里有自己的数据和一个指向None的指针。一个Node对象如下示意图：</p><p><img src="/images/2016-05-16-01.jpg" alt="node"></p><p>而队列里分为两端，一端叫前端，这一端做数据的删除操作，另一端叫后端，做数据的增加操作。数据只能从后端加入，并只能从前端删除。为了抽象这个<code>Queue</code>类，会创建两个指针，一个<code>head</code>，指向队头的元素，一个<code>tail</code>，指向队尾的元素。如果是一个空的队列，那<code>head</code>和<code>tail</code>都指向<code>None</code>。</p><p>一个空队列示意图：</p><p><img src="/images/2016-05-16-02.jpg" alt="node"></p><p>当队列里有一个元素时，<code>head</code>和<code>tail</code>两个指针都指向这个元素，示意图是这样的：</p><p><img src="/images/2016-05-16-03.jpg" alt="node"></p><p>当队列再增加一个元素时，<code>tail</code>指针会移动到新增加的这个元素，前一个元素的<code>next</code>指针也会指向新元素，而<code>head</code>指针不会发生改变，如下图：</p><p><img src="/images/2016-05-16-04.jpg" alt="node"></p><p>不断向队列增加元素时，各个指针移动方式如上。</p><p>当是删除元素时，直接把<code>head</code>指针移动到下一个元素，再把值弹出即可。</p><p>来看一个最简单队列的代码实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is a empty queue&#x27;</span>)</span><br><span class="line">        cur = self.head</span><br><span class="line">        self.head = cur.next</span><br><span class="line">        <span class="keyword">return</span> cur.value</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        q.enqueue(i)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(q.dequeue())</span><br><span class="line">    print(q.is_empty())</span><br><span class="line">    print(q.size())</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在实际编码中不会自己来实现一个队列，而是使用标准库中的<code>queue</code>，通过<code>from queue import Queue</code>来导入Queue类。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的运用-表达式解析</title>
      <link href="/2016/05/14/2016-05-14-%E6%A0%88%E8%BF%90%E7%94%A8-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/05/14/2016-05-14-%E6%A0%88%E8%BF%90%E7%94%A8-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之数据结构栈实现表达式解析。</p><a id="more"></a><h2 id="栈运用-表达式解析">栈运用-表达式解析</h2><p>以一个表达式解析的例子来说明栈的运用，比如要解析<code>(3 + 4) * 5 / ((2 + 3) *3)</code>这样一个数字表达式，观察这个表达式可知道一个正确的表达式括号是成对出现的，如果不是，那表达式是有误。</p><p>用静态的示意图不好表达这个过程，这里就来描述一下这个过程：</p><ol><li><p>表达式是一个字符串，可以用for循环得到表达式中每一个元素，因空白字符不会参与计算，所以空白字符不需要处理</p></li><li><p>如果是&quot;(+/-=*&quot;这样的字符时直接就入栈</p></li><li><p>如果元素不是’)’，说明字符是个数字，此有以下几种情况：</p><p>3.1、此时栈顶元素是“+/-*”这样的计算符号，把符号pop出来，接着再判断栈顶元素是不是数字，不是数字则表达式是错误的，如果是数字，那也把此数字pop出来，按照pop出的计算符号与前边的数字进行计算，得到结果后把此数字push回栈。</p><p>3.2、如果栈顶元素不是“+/-*”这样的计算符号，直接入栈</p></li><li><p>如果元素是’)’，判断栈顶元素是不是数字，如果不是就抛出异常，说明表达是有问题的。如果是一个数字，则把栈顶的数字元素pop出，再判断栈顶元素是不是’(’，如果不是，抛出异常说明表达式有误，如果是’(’，那也把’('元素pop出来，再把之前弹出的数字元素push回栈</p></li><li><p>通过上边的计算和判断后栈里可能剩下的就是一个含有一个计算符号的表达式，此时再把栈顶pop出来并判断这是不是一个数字，如果是，则把栈顶元素pop出来，得到一个计算符号，接着再把栈顶元素pop，此时这个栈顶元素应该是一个数字，这样根据计算符号就可以得到最终的结果。</p></li></ol><p>代码如下：</p><p>stack.py模块</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stack <span class="keyword">import</span> Stack</span><br><span class="line"> </span><br><span class="line">func_map = &#123;</span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: <span class="keyword">lambda</span> x, y: x+y,</span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: <span class="keyword">lambda</span> x, y: x-y,</span><br><span class="line">    <span class="string">&#x27;*&#x27;</span>: <span class="keyword">lambda</span> x, y: x*y,</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="keyword">lambda</span> x, y: x/y</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cacl</span>(<span class="params">expr</span>):</span></span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> expr:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&#x27;(+-*/&#x27;</span>:</span><br><span class="line">            stack.push(c)</span><br><span class="line">        <span class="keyword">elif</span> c.strip() == <span class="string">&#x27;&#x27;</span>:   <span class="comment"># 对空格的处理</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                c = int(c)</span><br><span class="line">                <span class="keyword">if</span> stack.top.value <span class="keyword">in</span> <span class="string">&#x27;+/-*&#x27;</span>:</span><br><span class="line">                    s = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(stack.top.value, (int, float)):</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">                    v = stack.pop()</span><br><span class="line">                    v = func_map[s](v, c)</span><br><span class="line">                    stack.push(v)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.push(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> isinstance(stack.top.value, (int, float)):</span><br><span class="line">                    v = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack.top.value == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        stack.push(v)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> stack.top:</span><br><span class="line">        c = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(c, (int,float)):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> stack.top.value <span class="keyword">in</span> <span class="string">&#x27;+/-*&#x27;</span>:</span><br><span class="line">            s = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(stack.top.value, (int, float)):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line">            v = stack.pop()</span><br><span class="line">            v = func_map[s](v, c)</span><br><span class="line">            <span class="keyword">if</span> stack.top <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 栈顶是None时才表明表达式解析完成</span></span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;wrong expr&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    expr = <span class="string">&#x27;(3 + 4) * 5 / ((2 + 3) *3)&#x27;</span></span><br><span class="line">    print(cacl(expr))</span><br></pre></td></tr></table></figure><p>此代码中的<code>func_map</code>函数算是一个技巧，这样就可以方便的为两个数字进行加减乘除运算，少去了用多个<code>if</code>语句来做判断。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈运用，表达式解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构之栈</title>
      <link href="/2016/05/14/2016-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2016/05/14/2016-05-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之<code>数据结构-栈</code></p><a id="more"></a><h2 id="数据结构-栈">数据结构-栈</h2><p>栈（也叫“push-down stack”-下推栈）一种线性有序的数据元素集合，它的特点是，数据的增加删除操作都在同一端进行。进行操作的这一端，我们一般叫做“顶”，另一端叫做“底”。</p><p>栈的底部很有象征性，因为元素越接近底部，就意味着在栈里的时间越长。最近进来的，总是最早被移走，这种排列规律叫做先进后出，综合为LIFO( last-in first-out)。所以栈的排序是按时间长短来排列元素的。新来的在栈顶，老家伙们在栈底。</p><p>下图反应了栈中数据加入和移走的顺序：</p><p><img src="/images/2016-05-13-12.jpg" alt="栈"></p><p>一个栈一般会实现以下方法：</p><ol><li>Stack(),构造方法，创建一个空栈，无参数，返回值是空栈</li><li>push(value) 向栈顶压入一个新数据项，需要一个数据项参数，无返回值</li><li>pop() 抛出栈顶数据项，无参数，返回被抛出的数据项，栈本身发生变化</li><li>peek() 返回栈顶数据项，但不删除。不需要参数，栈不变</li><li>is_empty() 测试栈是否空栈。不需要参数，返回布尔值。</li><li>size() 返回栈内数据项的数目，不需要参数，返回值是整数</li></ol><p>在python中栈的实现有多种，可以用内置的list数据结构实现，只要约定一个列表的一堆为栈顶，那可以利用现成的<code>append</code>和<code>pop</code>方法对列表(栈)进行操作，这里以另外的方式实现。</p><h3 id="Node类实现">Node类实现</h3><p>栈中的节点具有两个部份，这与链表中的节点类似，一个<code>数据域</code>，一个<code>指针域</code>。先看<code>Node</code>类的代码实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>Node类接收一个value参数，实例化后生成一个<code>数据域</code>为<code>value</code>，<code>next</code>指针指向<code>None</code>的对象。<br>用以下代码实例化后生成一个节点：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = Node(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>一个节点可以用一个示意图表示，如下：</p><p><img src="/images/2016-05-14-01.jpg" alt="node"></p><h3 id="Stack类实现">Stack类实现</h3><h4 id="构建函数实现">构建函数实现</h4><p>构建函数的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>构建函数初始化时创建了一个栈顶指针<code>top</code>，并指向<code>None</code>，如果栈里有数据，<code>top</code>指针会指向靠近栈顶的元素。此类执行以下代码实例化后生成一个空栈：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = Stack()</span><br></pre></td></tr></table></figure><p>一个空栈可以用以下示意图表示：</p><p><img src="/images/2016-05-13-13.jpg" alt="空栈"></p><h4 id="push方法实现">push方法实现</h4><p><code>push</code>方法实现向栈增加元素，这个过程叫做<code>押栈</code>，有以下操作要做：</p><ol><li>既然是增加元素，当然要实例化Node类，这里以node变量表示指向Node类的实例化对象</li><li>把node的next指针指向栈的top指针指向的对象</li><li>移动top指针移动到栈顶元素</li></ol><p>代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br></pre></td></tr></table></figure><p>如执行以下代码，向栈内增加一个元素：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.push(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>此时栈内可用以下示意图来表示这个过程：</p><p><img src="/images/2016-05-14-02.jpg" alt="node"></p><p>当不断向栈内增加数据，如下操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>这样会出现类似下图的数据结构：</p><p><img src="/images/2016-05-14-03.jpg" alt="node"></p><h4 id="pop方法实现">pop方法实现</h4><p>pop方法返回栈顶元素的值，此过程需要把top指针指向栈顶指向元素的下一个元素，然后把栈顶元素返回。也要考虑是对空栈的操作。</p><p><code>pop</code>方法的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><p>代码中使用了一个临时变量<code>node</code>，先让此变量指向栈顶元素，这样<code>node</code>这个对象就可以调用<code>next</code>属性，即可以再把栈的<code>top</code>指针指向栈顶元素的下一个元素。其实质就是移动了<code>top</code>指针的位置。比如执行如下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.pop()</span><br></pre></td></tr></table></figure><p>这个过程如下示意图：</p><p><img src="/images/2016-05-14-04.jpg" alt="node"></p><p>栈顶指针移动后，栈顶元素会被垃圾回收器回收掉。</p><h4 id="peek方法实现">peek方法实现</h4><p>peek方法直接返回栈顶元素。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><h4 id="is-empty方法实现">is_empty方法实现</h4><p>is_empty方法判断是否为空栈，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.top</span><br></pre></td></tr></table></figure><h4 id="size方法实现">size方法实现</h4><p>size方法返回栈内元素的个数，和链表的size方法类似，也用一个累加器完成计数。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="Node类和Stack类的完整代码">Node类和Stack类的完整代码</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.top</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#    print(stack.pop())</span></span><br><span class="line"><span class="comment">#    print(stack.top.value)</span></span><br><span class="line">    print(stack.peek())</span><br><span class="line">    print(stack.is_empty())</span><br><span class="line">    print(stack.size())</span><br></pre></td></tr></table></figure><h3 id="栈运用-平衡符号">栈运用-平衡符号</h3><p>平衡符号是栈的一种运用。像<code>[]、()、&#123;&#125;</code>这样符号都是成对出现的，我们可以用下边的代码来检测一个表达式所使用的这种成对出现的符号是否正确，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = self.top</span><br><span class="line">        self.top = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        self.top = node.next</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.top</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.top</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;This is an empty stack&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    exp = <span class="string">&#x27;&#123;a * [x/(x+y)]&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> exp:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&#x27;&#123;[(&#x27;</span>:</span><br><span class="line">            stack.push(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;&#125;])&#x27;</span>:</span><br><span class="line">            v = stack.top.value</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> v != <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;]&#x27;</span> <span class="keyword">and</span> v != <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> v != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">if</span> stack.top <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;ok&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的模块化</title>
      <link href="/2016/05/12/2016-05-12-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2016/05/12/2016-05-12-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之模块化</p><a id="more"></a><h2 id="模块化">模块化</h2><h3 id="基本概念">基本概念</h3><ul><li>在python中，模块、包和库的概念并没有那么清晰</li><li>一个文件就是一个模块，模块名就是文件名</li><li>一个目录，包含了<code>__init__.py</code>就是一个包</li><li>通常的当一个包或者若干包，包含一个<code>setup.py</code>就认为是一个可分发的库</li></ul><h3 id="导入模块">导入模块</h3><p>导入模块有两种方式，如下：</p><p>import <em>module</em></p><p>from <em>module</em> import <em>submodule</em></p><p>这两种导入方式的命名空间是不同的，以一个例子说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.basename(<span class="string">&#x27;/usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">&#x27;usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> basename</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename(<span class="string">&#x27;usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br></pre></td></tr></table></figure><p>上边的多种引用模块的方式都可以让我们使用<code>basename</code>，但各自的命名空间不一样。</p><h3 id="重命名">重命名</h3><p>引入模块的重命名用<code>as</code>语法，看下边的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> basename <span class="keyword">as</span> os_basename</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_basename(<span class="string">&#x27;/usr/local/etc&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'etc'</code></pre><p>当然直接用<code>import</code>导入模块时也可以用<code>as</code>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys <span class="keyword">as</span> system</span><br></pre></td></tr></table></figure><p>这样sys模块的名称被重命名为system了</p><p>当一个模块被导入时，真正发生了什么呢？看下边的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># pwd</span></span><br><span class="line">/root/virtual_env/fourth_week/learning</span><br><span class="line"> </span><br><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># ls</span></span><br><span class="line">foo.py  main.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># cat foo.py </span></span><br><span class="line"><span class="comment">#!/root/.pyenv/versions/pythv_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am bar in foo&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># cat main.py </span></span><br><span class="line"><span class="comment">#!/root/.pyenv/versions/pythv_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"> </span><br><span class="line">foo.bar()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># python3 main.py </span></span><br><span class="line">ha ha ha</span><br><span class="line">i am bar <span class="keyword">in</span> foo</span><br></pre></td></tr></table></figure><p>在<code>main.py</code>文件中用<code>import foo</code>的方式导入了<code>foo</code>模块，接着再调用了<code>foo</code>模块的<code>bar</code>函数，当执行<code>main.py</code>文件时，首先执行了<code>foo</code>模块的<code>print('ha ha ha')</code>语句，再执行了<code>bar</code>函数。</p><p>这说明当导入一个模块时，其实是执行了此模块，所以当一个文件是以模块的形式被导入时，应避免此模块中有一些全局性的语句，比如这时的<code>print('ha ha ha')</code>语句。</p><p>用<code>from foo import bar</code>的导入方式也是执行了<code>foo</code>文件，作如下验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># cat main.py </span></span><br><span class="line"><span class="comment">#!/root/.pyenv/versions/pythv_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf8 _*_</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(pythv_3<span class="number">.5</span><span class="number">.1</span>) [root@nod3 learning]<span class="comment"># python3 main.py </span></span><br><span class="line">ha ha ha</span><br></pre></td></tr></table></figure><h2 id="相对导入和绝对导入">相对导入和绝对导入</h2><p>在接下来的代码示例不再方便使用jumper来展示，开始用pycharm开发工具来展示代码。</p><p>为了说明模块的相对导入和绝对导入，在pycharm中创建了一个<code>reference</code>包，包内有<code>bar.py</code>和<code>foo.py</code>两个模块，在<code>reference</code>包外有一个<code>main.py</code>模块。目录结构如下图：</p><p><img src="/images/2016-05-12-01.png" alt="目录结构"></p><p>各个模块中的内容如下：</p><p><a href="http://foo.py">foo.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;i am in reference.foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://bar.py">bar.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> reference.foo <span class="keyword">import</span> fn</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    fn()</span><br></pre></td></tr></table></figure><p><a href="http://main.py">main.py</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from reference.bar import bar</span><br><span class="line"> </span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>当运行<code>main.py</code>时会得到下边的输出内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am <span class="keyword">in</span> reference.foo</span><br></pre></td></tr></table></figure><p>上边的<code>bar.py</code>和<code>main.py</code>模块中的<code>from</code>语句都是从包名<code>reference</code>这里开始引用的，这种引用就是<code>绝对引用</code>。</p><p>因<code>foo.py</code>和<code>bar.py</code>两个模块都是在包<code>reference</code>内，所以<code>bar.py</code>里引用<code>foo</code>模块时可以使用相对引用的方式，如下：</p><p><a href="http://bar.py">bar.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .foo <span class="keyword">import</span> fn</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    fn()</span><br></pre></td></tr></table></figure><p>这样就是<code>相对引用</code>的方式。</p><h3 id="循环导入">循环导入</h3><p>在实际编码中要避免循环导入的，举一个例子说明什么是循环引入。</p><p><a href="http://xn--foo-cy0e153b.py">假如foo.py</a>、<a href="http://bar.py">bar.py</a>、<a href="http://main.py">main.py</a>，这三个模块都在同一个包内，各自的代码如下：</p><p><a href="http://foo.py">foo.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bar <span class="keyword">import</span> fn <span class="keyword">as</span> bar</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    bar()</span><br><span class="line">    print(<span class="string">&#x27;i am foo&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://bar.py">bar.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> fn <span class="keyword">as</span> foo</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    foo()</span><br><span class="line">    print(<span class="string">&#x27;i am bar&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a href="http://main.py">main.py</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> fn</span><br><span class="line"> </span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>当运行main.py时，抛出以下异常：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/pythonlearning/fourth_week/reference/main.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> foo <span class="keyword">import</span> fn</span><br><span class="line">  File <span class="string">&quot;D:\pythonlearning\fourth_week\reference\foo.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> bar <span class="keyword">import</span> fn <span class="keyword">as</span> bar</span><br><span class="line">  File <span class="string">&quot;D:\pythonlearning\fourth_week\reference\bar.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> foo <span class="keyword">import</span> fn <span class="keyword">as</span> foo</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;fn&#x27;</span></span><br></pre></td></tr></table></figure><p>上边的foo模块和bar模块就发生了循环引用的情况，这样在执行main.py时，解释器就会抛出上边的异常信息。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构-链表</title>
      <link href="/2016/05/12/2016-05-12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2016/05/12/2016-05-12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之链表</p><a id="more"></a><h2 id="数据结构-链表">数据结构-链表</h2><p>什么是链表，我对这个概念非常陌生。</p><p>链表是实现了数据之间保持逻辑顺序，但存储空间不必按顺序的方法。可以用一个图来表示这种链表的数据结构：</p><p><img src="/images/2016-05-13-01.jpg" alt="链表"><br>　　　　　　　　　　　　　　　　图１：链表</p><p>链表中的基本要素：</p><ol><li>结点(也可以叫节点或元素)，每一个结点有两个域，左边部份叫<code>值域</code>，用于存放用户数据；右边叫<code>指针域</code>，一般是存储着到下一个元素的指针</li><li>head结点，head是一个特殊的结节，head结点永远指向第一个结点</li><li>tail结点，tail结点也是一个特殊的结点，tail结点永远指向最后一个节点</li><li>None，链表中最后一个结点指针域的指针指向None值，因也叫<code>接地点</code>，所以有些资料上用电气上的接地符号代表None</li></ol><p>链表的常用方法：</p><ol><li>LinkedList() 创建空链表，不需要参数，返回值是空链表</li><li>is_empty() 测试链表是否为空，不需要参数，返回值是布尔值</li><li>append(data) 在尾部增加一个元素作为列表最后一个。参数是要追加的元素，无返回值</li><li>iter() 遍历链表，无参数，无返回值，此方法一般是一个生成器</li><li>insert(idx,value) 插入一个元素，参数为插入元素的索引和值</li><li>remove(idx)移除1个元素，参数为要移除的元素或索引，并修改链表</li><li>size() 返回链表的元素数，不需要参数，返回值是个整数</li><li>search(item) 查找链表某元素，参数为要查找的元素或索引，返回是布尔值</li></ol><h3 id="节点类">节点类</h3><p>python用类来实现链表的数据结构，节点（Node）是实现链表的基本模块，每个节点至少包括两个重要部分。首先，包括节点自身的数据，称为“数据域”(也叫值域)。其次，每个节点包括下一个节点的“引用”(也叫指针)</p><p>下边的代码用于实现一个Node类：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>此节点类只有一个构建函数，接收一个数据参数，其中<code>next</code>表示指针域的指针，实例化后得到一个节点对象，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node = Node(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>此节点对象数据为<code>4</code>，指针指向None。</p><p>这样一个节点对象可以用一个图例来更形象的说明，如下：</p><p><img src="/images/2016-05-13-02.jpg" alt="链表"><br>　　　　　　　　　　　　　　图2:　节点</p><h3 id="链表类">链表类</h3><p>先来看LinkedList类的构建函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>此类实例后会生成一个链表对象，初始化了<code>head</code>和<code>tail</code>节点，且两节点都指向<code>None</code>，实例化代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list = LinkedList()</span><br></pre></td></tr></table></figure><p>也可以用图形象的表示这个链表对象，如下：</p><p><img src="/images/2016-05-13-03.jpg" alt="链表"><br>　　　　　　　　　　　　　　　　　　　图3：空链表</p><h4 id="is-empty方法实现">is_empty方法实现</h4><p>is_empty方法检查链表是否是一个空链表，这个方法只需要检查<code>head</code>节点是否指向<code>None</code>即可，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>如果是空列表返回<code>True</code>，否则返回<code>False</code></p><h4 id="append方法实现">append方法实现</h4><p>append方法表示增加元素到链表，这和insert方法不同，前者使新增加的元素成为链表中第一个节点，而后者是根据索引值来判断插入到链表的哪个位置。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br></pre></td></tr></table></figure><p>既然要新增加节点，首先把Node类实例化得到一个node对象。这里有两种情况需要考虑，一是链表是一个空链表时怎样append一个节点；二是当链表不是空链表时又怎样append一个节点？</p><p>当<code>if self.head is None:</code>为<code>True</code>时，把链表的<code>head</code>和<code>tail</code>都指向了<code>node</code>，假如我们执行了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list(append(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>此时的链表结构如下图：</p><p><img src="/images/2016-05-13-04.jpg" alt="链表"><br>　　　　　　　　　　　　　　　　图4：append-1</p><p>当<code>if self.head is None:</code>为<code>False</code>时,说明链表已经增加了一个节点了，再增加一个节点时<code>head</code>已经指向了第一个节点，所以不为<code>None</code>，比如增加的第二个节点为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_list(append(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>增加第二个节点的操作需要分两步完成，第一步：<code>self.tail.next = node</code>，即把上一个节点的<code>next</code>指针指向当前<code>node</code>；第二步：<code>self.tail = node</code>，把<code>tail</code>移动到<code>node</code>，如下图：</p><p><img src="/images/2016-05-13-05.jpg" alt="链表"></p><p>移动完成后就成这样了：</p><p><img src="/images/2016-05-13-06.jpg" alt="链表"></p><p>当增加第三个、第四个等节点时，按照上边的操作依次类推。</p><h3 id="iter方法实现">iter方法实现</h3><p>iter方法表示遍历链表。在遍历链表时也要首先考虑空链表的情况。遍历链表时从<code>head</code>开始，直到一个节点的<code>next</code>指向<code>None</code>结束，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">yield</span> cur.data</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">yield</span> cur.data</span><br></pre></td></tr></table></figure><p>当是遍历一个空链表时，<code>if not self.head:</code>为<code>True</code>，直接返回<code>None</code>；如果不是空链表就让一个局部变量<code>cur</code>指向<code>head</code>,并把<code>head</code>的<code>data</code>属性<code>yield</code>出来，再对<code>cur</code>的<code>next</code>指针指向的对象做<code>while</code>循环，直到<code>next</code>指向<code>None</code>，这样就遍历了链表。</p><h3 id="insert方法实现">insert方法实现</h3><p>假如采取<code>append</code>方法又增加了两个节点，增加完成后如下图：</p><p><img src="/images/2016-05-13-07.jpg" alt="链表"></p><p>如果想在数据域为<code>6</code>的那节点处插入一个节点，需要做的操作有两步：</p><ol><li>把新节点的next指针指向数据域为<code>6</code>的这个节点，即为数据域为<code>5</code>节点的next指向指向的对象</li><li>把数据域为<code>5</code>节点的next指针指向新加的节点</li></ol><p>注： 这两个步骤不能颠倒，如果颠倒，数据域为<code>6</code>的节点会被丢失，数据域为<code>7</code>的节点不再是链表的节点。</p><p>示意图如下：</p><p><img src="/images/2016-05-13-08.jpg" alt="链表"></p><p>还要额外考虑两种情况：</p><ol><li>空链表时</li><li>插入位置超出链表节点的长度时</li><li>插入位置是链表的最后一个节点时，需要移动tail</li></ol><p>当是在链表最后一个节点插入时，示意图如下：</p><p><img src="/images/2016-05-13-09.jpg" alt="链表"></p><p>要在指定的索引位置插入一个节点，前提是需要找到这个位置，在链表中只有采用遍历的方式，具有O(n)的速度，最糟糕时会遍历链表的所有节点，而当找到插入点时，我们并不需要当前节点的信息，而是需要前一个节点的信息，所以代码中巧妙的使用了<code>while cur_idx &lt; idx-1:</code>的方式，这样能使用<code>cur</code>这个变量能指向插入点上一个节点对象。</p><p>实现<code>insert</code>方法的代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, idx, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">            cur_idx += <span class="number">1</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">        <span class="keyword">if</span> node.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.tail = node</span><br></pre></td></tr></table></figure><h3 id="remove方法实现">remove方法实现</h3><p>remove方法接收一个idx参数，表示要删除节点的索引，此方法要考虑以下几种情况：</p><ol><li>空链表，直接抛出异常</li><li>删除第一个节点时，移动head到删除节点的next指针指向的对象</li><li>链表只有一个节点时，把head与tail都指向None即可</li><li>删除最后一个节点时，需要移动tail到上一个节点</li><li>遍历链表时要判断给定的索引是否大于链表的长度，如果大于则抛出异常信息</li></ol><p>请看下边图例：</p><p><img src="/images/2016-05-13-10.jpg" alt="链表"></p><p><img src="/images/2016-05-13-11.jpg" alt="链表"></p><p>以下为remove函数的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">       cur = self.head</span><br><span class="line">       cur_idx = <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空链表时</span></span><br><span class="line">           <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">       <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:</span><br><span class="line">           cur = cur.next</span><br><span class="line">           <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">               <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">           cur_idx += <span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> idx == <span class="number">0</span>:   <span class="comment"># 当删除第一个节点时</span></span><br><span class="line">           self.head = cur.next</span><br><span class="line">           cur = cur.next</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       <span class="keyword">if</span> self.head <span class="keyword">is</span> self.tail:   <span class="comment"># 当只有一个节点的链表时</span></span><br><span class="line">           self.head = <span class="literal">None</span></span><br><span class="line">           self.tail = <span class="literal">None</span></span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       cur.next = cur.next.next</span><br><span class="line">       <span class="keyword">if</span> cur.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 当删除的节点是链表最后一个节点时</span></span><br><span class="line">           self.tail = cur</span><br></pre></td></tr></table></figure><h3 id="size函数实现">size函数实现</h3><p>size函数不接收参数，返回链表中节点的个数，要获得链表的节点个数，必定会遍历链表，直到最后一个节点的<code>next</code>指针指向<code>None</code>时链表遍历完成，遍历时可以用一个累加器来计算节点的个数，如下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;The list is an empty list&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            current = current.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="search函数实现">search函数实现</h3><p>search函数接收一个item参数，表示查找节点中数据域的值。search函数遍历链表，每到一个节点把当前节点的<code>data</code>值与<code>item</code>作比较，最糟糕的情况下会全遍历链表。如果查找到有些数据则返回<code>True</code>，否则返回<code>False</code>，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> current.data == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.next</span><br><span class="line">        <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h3 id="Node类与LinkedList类完整代码">Node类与LinkedList类完整代码</h3><p>最后把<code>Node类</code>和<code>LinkedList类</code>的完整代码整理如下：</p><p>Node类：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>LinkedList类及调度代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.next = node</span><br><span class="line">            self.tail = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">yield</span> cur.data</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">yield</span> cur.data</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, idx, value</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:             <span class="comment"># 判断是否是空链表</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:   <span class="comment"># 遍历链表</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:   <span class="comment"># 判断是不是最后一个元素</span></span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">            cur_idx += <span class="number">1</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line">        <span class="keyword">if</span> node.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.tail = node</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        cur_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 空链表时</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;The list is an empty list&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur_idx &lt; idx<span class="number">-1</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;list length less than index&#x27;</span>)</span><br><span class="line">            cur_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span>:   <span class="comment"># 当删除第一个节点时</span></span><br><span class="line">            self.head = cur.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.head <span class="keyword">is</span> self.tail:   <span class="comment"># 当只有一个节点的链表时</span></span><br><span class="line">            self.head = <span class="literal">None</span></span><br><span class="line">            self.tail = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur.next = cur.next.next</span><br><span class="line">        <span class="keyword">if</span> cur.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 当删除的节点是链表最后一个节点时</span></span><br><span class="line">            self.tail = cur</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;The list is an empty list&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            current = current.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">if</span> current.data == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.next</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    link_list = LinkedList()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">150</span>):</span><br><span class="line">        link_list.append(i)</span><br><span class="line"><span class="comment">#    print(link_list.is_empty())</span></span><br><span class="line"><span class="comment">#    link_list.insert(10, 30)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#    link_list.remove(0)</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> link_list.iter():</span><br><span class="line">        print(<span class="string">&#x27;node is &#123;0&#125;&#x27;</span>.format(node))</span><br><span class="line">    print(link_list.size())</span><br><span class="line"><span class="comment">#    print(link_list.search(20))</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python异常处理</title>
      <link href="/2016/05/12/2016-05-12-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2016/05/12/2016-05-12-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之异常处理</p><a id="more"></a><h2 id="异常处理">异常处理</h2><h3 id="错误与异常">错误与异常</h3><p>错误：通常指程序运行中不可恢复的问题</p><p>异常：通常指可以在程序运行时恢复的问题</p><p>异常处理的一般语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try: (1)</span><br><span class="line">    block</span><br><span class="line">except ExceptionClass as e:  (2)</span><br><span class="line">    pass</span><br><span class="line">finally:  (3)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><ol><li>异常处理以<code>try</code>开始</li><li>当异常发生时按照一定的规则执行<code>except</code>块，可以存在多个<code>except</code>块</li><li>可选的<code>finally</code>块，无论如何都会被执行，通常用于清理工作</li></ol><p>以一个例子来说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------ZeroDivisionError                         Traceback (most recent call last)&lt;ipython-input-3-a0641230c7a8&gt; in &lt;module&gt;()----&gt; 1 3/0ZeroDivisionError: division by zero</code></pre><p>显然，数字0是不能做除数的，这里会抛出<code>ZeroDivisionError</code>错误，程序执行被中止。如果我们想执行<code>3/0</code>时不抛出这样的异常，而是可以人为处理，这时就需要做异常处理了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="number">3</span>/<span class="number">0</span></span><br><span class="line">    print(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&#x27;finally&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>startdivision by zerofinally</code></pre><p>上边代码中人为加入了两个<code>print</code>语句是为了看清代码的执行流程。解释器当执行到<code>3/0</code>时，会抛出上边的<code>ZeroDivisionError</code>异常，此时解释器就不会在执行<code>try</code>语句中的<code>print('end')</code>语句了，而是被<code>except</code>语句捕捉到，执行此代码块中的语句<code>print(e)</code>，这里的<code>e</code>是一个变量，表示把异常的信息保存到这个变量上，这是一个可选择参数，如果没有<code>as e</code>，那异常信息就不会被保存。最后再执行了<code>finally</code>代码块中的语句。</p><p><code>except</code>代码是一个类型匹配的过程，可以允许多次出现，但要注意匹配的顺序，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">3</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">&#x27;Exception&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">&#x27;ZeroDivisionError&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Exception</code></pre><p><code>3/0</code>不是会抛出<code>ZeroDivisionError</code>的异常吗？这里怎么没有被捕捉到，而是被<code>except Exception:</code>语句捕捉到了？这是因为异常在python也是一个class，决大多数的异常都是在<code>Exception</code>类中的，<code>ZeroDivisionError</code>是<code>Exception</code>的子类，所以在实际编码中，当有多个<code>except</code>语句时应该把子类放在前面，父类写在后边。</p><p>如果<code>except</code>后边不接任何类名，表示可以捕捉任何的异常信息。</p><p>再来看一下<code>finally</code>语句，它在异常处理中不管是否捕捉到异常，<code>finally</code>语句都会被执行，以下边的例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call p function&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> p()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">main()</span><br></pre></td></tr></table></figure><pre><code>call p functionfinally...</code></pre><p>在<code>main</code>函数中有一个<code>return</code>语句，执照常理来说，在一个函数中执行<code>return</code>语句时，此函数就执行结束了，但这里为什么还会执行<code>finally</code>语句呢？</p><p>执行流程大致是这样的：</p><p>当解释器执行到<code>return p()</code>语句时，先调用<code>p</code>函数，输出了<code>call p function</code>，接着并没有把结果return回去，而是把此时的状态保存起来后去执行<code>finally</code>语句，执行完成后把之前保存的状态恢复后再执行<code>return</code>操作，这样就成上边调用<code>main</code>函数的输出信息了。</p><h3 id="抛出异常">抛出异常</h3><p>抛出异常使用<code>raise</code>语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;i &lt; 0&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">fn(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------Exception                                 Traceback (most recent call last)&lt;ipython-input-3-87e48ca0d898&gt; in &lt;module&gt;()      3         raise Exception('i &lt; 0')      4 ----&gt; 5 fn(-4)&lt;ipython-input-3-87e48ca0d898&gt; in fn(i)      1 def fn(i):      2     if i &lt; 0:----&gt; 3         raise Exception('i &lt; 0')      4       5 fn(-4)Exception: i &lt; 0</code></pre><p><code>raise Exception('i &lt; 0')</code>语句就是抛出一个自定义异常信息，<code>Exception</code>是类，其实质是抛出了<code>Exception</code>类的一个实例。</p><h3 id="未处理异常">未处理异常</h3><p>异常未处理时会往上层抛出，如果都没有异常处理时会交给python解释器处理，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    <span class="number">3</span>/<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    fn()</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------ZeroDivisionError                         Traceback (most recent call last)&lt;ipython-input-5-57d9f8a0a6b1&gt; in &lt;module&gt;()      5     fn()      6 ----&gt; 7 main()&lt;ipython-input-5-57d9f8a0a6b1&gt; in main()      3       4 def main():----&gt; 5     fn()      6       7 main()&lt;ipython-input-5-57d9f8a0a6b1&gt; in fn()      1 def fn():----&gt; 2     3/0      3       4 def main():      5     fn()ZeroDivisionError: division by zero</code></pre><p>上边的异常信息就一层层的往上层抛出，最后由解释器处理了。如果要在<code>main()</code>捕捉异常呢，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><pre><code>division by zero</code></pre><h3 id="自定义异常">自定义异常</h3><p>自定义异常：当一个类继承自Exception类或其派生类时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> MyException(<span class="string">&#x27;exception&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------MyException                               Traceback (most recent call last)&lt;ipython-input-8-c6b10bf8a778&gt; in &lt;module&gt;()----&gt; 1 raise MyException('exception')MyException: exception</code></pre><p><code>MyException</code>类继承自<code>Exception</code>类，所以<code>MyException</code>类是一个自定义异常类，当执行<code>raise MyException('exception')</code>语句时抛出的异常就是自定义的异常类。</p><p>捕获自定义异常，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyException(<span class="string">&#x27;exception&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> MyException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><pre><code>exception</code></pre>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的property实现原理</title>
      <link href="/2016/05/10/2016-05-10-property%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2016/05/10/2016-05-10-property%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之property的实现原理</p><a id="more"></a><p>以实际的例子来说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,fget=None,fset=None,fdel=None</span>):</span></span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fget(instance)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.fset(instance,value)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.fdel(instance)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fget = fn</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fset = fn</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deler</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fdel = fn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.__val = val</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @val.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_val</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        self.__val = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Spam(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.val   <span class="comment">#Spam.val.__get__(s,Spam)</span></span><br></pre></td></tr></table></figure><pre><code>4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.val = <span class="number">3</span>  <span class="comment">#Spam.val.__set__(s,3)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.val</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><p>现在来分析一下上边的代码：</p><p>当执行<code>s = Spam(4)</code>时，调用比较简单，就是直接执行类<code>Spam</code>的构建函数<code>__init__</code>，这样就得到一个私有变量<code>__val</code>，值为<code>4</code>。</p><p>当执行<code>s.val</code>时，因<code>val</code>函数被<code>Property</code>所装饰，所以<code>val</code>函数可以像属性一样调用；因<code>Property</code>类是一个描述器，所以<code>s.val</code>操作首先会实例化<code>Property</code>类，把<code>__init__</code>函数中的<code>fget</code>指向<code>Spam</code>类的<code>val</code>函数，把<code>fset</code>指向<code>Spam</code>类的<code>set_val</code>函数，接着就去调用<code>Property</code>类的<code>__get__</code>函数代码块，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">       <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> self.fget(instance)</span><br></pre></td></tr></table></figure><p>这里的<code>instance</code>指向<code>Spam</code>类的实例<code>s</code>，<code>cls</code>指向<code>Spam</code>类，因<code>fget</code>已指向了<code>Spam</code>类的<code>val</code>函数，所以if语句为True，执行<code>return self.fget(instance)</code>语句，这里的<code>self.fget</code>指向了<code>Spam</code>类的<code>val</code>函数，<code>instance</code>指向了<code>Spam</code>类的实例<code>s</code>，其实质就是调用<code>Spam</code>类的<code>val</code>函数，即返回<code>__val</code>的值。这个调用过程其实质与<code>Spam.val.__get__(s,Spam)</code>相同。</p><p>当执行<code>s.val = 3</code>时，整个调用过程与执行<code>s.val</code>的过程类似，只是把调用<code>__get__</code>换成了调用<code>__set__</code>函数，这个调用过程其实质与<code>Spam.val__set__(s,3)</code>相同。</p><p><strong>有个疑问？</strong></p><p>在<code>2016-05-06-面向对象-封装-property.md</code>中讲如何使用<code>@property</code>这个装饰器时说被<code>@property</code>装饰的函数名(<em>FunName</em>)与被&quot;@<em>FunName</em>.setter&quot;装饰器装饰的函数名要相同，但今天这里讲<code>property</code>的是如何实现时，又需要把两个函数的名称设置成不同，比如上边的<code>val</code>和<code>set_val</code>，这是为什么？</p><p>既然可以对一个类的实例变量做装饰，那对类变量也是一样的，如下边代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassProperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,fn</span>):</span></span><br><span class="line">        self.fn = fn</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.fn(cls)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam1</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__name__.lower()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = Spam1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.val</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.name</span><br></pre></td></tr></table></figure><pre><code>'spam1'</code></pre><p>分析一下上边的代码：</p><p>当python解释器执行到下边代码块时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam1</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ClassProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.__name__.lower()</span><br></pre></td></tr></table></figure><p>解释器会创建一个名为<code>Spam1</code>的类空间，在此空间中创建一个<code>__val</code>的私有变量；当执行到第一个被<code>@ClassProperty</code>装饰器装饰的<code>val</code>函数时，会把<code>val</code>这个函数名称传递给<code>ClassProperty</code>类的<code>fn</code>参数，接着下边的函数<code>name</code>也会被传递给<code>ClassProperty</code>类的<code>fn</code>参数，这样函数<code>val</code>已不再是原先的函数了，而是一个被<code>ClassProperty</code>装饰过的函数。</p><p>当执行<code>s1 = Spam1()</code>时，只是实例化了一个类，比较好理解。</p><p>当执行<code>s1.val</code>时，是去调用<code>ClassProperty</code>类的<code>__get__</code>函数，把<code>Spam1</code>的实例<code>s1</code>传递给<code>instance</code>参数，把<code>Spam1</code>传递给<code>cls</code>参数，当执行<code>return self.fn(cls)</code>语句时其实质是执行<code>val(cls)</code>，所以是返回一个函数，此时解释器回到<code>Spam1</code>类中的<code>val</code>函数，执行<code>return cls.__val</code>，所以就输出了<code>3</code>。</p><p>执行<code>s1.name</code>语句也是类似的调用过程。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> property实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python描述器</title>
      <link href="/2016/05/09/2016-05-09-%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
      <url>/2016/05/09/2016-05-09-%E6%8F%8F%E8%BF%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之描述器</p><a id="more"></a><h2 id="描述器">描述器</h2><p>一个类实现了<code>__get__</code>、<code>__set__</code>、<code>__delete__</code>三个方法，这个类就叫描述器</p><p>直接来看一个描述器的实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __get__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __set__&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> isinstance(value,(int,float)):</span><br><span class="line">            instance.__dict__[self.name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;execepted int or float&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Number(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = Number(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><p>这样就定义了一个描述器<code>Number</code>类，这个类的作用是描述实例化<code>Point</code>类时<code>x</code>和<code>y</code>变量的类型必须为整型或浮点型，如果不满足这两种类型中的一个，那抛出TypeError的异常。为了验证代码的调用关系，有意在<code>Number</code>类中加了一些<code>print</code>语句，在实例代码中应该把这语句去除。现在来实际实例化<code>Point</code>类试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = Point(<span class="number">2</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure><pre><code>call __set__call __set__</code></pre><p>当执行<code>p1 = Point(2,8)</code>时发生了什么呢？</p><p>1.当python解释器解析到</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Number(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = Number(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><p>代码块时，解释器会创建一个<code>Point</code>类对象，此对象中有<code>x</code>类变量，且此变量指向<code>Number</code>类的一个实例，有<code>y</code>类变量，且此变量指向<code>Number</code>类的另一个实例；解释器还会创建一个<code>__init__</code>函数，此函数接收两个参数。</p><p>2.当解释器执行到<code>p1 = Point(2,8)</code>时，<code>Point</code>类中的<code>__init__</code>构建函数被执行，执行以下两代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.x = x</span><br><span class="line">self.y = y</span><br></pre></td></tr></table></figure><p>解释器先执行<code>self.x = x</code>代码，这里的<code>self.x</code>是一个变量对象，等号后边的<code>x</code>是指向类变量<code>x = Number('x')</code>中的<code>Number</code>类实例，这时解释器会执行<code>Number</code>类中的<code>__set__</code>函数，把<code>p1</code>实例传递给<code>instance</code>这个形参，把<code>2</code>传递给<code>value</code>这个形参，执行此函数体的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def __set__(self,instance,value):</span><br><span class="line">        print(&#39;call __set__&#39;)</span><br><span class="line">        if isinstance(value,(int,float)):</span><br><span class="line">            instance.__dict__[self.name] &#x3D; value</span><br><span class="line">        else:</span><br><span class="line">            raise TypeError(&#39;execepted int or float&#39;)</span><br></pre></td></tr></table></figure><p>首先打印出<code>call __set__</code>，再执行if语句，为True时把<code>p1</code>实例中<code>__dict__</code>这个特殊方法中key为<code>x</code>的值指向<code>2</code>；如果if语句的判断结果为False，那抛出异常。</p><p>接着解释器往下执行代码，开始执行构建函数中的<code>self.y = y</code>语句，这个过程与执行<code>self.x = x</code>语句一样。这样就完成了<code>p1 = Point(2,8)</code>这个语句的执行，其<strong>实质就是会去执行Number类的<code>__set__</code>函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br></pre></td></tr></table></figure><pre><code>call __get__2</code></pre><p>当执行上边的<code>p1.x</code>时发生了什么？</p><p>执行<code>p1.x</code>是去调用<code>Point</code>类的实例变量<code>x</code>，从上边的分析可知，这个实例变量是指向<code>Number('x')</code>这个实例，这时解释器会执行<code>Number</code>类的<code>__get__</code>方法，会把<code>p1</code>这个实例名作为变量传递给<code>instance</code>这个形参，把<code>p1</code>的类名作为变量传递给<code>cls</code>，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __get__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><p>先打印出<code>call __get__</code>，然后取出<code>p1</code>实例中<code>__dict__</code>中key为<code>x</code>的值返回，这样就得到执行<code>p1 = Point(2,8)</code>语句时<code>2</code>这个数字。</p><p>总结起来，访问一个使用了描述器的类的实例属性时，<strong>其实质是访问了描述器的<code>__get__</code>函数</strong>。</p><p>其实访问<code>p1.x</code>和访问<code>Point.x.__get__(p1,Point)</code>的过程是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x = <span class="number">10</span></span><br></pre></td></tr></table></figure><pre><code>call __set__</code></pre><p>当执行上边的<code>p1.x = 10</code>语句时发生了什么呢？</p><p>执行<code>p1.x = 10</code>是想把<code>Point</code>类的<code>p1</code>实例的实例变量指向一个数字<code>10</code>，实例变量<code>x</code>是指向<code>Number('x')</code>这个实例，其实质是去调用<code>Number</code>类的<code>__set__</code>方法，上边已对调用<code>__set__</code>函数进行了详细了分析，不再赘述。</p><p>其实执行<code>p1.x = 10</code>和执行<code>Point.x.__set__(p1.10)</code>的过程是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x</span><br></pre></td></tr></table></figure><pre><code>call __get__10</code></pre><p>再来给<code>x</code>一个不是<code>int</code>或<code>float</code>型的字符，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.x = <span class="string">&#x27;zhaochj&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>call __set__---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-8-47a1681546d4&gt; in &lt;module&gt;()----&gt; 1 p1.x = 'zhaochj'&lt;ipython-input-2-087bfda6d4c9&gt; in __set__(self, instance, value)     12             instance.__dict__[self.name] = value     13         else:---&gt; 14             raise TypeError('execepted int or float')     15      16     def __delete__(self,instance):TypeError: execepted int or float</code></pre><p>在类型检查时没有通过，所以抛出我们自定义的异常信息。</p><p>在<code>Point</code>类中，按理说<code>类变量x</code>是可以像<code>Point.x</code>来访问的，但执行时，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.x</span><br></pre></td></tr></table></figure><pre><code>call __get__---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-9-7a7eae6dfbec&gt; in &lt;module&gt;()----&gt; 1 Point.x&lt;ipython-input-2-087bfda6d4c9&gt; in __get__(self, instance, cls)      5     def __get__(self,instance,cls):      6         print('call __get__')----&gt; 7         return instance.__dict__[self.name]      8       9     def __set__(self,instance,value):AttributeError: 'NoneType' object has no attribute '__dict__'</code></pre><p>这是因为在调用<code>__get__</code>方法时<code>instance</code>参数接收到了一个<code>None</code>对象，这是因为类<code>Point</code>并没有被实例化，所以<code>return</code>时会报错。可以对<code>__get__</code>函数做如下修正，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberFix</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __get__&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __set__&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> isinstance(value,(int,float)):</span><br><span class="line">            instance.__dict__[self.name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;execepted int or float&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2</span>:</span></span><br><span class="line">    x = NumberFix(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = NumberFix(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__&lt;__main__.NumberFix at 0x7f8030321550&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = Point2(<span class="number">4</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><pre><code>call __set__call __set__</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__&lt;__main__.NumberFix at 0x7f8030321550&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.x = <span class="number">30</span></span><br></pre></td></tr></table></figure><pre><code>call __set__</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.x</span><br></pre></td></tr></table></figure><pre><code>call __get__30</code></pre><p>这样，<code>NumberFix</code>算是一个完整的描述器。</p><p>这样，<code>NumberFix</code>这个描述器就完成了对实例化类<code>Point2</code>时传入参数类型的限制，允许的类型在描述器<code>NumberFix</code>的<code>__set__</code>函数中进行设置。</p><p>上边的例子中都是对各个参数进行同一类型的检查，如果我们要对每个参数都做不同的类型检查呢？比如要求<code>x</code>参数为<code>int</code>型，<code>y</code>参数为<code>str</code>型。对上边的描述器做如下改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeCheck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,expected_type</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.expected_type = expected_type</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self,instance,cls</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self,instance,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value,self.expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;expected type &#123;0&#125;&#x27;</span>.format(self.expected_type))</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3</span>:</span></span><br><span class="line">    x = TypeCheck(<span class="string">&#x27;x&#x27;</span>,(int,))</span><br><span class="line">    y = TypeCheck(<span class="string">&#x27;y&#x27;</span>,(str,))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 = Point3(<span class="number">10</span>,<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.x</span><br></pre></td></tr></table></figure><pre><code>10</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.y</span><br></pre></td></tr></table></figure><pre><code>'zhaochj'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.x = <span class="number">40</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3.x</span><br></pre></td></tr></table></figure><pre><code>40</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p4 = Point3(<span class="number">10</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-67-7765c7ef841b&gt; in &lt;module&gt;()----&gt; 1 p4 = Point3(10,30)&lt;ipython-input-58-20cc1f0ef40f&gt; in __init__(self, x, y)      5     def __init__(self,x,y):      6         self.x = x----&gt; 7         self.y = y&lt;ipython-input-51-d7bab526d123&gt; in __set__(self, instance, value)     11     def __set__(self,instance,value):     12         if not isinstance(value,self.expected_type):---&gt; 13             raise TypeError('expected type &#123;0&#125;'.format(self.expected_type))     14         instance.__dict__[self.name] = value     15 TypeError: expected type (&lt;class 'str'&gt;,)</code></pre><p>这样就可以实现对不同的变量限制不同的类型，当对<code>x</code>和<code>y</code>的类型有变更时只需要修改<code>Point3</code>类即可。</p><p>其实还可以使用装饰器来达到同样的效果，这是一个装饰类<code>TypeCheck</code>的装饰器，代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeinsert</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">        @wraps(cls)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">                setattr(cls,k,TypeCheck(k,v))</span><br><span class="line">            <span class="keyword">return</span> cls</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@typeinsert(x=int,y=float,z=str,m=str)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y,z,m</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.z = z</span><br><span class="line">        self.m = m</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Spam(x=<span class="string">&#x27;dfd&#x27;</span>,y=<span class="number">10</span>,z=<span class="number">10</span>,m=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>好像没有达到预想的效果，没有想明白，相关视频在“09-面向对象-8”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 描述器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的with语法</title>
      <link href="/2016/05/09/2016-05-09-with%E8%AF%AD%E6%B3%95/"/>
      <url>/2016/05/09/2016-05-09-with%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之with语法</p><a id="more"></a><h2 id="with语句与-enter-，exit">with语句与__enter__，<strong>exit</strong></h2><p>有一些任务，可能事先需要设置，事后做清理工作。对于这种场景，Python的with语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。</p><p>如果不使用with语句，代码是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">&quot;/tmp/foo.txt&quot;</span>)</span><br><span class="line">data = file.read()</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>这里有两个问题。一是可能忘记关闭文件句柄；二是文件读取数据发生异常，没有进行任何处理。下面是处理异常的加强版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">&quot;/tmp/foo.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure><p>虽然这段代码运行良好，但是太冗长了。这时候就是with一展身手的时候了。除了有更优雅的语法，with还可以很好的处理上下文环境产生的异常。下面是with版本的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&quot;/tmp/foo.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure><p>那with语法是怎么实现的呢？下边来看一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;call __init__&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;call __enter__&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;self object at &#123;0&#125;&quot;</span>.format(self))</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;call __exit__&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Resource() <span class="keyword">as</span> res:</span><br><span class="line">    print(<span class="string">&quot;res object at &#123;0&#125;&quot;</span>.format(res))</span><br></pre></td></tr></table></figure><pre><code>call __init__call __enter__self object at &lt;__main__.Resource object at 0x7f5db448a6a0&gt;res object at &lt;__main__.Resource object at 0x7f5db448a6a0&gt;call __exit__</code></pre><p>这上边这个例子可知，只要一个类实现了<code>__enter__</code>和<code>__exit__</code>方法，那这个类就可以使用<code>with</code>语句。</p><p>with语句的调用流程大致如下：</p><ol><li><p>python解释器执行到<code>with Resource() as res:</code>语句时，其实是首先实例化了<code>Resource</code>类，接着执行了<code>__enter__</code>函数</p></li><li><p>执行<code>print(&quot;res object at &#123;0&#125;&quot;.format(res))</code>语句，这里的<code>res</code>是指向<code>Resource</code>类实例化对象，所以与<code>self</code>指向的对象相同</p></li><li><p>再执行<code>__exit__</code>函数</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> with语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的魔术方法、类装饰器、单例</title>
      <link href="/2016/05/08/2016-05-08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%8D%95%E4%BE%8B/"/>
      <url>/2016/05/08/2016-05-08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之魔术方法、类装饰器、单例</p><a id="more"></a><h2 id="魔术方法">魔术方法</h2><h3 id="对象的创建与销毁">对象的创建与销毁</h3><ul><li><code>__new__</code>创建对象</li><li><code>__init__</code>初始化对象</li><li><code>__del__</code>当销毁对象时调用</li></ul><p>以一个例子来说明上边各个魔术方法在哪时被调用，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __new__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __init__&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mothod</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call mothod&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __del__&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br></pre></td></tr></table></figure><pre><code>call __new__call __init__</code></pre><p>从上边输出可知<code>__new__</code>和<code>__init__</code>方法是在类实例化时就被执行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.mothod()   <span class="comment">#普通方法被显示调用时被执行</span></span><br></pre></td></tr></table></figure><pre><code>call mothod</code></pre><p><code>__del__</code>方法是在对象被销毁时被执行，即是垃圾回收时，这里可以用<code>del</code>来模拟垃圾回收时删除实例<code>a</code>这个对象，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure><pre><code>call __del__</code></pre><p>在实际编程中，使用最多的是<code>__init__</code>方法</p><h3 id="可视化对象">可视化对象</h3><ul><li><code>__repr__</code>   对应repr(object)这个函数，返回一个可以用来表示对象的可打印字符串</li><li><code>__str__</code>    对应str(object)这个函数，返回一个字符串对象，适合用于print输出</li><li><code>__bytes__</code>   对应bytes(object)这个函数，返回bytes对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;call __repr__ name is &#123;0&#125;&#x27;</span>.format(self.name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;call __str__ name is &#123;0&#125;&#x27;</span>.format(self.name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;call __bytes__ name is &#123;0&#125;&#x27;</span>.format(self.name).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = B(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b</span><br></pre></td></tr></table></figure><pre><code>call __repr__ name is zhaochj</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(b)</span><br></pre></td></tr></table></figure><pre><code>call __str__ name is zhaochj</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(b)</span><br></pre></td></tr></table></figure><pre><code>'call __str__ name is zhaochj'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes(b)</span><br></pre></td></tr></table></figure><pre><code>b'call __bytes__ name is zhaochj'</code></pre><h3 id="比较运算符重载">比较运算符重载</h3><ul><li><code>__lt__</code>  小于</li><li><code>__le__</code>  小于等于</li><li><code>__eq__</code>  等于</li><li><code>__ne__</code>  不等于</li><li><code>__gt__</code>  大于</li><li><code>__ge__</code>  大于等于</li></ul><p>先看下边这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,age</span>):</span></span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = Person(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2 = Person(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.age &gt; p2.age</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>上边对实例变量可以进行比较，如果想对实例对象进行比较呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 &gt; p2</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-42-64d46152e12c&gt; in &lt;module&gt;()----&gt; 1 p1 &gt; p2TypeError: unorderable types: Person() &gt; Person()</code></pre><p>抛出了<code>TypeError</code>，如果要实例能对实例对象进行比较，那要实现一些方法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __lt__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt; other.age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__le__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __le__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __eq__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age == other.age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __ne__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age != other.age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __gt__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &gt; other.age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __ge__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &gt;= other.age</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 = Person_1(<span class="string">&#x27;30&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p4 = Person_1(<span class="string">&#x27;20&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 &gt; p4</span><br></pre></td></tr></table></figure><pre><code>call __gt__True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 &lt; p4</span><br></pre></td></tr></table></figure><pre><code>call __lt__False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 == p4</span><br></pre></td></tr></table></figure><pre><code>call __eq__True</code></pre><p>如上，只要一个实例变量实现了<code>__lt__</code>这样的方法，那实例也可以进行比较。</p><h3 id="bool函数">bool函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst = []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(lst)</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(lst1)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;zhaochj&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(str1)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(str2)</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><p>从上边的输出可知，对空列表、空字符调用bool函数时返回False，对有元素的列表、字符调用bool函数时返回True。这其内部是什么原理呢？先来看一个类，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grok</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __bool__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.val</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = Grok(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(g)</span><br></pre></td></tr></table></figure><pre><code>call __bool__True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g1 = Grok(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(g1)</span><br></pre></td></tr></table></figure><pre><code>call __bool__False</code></pre><p>从上边的例子可知，在调用<code>bool(object)</code>函数时其实是调用了<code>__bool__</code>这个方法。</p><p>接下来再一个例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        self.val = args</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __len__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self.val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = Seq(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(s1)</span><br></pre></td></tr></table></figure><pre><code>call __len__3</code></pre><p>从上边的输出可知执行<code>len(s1)</code>时，实质是执行了<code>__len__</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2 = Seq()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(s2)</span><br></pre></td></tr></table></figure><pre><code>call __len__0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(s1)</span><br></pre></td></tr></table></figure><pre><code>call __len__True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(s2)</span><br></pre></td></tr></table></figure><pre><code>call __len__False</code></pre><p>从上边的输出可知，当执行<code>bool(object)</code>函数时也是调用了<code>__len__</code>函数，但是把结果进行了bool计算。如果<code>__len__</code>和<code>__bool__</code>方法同时存在类中时，当我们执行<code>bool(object)</code>时是调用哪个方法呢？做如下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        self.val = args</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __len__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self.val)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __bool__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3 = Seq_1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool(s3)</span><br></pre></td></tr></table></figure><pre><code>call __bool__True</code></pre><p>上边实例化<code>Seq_1</code>类时传递了一个空序列，但调用bool函数时返回了True，这表明，当类中实现了<code>__bool__</code>方法时会被调用，而<code>__len__</code>方法则不会被调用，如果没有<code>__bool__</code>时才调用<code>__len__</code>方法。</p><h3 id="hash-与可hash对象">hash()与可hash对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 = Hash(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(h1)</span><br></pre></td></tr></table></figure><pre><code>123</code></pre><p>从上边输出可知，执行<code>hash(object)</code>函数时，实质是调用了<code>__hash__</code>方法，如果类中不定义<code>__hash__</code>方法呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h2 = Hash_1(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(h2)</span><br></pre></td></tr></table></figure><pre><code>8795459756152</code></pre><p>依然得到了一个hash值，为什么呢？这是因为python中所有的类都继承了object基类，object类已实现了<code>__hash__</code>方法，可以用<code>dir(object)</code>查看object这个类的属性。</p><h3 id="可调用对象">可调用对象</h3><p>在python中可以用<code>callable</code>函数查看一个对象是不是可调用，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(fn)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>输出为True，函数当然是一个可调用对象，如果是一个类呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = Fun(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(f)</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><p>如上，一个类被实例化后，这个实例对象是一个不可调用对象。</p><p>有什么方法能让一个实例对象变成可调用对象呢？做如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fun_1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;my name is &#123;0&#125;&#x27;</span>.format(self.name))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1 = Fun_1(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(f1)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>cool，<code>f1</code>这个实例现在已是一个可调用对象了。所以只要一个类中实现了<code>__call__</code>方法，那么类实例就是一个可调用对象。调用此对象试试，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1()</span><br></pre></td></tr></table></figure><pre><code>my name is zhaochj</code></pre><p>如上，事实证明，调用此实例对象也就是执行了<code>__call__</code>方法。既然是可调用对象，就可以向调用函数一样传递参数来调用，只要在<code>__call__</code>方法中定义可接收参数即可。</p><p>类通过实现<code>__call__</code>方法可以让实例变成一个可调用对象，如果我们向这个可调用对象传递一个函数作为其参数，那<code>__call__</code>函数就可以写成一个装饰器，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjectUser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,default_user</span>):</span></span><br><span class="line">        self.user = default_user</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,fn</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(fn)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;user&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs.keys():</span><br><span class="line">                kwargs[<span class="string">&#x27;user&#x27;</span>] = self.user</span><br><span class="line">            <span class="keyword">return</span> fn(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectUser(&#x27;zhaochj&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_somthings</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">    print(kwargs.get(<span class="string">&#x27;user&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_somthings()</span><br></pre></td></tr></table></figure><pre><code>zhaochj</code></pre><p>分析一下上边的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def __call__(self,fn):</span><br><span class="line">        @functools.wraps(fn)</span><br><span class="line">        def wrap(*args,**kwargs):</span><br><span class="line">            if &#39;user&#39; not in kwargs.keys():</span><br><span class="line">                kwargs[&#39;user&#39;] &#x3D; self.user</span><br><span class="line">            return fn(*args,**kwargs)</span><br><span class="line">        return wrap</span><br></pre></td></tr></table></figure><p>上边的代码是定义一个装饰器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@InjectUser(&#39;zhaochj&#39;)</span><br><span class="line">def do_somthings(*args,**kwargs):</span><br><span class="line">    print(kwargs.get(&#39;user&#39;))</span><br></pre></td></tr></table></figure><p>这里的魔法等价执行了<code>InjectUser('zhaochj')(do_somthings)</code>，实质是返回装饰器的wrap函数。执行<code>do_somthings()</code>时，实质是执行了<code>wrap()</code>，并返回<code>fn(*args,**kwargs)</code>，到这里才真正执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def do_somthings(*args,**kwargs):</span><br><span class="line">    print(kwargs.get(&#39;user&#39;))</span><br></pre></td></tr></table></figure><p>函数中的print语句。</p><ul><li>利用<code>__call__</code>方法实现单例</li></ul><p>所谓单例，是指一个类的实例从始至终只能被创建一次。单例的实现有多种，这里以<code>__call__</code>方法来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,cls</span>):</span></span><br><span class="line">        self.cls = cls</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = self.cls(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.__instance</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Single</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grok1</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok1 = Grok1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(grok1)</span><br></pre></td></tr></table></figure><pre><code>140271956645592</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok2 = Grok1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(grok2)</span><br></pre></td></tr></table></figure><pre><code>140271956645592</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(grok1) == id(grok2)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>现在来分析一下上边的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Single</span><br><span class="line">class Grok1:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">grok1 &#x3D; Grok1()</span><br></pre></td></tr></table></figure><p>实例化<code>Grok1</code>类时相当于执行了下边两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Grok1 &#x3D; Single(Grok1)</span><br><span class="line">2. grok1 &#x3D; Grok1()</span><br></pre></td></tr></table></figure><p>第一步：执行<code>Single(Grok1)</code>是返回一个<code>Single</code>类的实例，并用一个变量Grok1指向这个实例对象，此时的Grok1不是<code>class Grok1:</code>里的Grok1类，只是名字相同而已，<code>Single</code>类实例化时<code>__init__</code>构建函数被调用，这里会把<code>self.cls</code>这个实例属性指向<code>Grok1</code>类。</p><p>第二步：因<code>Single</code>类实现了<code>__call__</code>方法，所以此实例是一个可调用对象，这里执行<code>grok1 = Grok1()</code>，其中的<code>Grok1</code>已不再是<code>class Grok1:</code>里的类，而是<code>Single</code>类的实例对象，这里调用实例对象就会执行<code>__call__</code>方法，对此方法中的代码做进一步分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def __call__(self,*args,**kwargs):</span><br><span class="line">        if self.__instance is None:</span><br><span class="line">            self.__instance &#x3D; self.cls(*args,**kwargs)</span><br><span class="line">        return self.__instance</span><br></pre></td></tr></table></figure><p>当第一次调用时，if语句的结果为True，此时会执行<code>self.__instance = self.cls(*args,**kwargs)</code>，其中的<code>self.cls</code>指向<code>Grok1</code>类，即这里表示实例化<code>Grok1</code>类，并把<code>self.__instance</code>指向实例化<code>Grok1</code>类的对象，这样<code>__instance</code>就不再是<code>None</code>了，当第二次调用<code>__call__</code>函数时，if语句的结果为False，所以直接执行<code>return self.__instance</code>，所以<code>Grok1</code>这个对象在被多次实例化后指向的实例化对象都是一样的，其实是只被实例化了一次而已。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔术方法，类装饰器，单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python反射</title>
      <link href="/2016/05/08/2016-05-08-%E5%8F%8D%E5%B0%84/"/>
      <url>/2016/05/08/2016-05-08-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之反射</p><a id="more"></a><h2 id="反射">反射</h2><p>什么叫反射？</p><p>给定一个对象，返回该对象的所有属性和函数列表，或给定对象和该对象的函数或者属性的名字，返回对象的函数或者属性实例。</p><p>dir函数就是反射的实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(int)</span><br></pre></td></tr></table></figure><pre><code>['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']</code></pre><p>给定<code>int</code>对象，返回了此对象的所有属性和函数列表。</p><p>再来看一个特殊方法<code>__dict__</code>，先定义一个类，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grok</span>:</span></span><br><span class="line">    X = <span class="number">1</span></span><br><span class="line">    Y = <span class="number">2</span></span><br><span class="line">    Z = <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y,z</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.z = z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call method&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">grok = Grok(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok.__dict__</span><br></pre></td></tr></table></figure><pre><code>&#123;'x': 1, 'y': 2, 'z': 3&#125;</code></pre><p>类所有的实例属性都能通过<code>__dict__</code>输出，这种对定了一个实例对象，返回了该实例对象的属性，这也是反射的体现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok.__class__</span><br></pre></td></tr></table></figure><pre><code>__main__.Grok</code></pre><p>通过<code>__class__</code>能够返回一个实例对象是由哪个类产生的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok.__dir__()   <span class="comment">#这也是反射的体现</span></span><br></pre></td></tr></table></figure><pre><code>['__sizeof__', '__ne__', '__repr__', '__class__', 'method', '__new__', '__eq__', '__init__', 'x', '__weakref__', '__format__', '__gt__', '__lt__', 'Y', 'Z', '__subclasshook__', 'z', 'X', '__delattr__', '__reduce__', '__getattribute__', '__dict__', '__doc__', '__module__', '__dir__', '__hash__', '__reduce_ex__', '__le__', '__str__', '__ge__', '__setattr__', 'y']</code></pre><ul><li>getattr</li></ul><p>getattr用于返回一个对象属性，或者方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok,<span class="string">&#x27;X&#x27;</span>)   <span class="comment">#返回grok实例的类的X变量的值</span></span><br></pre></td></tr></table></figure><pre><code>1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok,<span class="string">&#x27;method&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;bound method Grok.method of &lt;__main__.Grok object at 0x7f570c405358&gt;&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok.method</span><br></pre></td></tr></table></figure><pre><code>&lt;bound method Grok.method of &lt;__main__.Grok object at 0x7f570c405358&gt;&gt;</code></pre><p>上边两种调用都是返回method函数对象，也可以直接调用，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok,<span class="string">&#x27;method&#x27;</span>)()</span><br></pre></td></tr></table></figure><pre><code>call method</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok.method()</span><br></pre></td></tr></table></figure><pre><code>call method</code></pre><ul><li>setattr</li></ul><p>设置一个对象的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setattr(grok,<span class="string">&#x27;a&#x27;</span>,<span class="number">123</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>123</code></pre><ul><li>delattr</li></ul><p>删除一个对象的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delattr(grok,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok,<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-42-6ec68937908b&gt; in &lt;module&gt;()----&gt; 1 getattr(grok,'a')AttributeError: 'Grok' object has no attribute 'a'</code></pre><ul><li><code>__getattr__</code> <code>__setattr__</code> <code>__delattr__</code></li></ul><p>上边的<code>getattr</code>，<code>setattr</code>，<code>delattr</code>三个函数是分别对应<code>__getattr__</code>，<code>__setattr__</code>，<code>__delattr__</code>这三个特殊方法。</p><p>先来看一个例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grok1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__dict = &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __getattr__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__dict.get(name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok1 = Grok1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok1.x</span><br></pre></td></tr></table></figure><pre><code>call __getattr__1</code></pre><p>从上边的例子可知，当访问实例对象的一个属性时，这里直接调用了<code>__getattr__</code>方法，如果此属性在构建函数中存在呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grok2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__dict = &#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">        self.x = <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __getattr__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.__dict.get(name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok2 = Grok2()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok2.x</span><br></pre></td></tr></table></figure><pre><code>10</code></pre><p>当访问实例对象的属性时，此属性在构建函数时已定义，那直接返回，如果没有，则去<code>__getattr__</code>查找，如果这个函数中也没有，查找才结束。</p><p>再来看一个<code>getattr</code>的使用例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grok3</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call method_a&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_b</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call method_b&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_default</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call method_default&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.method_default</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok3 = Grok3()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok3,<span class="string">&#x27;method_a&#x27;</span>)()</span><br></pre></td></tr></table></figure><pre><code>call method_a</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok3,<span class="string">&#x27;method_b&#x27;</span>)()</span><br></pre></td></tr></table></figure><pre><code>call method_b</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(grok3,<span class="string">&#x27;method_c&#x27;</span>)()</span><br></pre></td></tr></table></figure><pre><code>call method_default</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grok3.method_c()</span><br></pre></td></tr></table></figure><pre><code>call method_default</code></pre><p>上边这个例子说明当我们调用一个不存在的方法时，比如这里的<code>method_c</code>，如果类中定义了<code>__getattr__</code>方法，那么会去调用此函数定义的操作，这就在python中实现了一个默认操作，避免当用户调用一个不存在的方法或属性时解释器会抛出错误，而<code>__getattr__</code>函数后，可以给用户一些提示信息。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象的多继承-MIXIN</title>
      <link href="/2016/05/07/2016-05-07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E7%BB%A7%E6%89%BF-MRO-MIXIN/"/>
      <url>/2016/05/07/2016-05-07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E7%BB%A7%E6%89%BF-MRO-MIXIN/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之多继承，MRO算法及MIXIN</p><a id="more"></a><h2 id="多继承">多继承</h2><p>先来看一个多继承的例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_from_a</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;method of a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_from_b</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;method of b&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = C()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.method_from_a()</span><br></pre></td></tr></table></figure><pre><code>method of a</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.method_from_b()</span><br></pre></td></tr></table></figure><pre><code>method of b</code></pre><p>通过上边的代码可知，python是支持多继承的，父类的方法都能继承到子类，如果父类的方法名是相同时，子类调用这个方法时到底是继承哪个父类的方法呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;method of a1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;method of b1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>(<span class="params">A1,B1</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 = C1()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1.method()</span><br></pre></td></tr></table></figure><pre><code>method of a1</code></pre><p>从上边的输出结果来看，子类C1是继承了A1类中的method方法。如果在定义C1类时，把继承的A1和B1两个类的顺序调换后呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>(<span class="params">B1,A1</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2 = C2()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2.method()</span><br></pre></td></tr></table></figure><pre><code>method of b1</code></pre><p>这样就是继承了B1类中的method方法了。</p><p>通过上边的测试，能不能说明在多继承时，子类继承方法总是在定义子类时写在前一个父类中的方法呢？答案是，这样说是不准确的。再看以下的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;method of a2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>(<span class="params">A2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;method of b2&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span>(<span class="params">A2,B2</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-16-5035382970b1&gt; in &lt;module&gt;()----&gt; 1 class C3(A2,B2):      2     passTypeError: Cannot create a consistent method resolutionorder (MRO) for bases A2, B2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span>(<span class="params">B2,A2</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 = C3()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3.method()</span><br></pre></td></tr></table></figure><pre><code>method of b2</code></pre><p>上边代码中，B2类继承了A2类，B2类中也有一个method方法，当定义C3类时，让其继承(A2,B2)时，直接抛出了异常，但让其继承(B2，A2)时又能正常工作，所以在多继承中，子类继承的方法并不总是继承父类列表(如(A2,B2))左边父类的方法。这又是为什么呢？</p><p>这里是存在一个算法存在的，叫MRO算法，全称：method resolution order（方法解析顺序）</p><h3 id="MRO">MRO</h3><p>MRO 是通过C3算法计算出来的</p><p>MRO遵循以下规则：</p><ol><li><p>本地优先级： 根据声明顺序从左往右查找</p></li><li><p>单调性： 所有子类中，也应满足其查找顺序</p></li></ol><p>MRO中采用了C3 算法，而C3算法中重点是一个merge函数，那先来看一个执行merge时步骤：</p><ol><li><p>顺序遍历列表</p></li><li><p>查找首元素满足以下条件，否则遍历下一个序列</p></li></ol><ul><li>在其他序列也是首元素</li><li>或者在其他序列里不存在</li></ul><ol start="3"><li><p>从所有序列中移除此元素，合并到MRO序列中</p></li><li><p>重复执行，直到所有序列为空或无法执行下去</p></li></ol><p>以例子来说明一下C3算法是怎样工作的，比如有一个B类，默认是继承object这个父类的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class B(object): --&gt; mro(B) &#x3D; [B,O]</span><br><span class="line"> </span><br><span class="line">[B,O]中的字母O表示的就是object</span><br></pre></td></tr></table></figure><p>如果B类继承了A1这个类呢，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class B(A1):   --&gt; mro(B) &#x3D; [B] + merge(mro(A1),[A1])</span><br></pre></td></tr></table></figure><p>如果B类继承了A1，A2类呢，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class B(A1,A2):  --&gt; mro(B) &#x3D; [B] + merge(mro(A1),mro(A2),[A1,A2])</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class B(A1,A2,...) --&gt; mro(B) &#x3D; [B] + merge(mro(A1),mro(A2),...,[A1,A2,...])</span><br></pre></td></tr></table></figure><p>以上边定义<code>class C1(A1,B1):</code>这个类来说明一下为什么执行<code>c1.method()</code>时输出的是&quot;method of a1&quot;，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A1:</span><br><span class="line">class B1:</span><br><span class="line">class C1(A1,B1):</span><br><span class="line">mro(C1) &#x3D; [C1] + merge(mro(A1),mro(B1),[A1,B1])</span><br><span class="line">      &#x3D; [C1] + merge([A1,O],[B1,O],[A1,B1])</span><br><span class="line">      &#x3D; [C1,A1] + merge([O],[B1,O],[B1])</span><br><span class="line">      &#x3D; [C1,A1,B1] + merge([O],[O])</span><br><span class="line">      &#x3D; [C1,A1,B1,O]</span><br></pre></td></tr></table></figure><p>通过C3算法最后得到了<code>[C1,A1,B1,O]</code>这样一个序列，这个序列表示<code>C1(A1,B1):</code>这个类被实例化后，当调用父类中同名方法时的查找顺序，比如调用<code>c1.method()</code>方法时，解释器先会在&quot;C1&quot;类中查找是否有这个方法，如果没有再去&quot;A1&quot;类中查找，如果没有再去&quot;B1&quot;类中查找，如果还是没有则去&quot;object&quot;这个类中查找，只要有一个类中查找到了该方法，则会执行。</p><p>再来看一下<code>C1(B1,A1):</code>这个类的查找顺序，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A1:</span><br><span class="line">class B1:</span><br><span class="line">class C1(B1,A1):</span><br><span class="line">mro(C1) &#x3D; [C1] + merge(mro(B1),mro(A1),[B1,A1])</span><br><span class="line">      &#x3D; [C1] + merge([B1,O],[A1,O],[B1,A1])</span><br><span class="line">      &#x3D; [C1,B1] + merge([O],[A1,O],[A1])</span><br><span class="line">      &#x3D; [C1,B1,A1] + merge([O],[O])</span><br><span class="line">      &#x3D; [C1,B1,A1,O]</span><br></pre></td></tr></table></figure><p>最后得到的<code>[C1,B1,A1,O]</code>序列的查找顺序也符合之前的调用结果。</p><p>接下来看一个略复杂一点的例子，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A2:</span><br><span class="line">class B2(A2):</span><br><span class="line">class C3(A2,B2):</span><br><span class="line">mro(C3) &#x3D; [C3] + merge(mro(A2),mro(B2),[A2,B2])</span><br><span class="line">      &#x3D; [C3] + merge([A2,O],([B2] + merge(mro(A2),[A2]),[A2,B2])</span><br><span class="line">      &#x3D; [C3] + merge([A2,O],([B2] + merge([A2,O],[A2])),[A2,B2])</span><br><span class="line">      &#x3D; [C3] + merge([A2,O],([B2,A2] + merge([O])),[A2,B2])</span><br><span class="line">      &#x3D; [C3] + merge([A2,O],[B2,A2,O],[A2,B2])</span><br><span class="line">      计算到这里没有任何一个元素符合mro的计算规则，所以就抛出“TypeError”</span><br></pre></td></tr></table></figure><p>那来看一下<code>class C3(B2,A2):</code>呢？如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A2:</span><br><span class="line">class B2(A2):</span><br><span class="line">class C3(B2,A2):</span><br><span class="line">mro(C3) &#x3D; [C3] + merge(mro(B2),mro(A2),[B2,A2])</span><br><span class="line">      &#x3D; [C3] + merge(([B2] + merge(mro(A2),[A2])),[A2,O],[B2,A2])</span><br><span class="line">      &#x3D; [C3] + merge(([B2] + merge([A2,O],[A2])),[A2,O],[B2,A2])</span><br><span class="line">      &#x3D; [C3] + merge(([B2,A2] + merge([O])),[A2,O],[B2,A2])</span><br><span class="line">      &#x3D; [C3] + merge([B2,A2,O],[A2,O],[B2,A2])</span><br><span class="line">      &#x3D; [C3,B2] + merge([A2,O],[A2,O],[A2])</span><br><span class="line">      &#x3D; [C3,B2,A2] + merge([O],[O])</span><br><span class="line">      &#x3D; [C3,B2,A2,O]</span><br></pre></td></tr></table></figure><p>得出的结果<code>[C3,B2,A2,O]</code>也正是方法的查找顺序，这也验证了前边在执行<code>c3.method()</code>时执行了父类&quot;B2&quot;中的<code>method</code>方法。</p><p>其实在一个类中有一个<code>__mro__</code>属性，可显示出查找顺序，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C3.__mro__</span><br></pre></td></tr></table></figure><pre><code>(__main__.C3, __main__.B2, __main__.A2, object)</code></pre><h3 id="MIXIN-混入">MIXIN - 混入</h3><p>MIXIN是一种组合的表现，在python是通过多继承来实现组合。</p><p>试想有这样一个场景，我们有一个文档类，文档分为word文档和excel文档，这些文档可以输出到显示器上，也可以输出到打印机上，我们用MIXIN的方式来实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,content</span>):</span></span><br><span class="line">        self.content = content</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>(<span class="params">Document</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.content = <span class="string">&#x27;i am word,my content is &#123;0&#125;&#x27;</span>.format(self.content)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Excel</span>(<span class="params">Document</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.content = <span class="string">&#x27;i am excel,my content is &#123;0&#125;&#x27;</span>.format(self.content)</span><br></pre></td></tr></table></figure><p>上边定义了三个类，<code>Document</code>类作为<code>Word</code>和<code>Excel</code>类的父类，两个子类分别实现了各自的format方法。这两种文档能输出到打印机和显示器上，所以接下来定义这两个类，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;0&#125; on monitor&#x27;</span>.format(self.content))</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;0&#125; on printer&#x27;</span>.format(self.content))</span><br></pre></td></tr></table></figure><p><code>Monitor</code>和<code>Printer</code>类只继承object类，各自实现了输出功能。如果此时我们想把word文档输出到显示器上、word文档输出到打印机上，或者是想把excel文档输出到显示器、excel文档输出到打印机上，应该怎样实现呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordWithMonitor</span>(<span class="params">Monitor,Word</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelWithMonitor</span>(<span class="params">Monitor,Excel</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordWithPrinter</span>(<span class="params">Printer,Word</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcelWithPrinter</span>(<span class="params">Printer,Excel</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwm = WordWithMonitor(<span class="string">&#x27;mix in&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwm.format()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwm.display()</span><br></pre></td></tr></table></figure><pre><code>i am word,my content is mix in on monitor</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwp = WordWithPrinter(<span class="string">&#x27;mix in&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwp.format()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wwp.display()</span><br></pre></td></tr></table></figure><pre><code>i am word,my content is mix in on printer</code></pre><p><code>ExcelWithMonitor</code>类和<code>ExcelWithPrinter</code>类实例化出来后效果和上边一样，这样通过继承不同的类组合就可以满足不同的要求，上边的<code>Monitor</code>类和<code>Printer</code>类我们叫做MINXIN类，这种类有以下特征：</p><ol><li><p>此类一般只包含方法，不包含数据</p></li><li><p>此类不能单独实例化，比如上边的<code>Monitor</code>类和<code>Printer</code>，类中没有<code>content</code>这个变量，所以不能单独实例化</p></li><li><p>此类一般只继承object类，或继承具有MIXIN类特性的类</p></li></ol><p>在使用MINXIN这种方式时，一般会把MIXIN类写在继承列表的首位，如<code>class WordWithMonitor(Monitor,Word):</code>，这样能避免因其他类的同名方法覆盖MIXIN类的方法，可以通过<code>__mro__</code>属性来看一下类继承后的查找顺序，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WordWithMonitor.__mro__</span><br></pre></td></tr></table></figure><pre><code>(__main__.WordWithMonitor, __main__.Monitor, __main__.Word, __main__.Document, object)</code></pre><p>当调用<code>wwm.display()</code>时，解释器会按<code>WordWithMonitor</code>类、<code>Monitor</code>类、<code>Word</code>类、<code>Document</code>类这样的顺序查找是否有<code>display</code>方法，如果在定义<code>WordWithMonitor</code>类时继承列表中MIXIN类不在首位，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordWithMonitor</span>(<span class="params">Word,Monitor</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那mro的查找顺序是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WordWithMonitor.__mro__</span><br></pre></td></tr></table></figure><pre><code>(__main__.WordWithMonitor, __main__.Word, __main__.Document, __main__.Monitor, object)</code></pre><p>如果此时在<code>Word</code>类或<code>Document</code>类中也有一个<code>display</code>方法，那<code>Monitor</code>类中的<code>display</code>方法就不能执行，所以说MIXIN类应定义在继承列表的首位。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多继承，MRO </tag>
            
            <tag> MIXIN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象的继承</title>
      <link href="/2016/05/07/2016-05-07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/"/>
      <url>/2016/05/07/2016-05-07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之继承</p><a id="more"></a><h2 id="继承">继承</h2><p>先来看一个例子，以门这个类为例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,status</span>):</span></span><br><span class="line">        self.number = number</span><br><span class="line">        self.status = status</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.status = <span class="string">&#x27;opening&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.status = <span class="string">&#x27;closed&#x27;</span></span><br></pre></td></tr></table></figure><p>上边这个“Door”类实现了两个方法，一是<code>open</code>，表示把门打开，另一是<code>close</code>，表示把门关闭。如果想对门加把锁，门是锁着的就打不开门，锁是打开状态时才能打开门，这时我们可以重新实现这个类，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockableDoor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,status,is_lock</span>):</span></span><br><span class="line">        self.number = number</span><br><span class="line">        self.status = status</span><br><span class="line">        self.is_lock = is_lock</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_lock:</span><br><span class="line">            self.status = <span class="string">&#x27;opening&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;is locked&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.status = <span class="string">&#x27;closed&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.status == <span class="string">&#x27;closed&#x27;</span>:</span><br><span class="line">            self.is_lock = <span class="string">&#x27;True&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;is opening&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上边的<code>LockableDoor</code>类实现了我们所需要的功能，它是完全舍弃了<code>Door</code>类而重新实现的类，有没有方法在不舍弃<code>Door</code>类的情况下实现我们所需要的功能呢？类的继承特性就可以实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockableDoor_1</span>(<span class="params">Door</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,status,is_lock</span>):</span></span><br><span class="line">        super(LockableDoor_1,self).__init__(number,status)</span><br><span class="line">        self.is_lock = is_lock</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_lock:</span><br><span class="line">            super(LockableDoor_1,self).open()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;is locked&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.status == <span class="string">&#x27;closed&#x27;</span>:</span><br><span class="line">            self.is_lock = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;is opening&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在分析上边代码前先来理清几点：</p><p>没有加锁的门(Door类)有以下方法：</p><ol><li><p>打开门(open)，直接把状态(status)设置为成打开状态(opening)</p></li><li><p>关闭门(close)，直接把状态(status)设置成关闭状态(closed)</p></li></ol><p>一个有锁的门(LockableDoor_1)有以下方法：</p><ol><li><p>打开门(open)，先要看下门是否被锁住了，如果没有锁住才能把状态(status)设置成打开状态(oipening)，否则就提示门是被锁住的，无法打开等信息，而一个<code>没有上锁</code>的门和一个<code>没有锁</code>的门对打开门这个动作都是相同的，所在这里可以用超类的的open方法</p></li><li><p>关闭门(close)，一个没锁的门要想关闭门把状态(status)设置成关闭状态(closed)，那对一个有锁的门呢？也是一样，不管门是否上锁，我们只需把门状态(status)设置成关闭状态(closed)，所以对关闭门来说与<code>Door类</code>中的<code>close</code>方法并没有差异</p></li><li><p>上锁(lock)，一个有锁的门会有加不加锁这个动作</p></li></ol><p>通过上边的分析可知：</p><p>在不完全舍弃<code>Door类</code>的情况下实现一个有锁的门这个类，那需要在<code>Door类</code>的基础上<code>重新实现</code>一个<code>open</code>方法，即<code>重写open方法</code>，并增加一个<code>lock</code>方法，而<code>close</code>方法完全可以利用<code>Door类</code>中的。</p><p>现在来分析一下<code>LockableDoor_1</code>这个类中的代码：</p><ol><li><p>第一行<code>class LockableDoor_1(Door):</code>表示<code>LockableDoor_1</code>类继承<code>Door</code>类，<code>Door</code>是<code>LockableDoor_1</code>的超类，也叫父类或基类</p></li><li><p>第二至四行是重写了构造方法，因为增加了<code>is_lock</code>实例属性，其中<code>super(LockableDoor_1,self).__init__(number,status)</code>是表示用supper函数调用了超类的<code>__init__</code>方法，即在<code>LockableDoor_1</code>类中实例化了超类(Door)</p></li><li><p>第六到十行是重写了open方法，其中<code>super(LockableDoor_1,self).open()</code>表示调用父类的open方法</p></li><li><p>针对超类的close方法不用重写，直接继承即可</p></li></ol><h3 id="继承与可见性">继承与可见性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    public_class_var = <span class="string">&#x27;public class var&#x27;</span></span><br><span class="line">    __private_class_var = <span class="string">&#x27;private class var&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.public_instance_var = <span class="string">&#x27;public instance var&#x27;</span></span><br><span class="line">        self.__private_instance_var = <span class="string">&#x27;private instance var&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_instance_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.public_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.__private_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.public_instance_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.__private_instance_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_instance_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.public_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.__private_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.public_instance_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.__private_instance_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_class_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.public_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.__private_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_class_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.public_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(self.__private_class_var)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = B()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(b)</span><br></pre></td></tr></table></figure><pre><code>['_A__private_class_method', '_A__private_class_var', '_A__private_instance_method', '_A__private_instance_var', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'public_class_method', 'public_class_var', 'public_instance_method', 'public_instance_var']</code></pre><p>从<code>dir(b)</code>输出的列表的最后四个元素可总结如下规则：</p><ol><li>子类可继承超类的<code>公有方法</code>，包括公有类方法和公有实例方法；子类可继承超类的<code>公有变量</code>，包括公有类变量和公有实例变量</li></ol><p>可概括如下：</p><ul><li><p>公有方法和变量(类和实例)是可继承的</p></li><li><p>私有方法和变量(类和实例)是不可继承的</p></li></ul><p>来调用验证一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.public_class_method() <span class="comment">#公有类方法可访问公有和私有的类变量</span></span><br></pre></td></tr></table></figure><pre><code>public class varprivate class var</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.public_class_var</span><br></pre></td></tr></table></figure><pre><code>'public class var'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.public_instance_method() <span class="comment">#公有的实例方法可访问公有和私有类变量，也能访问公有和私有实例变量</span></span><br></pre></td></tr></table></figure><pre><code>public class varprivate class varpublic instance varprivate instance var</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.public_instance_var</span><br></pre></td></tr></table></figure><pre><code>'public instance var'</code></pre><p>如果在子类中把类变量和实例变量重写后，那子类访问到的变量是自己的，还是父类的呢？做如下验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    public_class_var = <span class="string">&#x27;child public class var&#x27;</span></span><br><span class="line">    __private_class_var = <span class="string">&#x27;child private class var&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super(C,self).__init__()</span><br><span class="line">        self.public_instance_var = <span class="string">&#x27;child public instance var&#x27;</span></span><br><span class="line">        self.__private_instance_var = <span class="string">&#x27;child private instance var&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = C()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.public_instance_method()</span><br></pre></td></tr></table></figure><pre><code>child public class varprivate class varchild public instance varprivate instance var</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.public_class_method()</span><br></pre></td></tr></table></figure><pre><code>child public class varprivate class var</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.public_class_var</span><br></pre></td></tr></table></figure><pre><code>'child public class var'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.public_instance_var</span><br></pre></td></tr></table></figure><pre><code>'child public instance var'</code></pre><p>经过上边的验证可得到如下结论：</p><ol><li><p>父类的公有方法(类和实例)访问父类的私有变量，即使在子类中私有变量被重写了</p></li><li><p>子类中对公有变量重写后，父类的公有方法(类和实例)访问的是子类的公有变量</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象-封装</title>
      <link href="/2016/05/06/2016-05-06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85-property/"/>
      <url>/2016/05/06/2016-05-06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85-property/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之面向对象-封装</p><a id="more"></a><h2 id="property">@property</h2><p>先来看一个例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__val = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_val</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        self.__val = x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.get_val()</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.set_val(<span class="number">200</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.get_val()</span><br></pre></td></tr></table></figure><pre><code>200</code></pre><p>上边的这个类A，实现了通过调用<code>get_val</code>方法可获取类私有变量<code>__val</code>的值，通过<code>set_val</code>方法可以修改<code>__val</code>变量的值，但对所修改的值没有限定范围，如果需要对赋值限定一个范围，那该怎么办呢？ 改进上边的类，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__val = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__val &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_val</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x,(int,float)) <span class="keyword">and</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__val = x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__val = <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = B()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.get_val()</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.set_val(<span class="number">200</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.get_val()</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.set_val(<span class="number">80</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.get_val()</span><br></pre></td></tr></table></figure><pre><code>80</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.set_val(<span class="number">-50</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.get_val()</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><p>上边的类B中<code>set_val</code>方法加了判断条件，只允许设置0～100的数，这样就不能随心所欲的设置<code>__val</code>的值了，但如<code>b.set_val(80)</code>这样的调用略显复杂，能不能像访问类属性一样来访问这里的方法？ propery这个装饰器就能实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__val = <span class="number">0</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__val &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @val.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">val</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x,(int,float)) <span class="keyword">and</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__val = x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__val = <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = C()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.val</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.val = <span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.val</span><br></pre></td></tr></table></figure><pre><code>20</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.val = <span class="number">-30</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.val</span><br></pre></td></tr></table></figure><pre><code>0</code></pre><p>如上，现在想设置<code>__val</code>的值可直接像调用类属性的方式，比较简洁。</p><p>在使用<code>property</code>装饰器时，<code>@property</code>本身又会创建另一个装饰器，在这里就是<code>@val.setter</code>，其内部的原理不是太清楚，目前只要记住它的用法即可。</p><p>总结一下：</p><p>使用<code>@property</code>装饰的函数时，目的是想获取一个值，而使用<code>@val.setter</code>装饰器时是重新设置一个值，这里的<code>val</code>是被<code>@property</code>装饰函数的名称，两个装饰器装饰的函数名称必须要相同。使用<code>@property</code>装饰器能让调用更简洁。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象，封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象基础理论</title>
      <link href="/2016/05/06/2016-05-06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80-%E5%B0%81%E8%A3%85/"/>
      <url>/2016/05/06/2016-05-06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80-%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之面向对象理论基础</p><a id="more"></a><h2 id="面向对象基础理论">面向对象基础理论</h2><h3 id="基本哲学">基本哲学</h3><ol><li><p>世界是由对象组成的</p></li><li><p>对象具有运动规律和内部状态</p></li><li><p>对象之间的相互作用和通讯构成世界</p></li></ol><h3 id="对象的特性">对象的特性</h3><ol><li><p>唯一性：世界上没有完相同的树叶，对象都有唯一块内存地址</p></li><li><p>分类性：分类是对现实世界的抽象</p></li></ol><h3 id="OOP的三大特征">OOP的三大特征</h3><ol><li><p>继承</p></li><li><p>多态，相同的操作在不同的对象上得到的结果是不一样的</p></li><li><p>封装</p></li></ol><h3 id="面向对象的本质">面向对象的本质</h3><ol><li><p>面向对象是对数据和行为的封装</p></li><li><p>但是有时候，数据仅仅是数据，方法仅仅是方法</p></li></ol><h3 id="数据和行为的封装">数据和行为的封装</h3><p>以“门”这个对象来举例，门有门牌号，有开着的状态，有关闭的状态，让可以有打开的行为，也有关闭的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">door</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,status</span>):</span></span><br><span class="line">        self.number = number</span><br><span class="line">        self.status = status</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.status = <span class="string">&#x27;opening&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.status = <span class="string">&#x27;closed&#x27;</span></span><br></pre></td></tr></table></figure><p>上边就以面向对象的方式定义了“门”这个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">door1 = door(<span class="number">1002</span>,<span class="string">&#x27;closed&#x27;</span>)   <span class="comment">#实例化一个门</span></span><br></pre></td></tr></table></figure><p><code>class</code>是定义一个类的关键字，其语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ClassName(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>因为在python中所有的类都继承自<code>object</code>类。</p><p>在类中用<code>def</code>关键字定义的函数叫做类的方法，所一般函数不同的是，类中方法的第一个参数必须的是<code>self</code></p><p>类只是一个抽象的概念，类不能直接调用，只有初始化后才能对类中的方法进行操作。形象点说类就相当于建造房屋的蓝图，实例化就是修造了一个实实在在的房屋，这个房屋有几间房，各个房间的功用不同，这些就是实例可访问操作的属性或方法。</p><h3 id="构造方法">构造方法</h3><p>python中构造函数名称为<code>__init__</code>，以一个例子说明，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        self.x = x</span><br></pre></td></tr></table></figure><p>上边定义了一个类A，类中只有一个构造方法，接下实例化此类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = A(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x</span><br></pre></td></tr></table></figure><pre><code>5</code></pre><p>如上，用“类名.变量名”的方式可以访问类中的变量。当一个类实例化时会运行<code>__init__</code>这个构造函数，<code>self</code>表示类实例化后的实例本身，<code>self.x = x</code>表示把<code>x</code>这个变量绑定在实例上，并把这个变量指向实例化时传递进来的<code>5</code>这个对象，这种通过构造函数初始化出来的变量叫做<code>实例变量</code>。</p><p>既然<code>self</code>表示实例本身，那类没有实例化前，<code>self</code>从何而来？其实质是在在类中还有一个<code>__new__</code>方法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __new__&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;cls type is &#123;0&#125;&#x27;</span>.format(type(cls)))</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call __init__&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;self type is &#123;0&#125;&#x27;</span>.format(type(self)))</span><br><span class="line">        self.x = x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><pre><code>call __new__cls type is &lt;class 'type'&gt;call __init__self type is &lt;class '__main__.B'&gt;</code></pre><p>从上边的输出可看出，在实例化<code>class B</code>时，首先调用了<code>__new__</code>函数，再调用了<code>__init__</code>这个构造方法，<code>__new__</code>函数实质是产生了一个实例对象，所以在<code>__init__</code>函数时可以用<code>self</code>来代表实例本身。<code>__new__</code>函数中的<code>cls</code>代表类本身，当解释器执行到<code>class B:</code>语句时，类就已经产生了，所以在<code>__new__</code>函数时就可以使用<code>cls</code>这个对象。</p><p>总结：<code>__new__</code>函数负责创建实例，<code>__init__</code>函数只负责初始化实例变量或方法。在实际工作中不建议去修改<code>__new__</code>函数。</p><p>在类中定义的函数的参数中除了第一个参数必须是<code>self</code>外，和普通的函数参数用法完全相同，也支持默认参数、可变参数。</p><h3 id="访问控制">访问控制</h3><p>以例子来说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        self.__val = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add</span>(<span class="params">self,i</span>):</span></span><br><span class="line">        self.__val += i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        self.__add(k)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = C(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.get_val()</span><br></pre></td></tr></table></figure><pre><code>5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__val</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-24-edab75c4725a&gt; in &lt;module&gt;()----&gt; 1 c.__valAttributeError: 'C' object has no attribute '__val'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.__add(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-21-ca5cc7410971&gt; in &lt;module&gt;()----&gt; 1 c.__add(2)AttributeError: 'C' object has no attribute '__add'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.inc(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.get_val()</span><br></pre></td></tr></table></figure><pre><code>7</code></pre><p><code>C</code>这个类实例化后，运行<code>c.get_val()</code>能正确得到变量<code>__val</code>的值，但直接用<code>c.__val</code>访问实例变量抛出了<code>AttributeError</code>错误，这是因为在构造函数中的<code>__val</code>这个实例变量名以双下划线开始且不以双下划线结束，这样命名的变量叫<code>私有变量</code>，此变量只能在类中调用，在类外不可访问。在调用<code>c.__add(2)</code>时抛出错误同样是因为这是一个私有方法，只在类内部调用，调用<code>c.inc(2)</code>就是很好的证明。</p><p>事实上在python中并没有真正实现对象的私有化，只是把对象的名称进行改名而已，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(c)   <span class="comment">#查看实例的属性信息</span></span><br></pre></td></tr></table></figure><pre><code>['_C__add', '_C__val', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'get_val', 'inc']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c._C__val   <span class="comment">#这样就可以访问到类的私有属性</span></span><br></pre></td></tr></table></figure><pre><code>7</code></pre><p>本来访问类变量是<code>c.__val</code>，python为了让私有变量不让外部访问，把这个私有变量重新命名为“<code>_类名__变量名</code>”，在实际编程一般不会这样来访问一个私有对象。</p><h3 id="类变量">类变量</h3><p>类变量就是定义在类中而在类方法之外的变量，以一个例子来说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    val = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上边的<code>val</code>就是一个类变量，接下来实例化此类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 = D()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2 = D()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1.val</span><br></pre></td></tr></table></figure><pre><code>5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2.val</span><br></pre></td></tr></table></figure><pre><code>5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1.val += <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1.val</span><br></pre></td></tr></table></figure><pre><code>7</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2.val</span><br></pre></td></tr></table></figure><pre><code>5</code></pre><p>上边把类D分别进行了实例化，一个是实例d1，另一个是实例d2，当执行<code>d1.val += 2</code>后，d1实例中的类变量<code>val</code>的值变为了“7”，而d2实例中的类变量<code>val</code>依然还是“5”，为什么？先再来看一个例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>:</span></span><br><span class="line">    val = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1 = F()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2 = F()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.val</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2.val</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.val.append(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.val</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3, 4]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2.val</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3, 4]</code></pre><p>当执行<code>f1.val.append(4)</code>后，<code>f1</code>和<code>f2</code>两个实例中的&quot;val&quot;变量都发生了改变，为什么在上边<code>D</code>这个类中只有一个被修改了？</p><p>这是因为在实例化后，类变量是各个实例共享的对象，都指向同一个内存地址，起先<code>d1.va1</code>和<code>d2.val</code>是指向同一个内存地址，<code>f1.val</code>和<code>f2.val</code>是指向同一内存地址，但<code>d1.va1</code>和<code>d2.val</code>指向的是一个数字，而<code>f1.val</code>和<code>f2.val</code>指向的是一个列表，数字是一个<code>不可变对象</code>，列表是一个<code>可变对象</code>，所以在执行<code>d1.val += 2</code>后，<code>d1.val</code>新创建了一个指向数字“7”的对象，而<code>d2.val</code>还是指向实例化时指向数字“5”的对象；而向列表中增加一个元素并不会创建一个新的对象，所以<code>f1.val</code>和<code>f2.val</code>依然指向同一个内存地址。</p><p>另外，类变量可直接用“类名.变量名”的方式获取，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.val</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3, 4]</code></pre><p>再来看一个例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__val</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G.__val</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-51-8de1b6f555b8&gt; in &lt;module&gt;()----&gt; 1 G.__valAttributeError: type object 'G' has no attribute '__val'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g1 = G()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g1.__val</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-54-376589fc2b09&gt; in &lt;module&gt;()----&gt; 1 g1.__valAttributeError: 'G' object has no attribute '__val'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g1.get_val()</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><p>通过以上的代码可看出，类变量以双下划线开始且以非双下划线结束时，类变量就是一个私有有类变量，在类外不能访问。</p><h3 id="类方法">类方法</h3><p>类方法用<code>@classmethod</code>这个装饰器实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_val</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(cls.__val)</span><br><span class="line">        print(cls.x)</span><br></pre></td></tr></table></figure><p>如上，因为在实例方法需要传递<code>self</code>实例本身，类方法需要传递<code>cls</code>类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = H(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H.get_val()</span><br></pre></td></tr></table></figure><pre><code>3---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-68-0c6296a44132&gt; in &lt;module&gt;()----&gt; 1 H.get_val()&lt;ipython-input-66-117847179c76&gt; in get_val(cls)      8     def get_val(cls):      9         print(cls.__val)---&gt; 10         print(cls.x)AttributeError: type object 'H' has no attribute 'x'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h.get_val()</span><br></pre></td></tr></table></figure><pre><code>3---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-69-6f7ca0ed0df3&gt; in &lt;module&gt;()----&gt; 1 h.get_val()&lt;ipython-input-66-117847179c76&gt; in get_val(cls)      8     def get_val(cls):      9         print(cls.__val)---&gt; 10         print(cls.x)AttributeError: type object 'H' has no attribute 'x'</code></pre><p>如上，在执行<code>H.get_val()</code>和<code>h.get_val()</code>后都输出了<code>cls__val</code>这个类私有变量的值，但在访问实例变量时抛出了<code>AttributeError</code>错误，说明类直接调用，如<code>H.get_val()</code>也可以通过实例调用，如<code>h.get_val()</code>，类方法可以访问类私有变量，类方法不可访问实例变量。</p><h3 id="静态方法">静态方法</h3><p>静态方法使用<code>@staticmethod</code>这个装饰器来实现，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span>:</span></span><br><span class="line">    __val = <span class="number">3</span></span><br><span class="line">    val = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_val</span>():</span></span><br><span class="line">        print(<span class="number">123</span>)</span><br><span class="line">        print(val)</span><br><span class="line">        print(__val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = I()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.print_val()</span><br></pre></td></tr></table></figure><pre><code>123---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-76-26edb3c8e63f&gt; in &lt;module&gt;()----&gt; 1 i.print_val()&lt;ipython-input-74-5f0cc11f3b96&gt; in print_val()      6     def print_val():      7         print(123)----&gt; 8         print(val)      9         print(__val)NameError: name 'val' is not defined</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I.print_val()</span><br></pre></td></tr></table></figure><pre><code>123---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-77-b5380716c77d&gt; in &lt;module&gt;()----&gt; 1 I.print_val()&lt;ipython-input-74-5f0cc11f3b96&gt; in print_val()      6     def print_val():      7         print(123)----&gt; 8         print(val)      9         print(__val)NameError: name 'val' is not defined</code></pre><p>静态方法可以通过实例来调用，也可以通过类来调用，但两种调用都不可以访问类变量，不管是私有变量还是非私有变量。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python带参数的装饰器</title>
      <link href="/2016/05/05/2016-05-05-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2016/05/05/2016-05-05-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>装饰器更高级的用法是可以带参数。</p><a id="more"></a><h2 id="带参数的装饰器">带参数的装饰器</h2><p>先来看一个不带参数的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        ret = fn(*args,**kwargs)</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"> </span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.0034420490264893</code></pre><p>这里打印出来的是执行<code>sleep</code>函数所消耗的<code>自然时间</code>,但在执行此函数时所消耗的cpu时间真的有3.0034420490264893秒吗？当然不是。利用time包中的<code>time.clock</code>方法可以计算得到代码执行所消耗cpu的时间，那怎样来修改上边的<code>timeit</code>函数，让其即能计算代码执行的自然时间，也能计算代码执行所消耗cpu的时间？做如下改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit_1</span>(<span class="params">process_time=False</span>):</span></span><br><span class="line">    cacl = time.clock <span class="keyword">if</span> process_time <span class="keyword">else</span> time.time</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeit_2</span>(<span class="params">fn</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            start = cacl()</span><br><span class="line">            ret = fn(*args,**kwargs)</span><br><span class="line">            print(cacl() - start)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line">    <span class="keyword">return</span> timeit_2</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_1</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit_1(<span class="literal">True</span>)(sleep_1)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>0.020000000000000018</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit_1(<span class="literal">False</span>)(sleep_1)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.0038363933563232</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit_1()(sleep_1)(<span class="number">3</span>)   <span class="comment"># 参数process_time是一个默认参数，所以可以不传递值，默认为False</span></span><br></pre></td></tr></table></figure><pre><code>3.003509283065796</code></pre><p>上边的调用过程是怎样的呢？分解一下，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 = timeit_1(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>上边调用<code>timeit_1(True)</code>，函数return回了<code>timeit_2</code>，并把<code>fn1</code>这个变量指向了调用结果，即指向了<code>timeit_2</code>，这里的<code>timeit_2</code>也是一个函数，此函数接收一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn2 = fn1(sleep_1)</span><br></pre></td></tr></table></figure><p>这里调用<code>fn1(sleep_1)</code>，其实就是调用了<code>timeit_2(sleep_1)</code>，并把<code>fn2</code>这个变量指向了调用后的结果，即指向了<code>warp</code>，这里的<code>warp</code>也是一个函数，此函数能接收任意的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn2(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>0.009999999999999787</code></pre><p>上边调用<code>fn2(3)</code>，其实是调用了<code>wrap(3)</code>,即执行了<code>wrap</code>函数内的语句，此函数内的<code>ret = fn(*args,**kwargs)</code>语句中的<code>fn</code>其实是指向了<code>sleep</code>，所以在执行<code>wrap</code>函数时，<code>sleep_1</code>函数才真正被执行。</p><p>既然装饰器可以用魔法来装饰一个函数，那上边经过改进过的装饰器是不是也能装饰一个函数呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timeit_1(False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_2</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep_2(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.0039477348327637</code></pre><p>如果想计算代码执行的cpu时间，那如下即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timeit_1(True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_3</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep_3(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>0.0</code></pre><p>这个魔法又发生了什么呢？</p><p>其实质就是在没有用魔法的情况下直接<code>timeit_1(True)(sleep_3)(3)</code>。而当使用<code>@</code>这个魔法后，当代码执行到此行时，解析器会执行<code>timeit_1(True)</code>,<code>timeit_1</code>实质就是一函数，接收一个参数，并返回一个<code>timeit_2</code>函数。当代码执行到<code>@</code>所在语句时，会把所装饰的<code>sleep_3</code>函数作为一个参数传递给<code>timeit_1(True)</code>的调用结果，即<code>timeit_2</code>这个函数，即<code>sleep_3</code>这个函数已作为一个变量传递给了<code>timeit_2(fn)</code>中的<code>fn</code>参数，并返回了一个<code>wrap</code>函数，在接下的调用<code>sleep_3(3)</code>这个操作，其实此时的<code>sleep_3</code>这个函数已不是原先的<code>def sleep_3(x):</code>中的<code>sleep_3</code>函数，而是一个指向了<code>wrap</code>的函数，<code>wrap</code>函数接收任何参数，所以把当执行<code>sleep_3(3)</code>时，把参数<code>3</code>传递给了<code>wrap</code>函数，并执行内部的代码，内部代码中<code>ret = fn(*args,**kwargs)</code>中的<code>fn</code>函数依赖还是指向原先的<code>sleep_3(x)</code>这个函数。</p><p>这里也有一个简单的记忆方式，如果一个函数被装饰器所装饰，在调用这个函数时其实不再是调用表面上看上去的这个函数，以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timeit_1(True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_3</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><p>来做说明。当执行到有<code>@</code>魔法所在行时，相当于执行了<code>sleep_3 = timeit_1(True)(sleep_3)</code>，即指向了<code>wrap</code>函数，既然<code>sleep_3</code>指向了<code>wrap</code>函数，那我们执行<code>sleep_3(3)</code>时，其实就是在进行<code>wrap(3)</code>这样的函数调用，记住，函数名也是一个变量。</p><p>再来举一个带参数的装饰器的例子，比如有一个函数，只有在对有许可权限的用户开放，执行此函数的用户没有在认证列表里的，就不会执行这个函数。这个该如何实现呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">allow_users</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_check</span>(<span class="params">fn</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">username,*args,**kwargs</span>):</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;This is wrap&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> username <span class="keyword">in</span> allow_users:</span><br><span class="line">                <span class="keyword">return</span> fn(username,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;You are illegal users&quot;</span></span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line">    <span class="keyword">return</span> inner_check</span><br><span class="line"> </span><br><span class="line"><span class="meta">@check([&#x27;zhaochj&#x27;,&#x27;zcj&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">private</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;The authentication&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;You are legitimate users&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private(<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'You are legitimate users'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private(<span class="string">&#x27;tom&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'You are illegal users'</code></pre><p>这样就可以对调用函数进行身份验证。</p><p>python中一个函数有一些属性是函数本身具有的，比如<code>__name__</code>属性是查看函数名称，<code>__doc__</code>是查看函数文档的等等。如果一个函数被装饰器装饰过后，这个函数的这些属性会发生怎样的变化呢？以上边的<code>check</code>装饰器和<code>private</code>函数为例子，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private.__name__</span><br></pre></td></tr></table></figure><pre><code>'wrap'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private.__doc__</span><br></pre></td></tr></table></figure><pre><code>'This is wrap'</code></pre><p><code>private</code>函数的名称是<code>wrap</code>了，文档也是<code>wrap</code>函数的文档，这是怎么回事？上边已经说过，这里的<code>private</code>函数被装饰器装饰后它已不再是原来的<code>private</code>函数，<code>private</code>这个函数名称会被指向到<code>wrap</code>这个函数对象，那当然用上边的<code>private.__name__</code>和<code>private.__doc__</code>查看函数的属性就会是<code>wrap</code>函数的属性。那怎样来修正呢？可以这样做，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_1</span>(<span class="params">allow_users</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_check</span>(<span class="params">fn</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">username,*args,**kwargs</span>):</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;This is wrap&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> username <span class="keyword">in</span> allow_users:</span><br><span class="line">                <span class="keyword">return</span> fn(username,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;You are illegal users&quot;</span></span><br><span class="line">        wrap.__name__ = fn.__name__</span><br><span class="line">        wrap.__doc__ = fn.__doc__</span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line">    <span class="keyword">return</span> inner_check</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">@check_1([&#x27;zhaochj&#x27;,&#x27;zcj&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">private_1</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;The authentication&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;You are legitimate users&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private_1.__name__</span><br></pre></td></tr></table></figure><pre><code>'private_1'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private_1.__doc__</span><br></pre></td></tr></table></figure><pre><code>'The authentication'</code></pre><p>通过在装饰器把<code>__name__</code>和<code>__doc__</code>重新赋值后就能更正这个问题，但对一个函数来说像<code>__name__</code>这样类似的属性有许多，如果都是这样手工来修正显然是不现实的，所以python提供了一个<code>wraps</code>装饰器来自动修正这个问题，<code>wraps</code>在<code>functools</code>这个包中，所以可以这样来修正这个问题，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_1</span>(<span class="params">allow_users</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_check</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(fn)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">username,*args,**kwargs</span>):</span></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;This is wrap&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> username <span class="keyword">in</span> allow_users:</span><br><span class="line">                <span class="keyword">return</span> fn(username,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;You are illegal users&quot;</span></span><br><span class="line">        <span class="keyword">return</span> wrap</span><br><span class="line">    <span class="keyword">return</span> inner_check</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">@check_1([&#x27;zhaochj&#x27;,&#x27;zcj&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">private_1</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;The authentication&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;You are legitimate users&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private_1.__name__</span><br></pre></td></tr></table></figure><pre><code>'private_1'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private_1.__doc__</span><br></pre></td></tr></table></figure><pre><code>'The authentication'</code></pre><p><code>@functools.wraps(fn)</code>这个装饰器相当于执行了<code>wrap.__name__ = fn.__name__</code>这样的操作。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python装饰器</title>
      <link href="/2016/05/04/2016-05-04-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2016/05/04/2016-05-04-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之装饰器</p><a id="more"></a><h2 id="装饰器">装饰器</h2><p>先来看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">fn</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    fn()</span><br><span class="line">    print(time.time() - start)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上边代码定义了两个函数，timeit函数能够模拟计算出在执行fn函数所花费的时间，调用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit(sleep)</span><br></pre></td></tr></table></figure><pre><code>3.003638505935669</code></pre><p>这样来计算一个函数的执行时间是有缺陷的，<code>sleep</code>函数必须是一个无参的函数，那怎样才能让<code>sleep</code>能接收参数呢？做如下改进：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit_1</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">x</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        fn(x)</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_1</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit_1(sleep_1)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.0035746097564697</code></pre><p>这样<code>timeit_1</code>函数通过<code>wrap</code>函数进行一次包装后就可以让<code>sleep</code>函数接收一个参数，但如果<code>sleep</code>函数所接收的参数个数是不确定的呢？这个可以采用python中的可变参数来解决，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit_2</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        fn(*args,**kwargs)</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><p>这样对于<code>sleep</code>这个函数所需要接收的参数个数就没有限制了，调用方法与上边的不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit_2(sleep_1)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.003852605819702</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeit_2(sleep_1)(x=<span class="number">3</span>)   <span class="comment">#以关键字参数方式传递参数</span></span><br></pre></td></tr></table></figure><pre><code>3.003178119659424</code></pre><p>其实这里的<code>timeit_2</code>就是一个<code>装饰器</code>,在python中有一个语法糖来表示，如果在执行一个函数时，比如上边的<code>sleep_1</code>函数想在其执行前后增加一些语句操作，比如上边的<code>start = time.time()</code>和<code>print(time.time() - start)</code>，那在定义<code>sleep_1</code>函数时就可以加上一个装饰器来装饰此函数，这样定义的函数有其独特的语法，在定义函数时在其上边用一个<code>@</code>符号加上装饰器函数的名称即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timeit_2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_2</span>(<span class="params">x</span>):</span></span><br><span class="line">    time.sleep(x)</span><br></pre></td></tr></table></figure><p>如上定义后的<code>sleep_2</code>的函数，我们在调用时就不需要再去调用<code>timeit_2</code>这个函数了，直接调用<code>sleep_2</code>函数即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep_2(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>3.0038673877716064</code></pre><p>上边调用<code>sleep_2(3)</code>时，函数的执行流程是怎样的呢？</p><ol><li><p>首先把<code>sleep_2</code>函数作为参数传递到<code>timeit_2</code>这个装饰器函数中执行，返回一个<code>wrap</code>函数对象</p></li><li><p>再把调用<code>sleep_2(3)</code>函数时的参数<code>3</code>传递到<code>wrap</code>函数参数中进行函数调用，实质就是解释器会转换成<code>timeit_2(sleep_2)(3)</code>的方式来调用，但是在已经使用<code>@timeit_2</code>语法来装饰函数<code>sleep_2</code>的场景下不能再使用<code>timeit_2(sleep_2)(3)</code>来调用函数，因为这样<code>wrap</code>函数会被执行两次。</p></li></ol><p>最后总结一下：</p><p>装饰器的本质就是一个函数，此函数接收一个函数作为参数，返回一个函数，通常，返回的这个函数，是对传入的函数执行进行前后增加了一些语句，所以叫做装饰器。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python列表解析</title>
      <link href="/2016/05/03/2016-05-03-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/05/03/2016-05-03-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之列表解析</p><a id="more"></a><h2 id="列表解析">列表解析</h2><p>列表解析是一种能快速生成列表的方法，在对元素的迭代上速度快于for循环</p><ul><li>列表解析的语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; [expression for item in iterator]</span><br></pre></td></tr></table></figure><p>等同于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; []</span><br><span class="line">for item in iterator:</span><br><span class="line">    ret.append(expression)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst1 = list(range(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst1</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> lst1]</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><p>上边的列表解析等价于下边的for循环，但速度上列表解析要快：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst1:</span><br><span class="line">    ret.append(x + <span class="number">1</span>)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre><ul><li>带条件的列表解析</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst1</span><br></pre></td></tr></table></figure><pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> lst1 <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>]  <span class="comment">#只对列表中偶数进行加&#x27;1&#x27;计算</span></span><br></pre></td></tr></table></figure><pre><code>[1, 3, 5, 7, 9]</code></pre><p>等同于下边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst1:</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        ret.append(x + <span class="number">1</span>)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><pre><code>[1, 3, 5, 7, 9]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> lst1 <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">if</span> x &gt; <span class="number">2</span>]  <span class="comment">#带多条件判断，条件之间是and的关系</span></span><br></pre></td></tr></table></figure><pre><code>[5, 7, 9]</code></pre><p>等同于下边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst1:</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> x &gt; <span class="number">2</span>:</span><br><span class="line">        ret.append(x + <span class="number">1</span>)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><pre><code>[5, 7, 9]</code></pre><h2 id="操作多个列表">操作多个列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">l2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">[(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> l1 <span class="keyword">for</span> y <span class="keyword">in</span> l2]</span><br></pre></td></tr></table></figure><pre><code>[(1, 2), (1, 4), (1, 6), (3, 2), (3, 4), (3, 6), (5, 2), (5, 4), (5, 6)]</code></pre><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> l1:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> l2:</span><br><span class="line">        ret.append((x,y))</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><pre><code>[(1, 2), (1, 4), (1, 6), (3, 2), (3, 4), (3, 6), (5, 2), (5, 4), (5, 6)]</code></pre><ul><li>列表解析生成集合</li></ul><p>列表解析用于集合时只需要把’[]‘修改成’{}'即可，语法不会发生改变，但集合有一个特性，就是会去掉列表中的重复数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line">&#123;x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> s&#125;</span><br></pre></td></tr></table></figure><pre><code>&#123;2, 4, 6, 8&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l3 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">&#123;x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> l3&#125;</span><br></pre></td></tr></table></figure><pre><code>&#123;2, 4, 6, 8&#125;</code></pre><ul><li>列表解析生成字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l4 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">l5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#123;k:v <span class="keyword">for</span> k <span class="keyword">in</span> l4 <span class="keyword">for</span> v <span class="keyword">in</span> l5&#125;</span><br></pre></td></tr></table></figure><pre><code>&#123;'a': 3, 'b': 3, 'c': 3&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(k,v) <span class="keyword">for</span> k <span class="keyword">in</span> l4 <span class="keyword">for</span> v <span class="keyword">in</span> l5]</span><br></pre></td></tr></table></figure><pre><code>[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)]</code></pre><p>从上边的两个例子中可看出：生成字典与生成列表时是有些区别的，在对多个列表操作生成字典时，字典的key是第一个for词句中的各元素，而v是第二个for词句中的最后一个元素。而生成一个列表时返回的是一个笛卡尔乘积。</p><p>一个元素是元组的列表，可利用列表解析生成一个字典，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l5 = [(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> l5&#125;</span><br></pre></td></tr></table></figure><pre><code>&#123;'a': 1, 'b': 2, 'c': 3&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 列表解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的字符串操作</title>
      <link href="/2016/05/01/2016-05-01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/2016/05/01/2016-05-01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之字符串操作</p><a id="more"></a><h1>1 字符串操作</h1><h2 id="1-1-字符串是一种线性结构">1.1 字符串是一种线性结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;learn python&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><pre><code>learn python</code></pre><h2 id="1-2-字符串是不可变的">1.2 字符串是不可变的</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><pre><code>'e'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="string">&#x27;L&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-5-74f3af69d7f0&gt; in &lt;module&gt;()----&gt; 1 a[1] = 'L'TypeError: 'str' object does not support item assignment</code></pre><h2 id="1-3-字符串格式化">1.3 字符串格式化</h2><ul><li><code>%</code>格式化操作符号</li></ul><p>以元组方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;%s learn python&#x27;</span> % (<span class="string">&#x27;zhaochj&#x27;</span>,)</span><br></pre></td></tr></table></figure><pre><code>'zhaochj learn python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;%s learn python,%s is a man&#x27;</span> % (<span class="string">&#x27;zhaochj&#x27;</span>,<span class="string">&#x27;zhaochj&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'zhaochj learn python,zhaochj is a man'</code></pre><p>以字典方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;%(name)s learn python&#x27;</span> % &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaochj&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><pre><code>'zhaochj learn python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;%(name)s learn python,%(name)s is a man&#x27;</span> % &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaochj&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><pre><code>'zhaochj learn python,zhaochj is a man'</code></pre><ul><li><code>format</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;0&#125; learn python,&#123;name&#125; is a man&#x27;</span>.format(<span class="string">&#x27;zhaochj&#x27;</span>,name=<span class="string">&#x27;he&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'zhaochj learn python,he is a man'</code></pre><h2 id="1-4-字符串的常用操作">1.4 字符串的常用操作</h2><ul><li>字符串连接<code>join</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;zhoachj&#x27;</span>,<span class="string">&#x27;learn&#x27;</span>,<span class="string">&#x27;python&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>.join(lst)</span><br></pre></td></tr></table></figure><pre><code>'zhoachj learn python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_&#x27;</span>.join(lst)</span><br></pre></td></tr></table></figure><pre><code>'zhoachj_learn_python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> lst:</span><br><span class="line">    ret += s</span><br><span class="line">    ret += <span class="string">&#x27; &#x27;</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><pre><code>'zhoachj learn python '</code></pre><ul><li>字符串切割，常用操作有：<code>split</code>,<code>rsplit</code>,<code>splitlines</code>,<code>partition</code>,<code>rpartition</code></li></ul><p><em>split</em>，从左往右按照给定的标准切割字符串，默认是以空格为切割，返回一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;zhaochj learn python&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.split()   <span class="comment">#split默认以空格切割，并返回一个list</span></span><br></pre></td></tr></table></figure><pre><code>['zhaochj', 'learn', 'python']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.split(<span class="string">&#x27;o&#x27;</span>) <span class="comment">#指定分割的标准为字母&#x27;o&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>['zha', 'chj learn pyth', 'n']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.split(<span class="string">&#x27;o&#x27;</span>,<span class="number">1</span>) <span class="comment">#限制分割的次数</span></span><br></pre></td></tr></table></figure><pre><code>['zha', 'chj learn python']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User = <span class="string">&#x27;root:x:0:0:root:/root:/bin/bash&#x27;</span>   <span class="comment">#如何获取用户名称</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.split(<span class="string">&#x27;:&#x27;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>['root', 'x:0:0:root:/root:/bin/bash']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username,_ = User.split(<span class="string">&#x27;:&#x27;</span>,<span class="number">1</span>)  <span class="comment">#&#x27;_&#x27;表示占位，丢掉此位置上的元素</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username</span><br></pre></td></tr></table></figure><pre><code>'root'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.split(<span class="string">&#x27;:&#x27;</span>,<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment">#这样也可得到用户名称</span></span><br></pre></td></tr></table></figure><pre><code>'root'</code></pre><p><em>rsplit</em>，从右往左按照给定的标准切割字符串，默认是以空格为切割，返回一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User2 = <span class="string">&#x27;root:x:0:0:root:/root:/bin/bash&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User2.rsplit(<span class="string">&#x27;:&#x27;</span>,<span class="number">1</span>)    <span class="comment">#切割是从右开始往左的</span></span><br></pre></td></tr></table></figure><pre><code>['root:x:0:0:root:/root', '/bin/bash']</code></pre><p><em>splitlines</em>，一般是用来处理多行的字符串对象，它以换行符(\n)为标准切割多行字符串，并可给定一个<code>keepend</code>值来是否保留<code>\n</code>这个换行符，默认是<code>False</code>，表示不保留换行符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I love python</span></span><br><span class="line"><span class="string">I also love linux</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1   <span class="comment">#输出的字串里有三个换行符</span></span><br></pre></td></tr></table></figure><pre><code>'\nI love python\nI also love linux\n'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.splitlines()   <span class="comment">#不显示指定Ture或False，那默认为False，表示不保留换行符号</span></span><br></pre></td></tr></table></figure><pre><code>['', 'I love python', 'I also love linux']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.splitlines(<span class="literal">True</span>)   <span class="comment">#指定`keepend`为`True`时，返回的列表里各元素保留换行符号</span></span><br></pre></td></tr></table></figure><pre><code>['\n', 'I love python\n', 'I also love linux\n']</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.splitlines(<span class="literal">False</span>)  <span class="comment">#这是默认行为，可不指定`False`</span></span><br></pre></td></tr></table></figure><pre><code>['', 'I love python', 'I also love linux']</code></pre><p><em>partition</em>，表示传入一个分隔符号，返回一个元组，元组里第一个元素是分割后的第一个字符，第二个元素是分隔符号，第三个元素切割后剩下的所有字符。(切割顺序是从左往右)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User3 = <span class="string">&#x27;root:x:0:0:root:/root:/bin/bash&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User3.partition(<span class="string">&#x27;:&#x27;</span>)   <span class="comment">#表示以`:`为切割，返回一个元组</span></span><br></pre></td></tr></table></figure><pre><code>('root', ':', 'x:0:0:root:/root:/bin/bash')</code></pre><p><em>rpartition</em>，表示传入一个分隔符号，返回一个元组，元组里第一个元素是分割后的第一个字符，第二个元素是分隔符号，第三个元素切割后剩下的所有字符。(切割顺序是从右往左)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User4 = <span class="string">&#x27;root:x:0:0:root:/root:/bin/bash&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User4.rpartition(<span class="string">&#x27;:&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>('root:x:0:0:root:/root', ':', '/bin/bash')</code></pre><ul><li>字符串修改–字符的大小写修改，准确的说不应该叫修改，因为字符串是不可变对象。常用的操作有：<code>capitalize</code>,<code>title</code>,<code>lower</code>,<code>upper</code>,<code>swapcase</code></li></ul><p><em>capitalize</em>，表示把字符串的首字母修改成大写，其他的所有字符都修改成小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&#x27;i LoVe pYthon&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str2.capitalize()</span><br></pre></td></tr></table></figure><pre><code>'I love python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(str2)</span><br></pre></td></tr></table></figure><pre><code>140153643362864</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(str2.capitalize())  <span class="comment">#与str2字符串的id值不同，所以准确的说不应该叫字符串修改</span></span><br></pre></td></tr></table></figure><pre><code>140153643363440</code></pre><p><em>title</em>，表示把字符串中所有单词的首字母修改成大写，之外的所有符全部为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str3= <span class="string">&#x27;i LoVe pYthon&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str3.title()</span><br></pre></td></tr></table></figure><pre><code>'I Love Python'</code></pre><p><em>upper</em>，表示把所有字符都修改成大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str3.upper()</span><br></pre></td></tr></table></figure><pre><code>'I LOVE PYTHON'</code></pre><p><em>lower</em>，表示把所有字符修改为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str3.lower()</span><br></pre></td></tr></table></figure><pre><code>'i love python'</code></pre><p><em>swapcase</em>，表示把字符串的字符的大小写反转，即大写修改成小写，小写的修改成大写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str3</span><br></pre></td></tr></table></figure><pre><code>'i LoVe pYthon'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str3.swapcase()</span><br></pre></td></tr></table></figure><pre><code>'I lOvE PyTHON'</code></pre><ul><li>字符串修改–填充，常用方法有：<code>center</code>,<code>ljust</code>,<code>rjust</code></li></ul><p><em>center</em>，两边填充，此方法接收一个填充宽度，默认以此宽度个空格来填充字符，也可指定填充字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4 = <span class="string">&#x27;python&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4.center(<span class="number">19</span>)  <span class="comment">#默认以空格填充，str4字符串尽可能放在这19个字符的中间</span></span><br></pre></td></tr></table></figure><pre><code>'       python      '</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4.center(<span class="number">19</span>,<span class="string">&#x27;*&#x27;</span>)  <span class="comment">#指定填充的字符为*号</span></span><br></pre></td></tr></table></figure><pre><code>'*******python******'</code></pre><p><em>ljust</em>，左移右填充，表示把字符串左移后在右边填充指定字符，与<code>center</code>方法类似，接收一个填充宽度，默认是以空格填充，也可以指定填充字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4</span><br></pre></td></tr></table></figure><pre><code>'python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4.ljust(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>'python    '</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4.ljust(<span class="number">10</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'python****'</code></pre><p><em>rjust</em>，右移左填充，表示把字符串右移后在左边填充指定字符，与center方法类似，接收一个填充宽度，默认是以空格填充，也可以指定填充字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4</span><br></pre></td></tr></table></figure><pre><code>'python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4.rjust(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>'    python'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str4.rjust(<span class="number">10</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'****python'</code></pre><ul><li>字符串修改–清除，常用方法有：<code>strip</code>,<code>rstrip</code>,<code>lstrip</code></li></ul><p>_strip_方法，表示清除字符串两边的一个空格或多个空格，换行符也同样适用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str5 = <span class="string">&#x27;   python       \n &#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str5</span><br></pre></td></tr></table></figure><pre><code>'   python       \n '</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str5.strip()</span><br></pre></td></tr></table></figure><pre><code>'python'</code></pre><p>_rstrip_方法，表示只清除字符串右边的空格或换行符号(一个或多个)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str5.rstrip()</span><br></pre></td></tr></table></figure><pre><code>'   python'</code></pre><p>_lstrip_方法，表示只清除字符串左边的空格或换行符号(一个或多个)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str5.lstrip()</span><br></pre></td></tr></table></figure><pre><code>'python       \n '</code></pre><ul><li>字符串判断，常用方法有：<code>startswith</code>,<code>endswith</code>,<code>isdigit</code>,<code>istitle</code>,<code>islower</code>,<code>isupper</code></li></ul><p><em>startswith</em>，表示判断一个字符串是以指定字符开头，返回bool值，可指定搜索判断的范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str6 = <span class="string">&#x27;Python is a programming language&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str6.startswith(<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str6.startswith(<span class="string">&#x27;is&#x27;</span>,<span class="number">7</span>,<span class="number">30</span>) <span class="comment">#限定范围搜索开始字符是不是&#x27;is&#x27;，从第7个字符开始，但不包含第7个字符</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p><em>endswith</em>，表示判断一个字符串是以指定字符结尾，返回bool值，可指定搜索判断的范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str6.endswith(<span class="string">&#x27;language&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str6.endswith(<span class="string">&#x27;is&#x27;</span>,<span class="number">2</span>,<span class="number">9</span>)  <span class="comment">#包含第9个字符</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p><em>isdigit</em>，判断一个字符是不是数字，返回bool值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str7 = <span class="string">&#x27;40&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str7.isdigit()</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p><em>istitle</em>，判断字符串中每一个单词是否都都以大写字母开始，返回bool值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str8 = <span class="string">&#x27;I Love Python&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str8.istitle()</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str9 = <span class="string">&#x27;I love Pyton&#x27;</span>   <span class="comment">#&#x27;love&#x27;这个单词的开头不是大写字母，所以返回False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str9.istitle()</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><p><em>islower</em>，判断所有字符都是小写字母</p><p><em>isupper</em>，判断所有字符都是大写字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str9</span><br></pre></td></tr></table></figure><pre><code>'I love Pyton'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str9.islower()</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str9.isupper()</span><br></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10 = <span class="string">&#x27;i love python&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.islower()</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str11 = <span class="string">&#x27;I LOVE PYTHON&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str11.isupper()</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><ul><li>字符串查找与替换，常用方法：<code>count</code>,<code>index</code>,<code>rindex</code>,<code>find</code>,<code>rfind</code>,<code>replace</code></li></ul><p>_count_方法，表示统计指定字符出现的次数，可指定一个范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10 = <span class="string">&#x27;I love python,I also love linux&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.count(<span class="string">&#x27;o&#x27;</span>)  <span class="comment">#统计字符&#x27;o&#x27;出现的次数</span></span><br></pre></td></tr></table></figure><pre><code>4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.count(<span class="string">&#x27;o&#x27;</span>,<span class="number">10</span>,<span class="number">30</span>)  <span class="comment">#指定范围，从第10个字符开始，但不包含第10的个字符，至第30个字符结束，包含第30个字符</span></span><br></pre></td></tr></table></figure><pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.count(<span class="string">&#x27;love&#x27;</span>)  <span class="comment">#也能统计一个字符串</span></span><br></pre></td></tr></table></figure><pre><code>2</code></pre><p>_index_方法，从左往右查找，返回指定字符的索引，可指定范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10</span><br></pre></td></tr></table></figure><pre><code>'I love python,I also love linux'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.index(<span class="string">&#x27;o&#x27;</span>)   <span class="comment">#当查找字符串中有多个满足条件时返回第一个</span></span><br></pre></td></tr></table></figure><pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.index(<span class="string">&#x27;o&#x27;</span>,<span class="number">10</span>,<span class="number">20</span>)   <span class="comment">#指定一个范围</span></span><br></pre></td></tr></table></figure><pre><code>11</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10[<span class="number">11</span>]</span><br></pre></td></tr></table></figure><pre><code>'o'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.index(<span class="string">&#x27;python&#x27;</span>)  <span class="comment">#当查找的是一个字符串时，返回此字符串中第一个字符的索引值</span></span><br></pre></td></tr></table></figure><pre><code>7</code></pre><p>_rindex_方法，表示从右往左查找，返回查找字符的索引值，当然也可指定一个范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10</span><br></pre></td></tr></table></figure><pre><code>'I love python,I also love linux'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.rindex(<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>22</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.rindex(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>7</code></pre><p>_find_方法，表示<code>从左往右</code>查找一个字符，若查找到了则返回相应的索引值，若没有查找到则返回’-1’，不会像<code>index</code>方法样会抛出异常，可指定范围查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10</span><br></pre></td></tr></table></figure><pre><code>'I love python,I also love linux'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.find(<span class="string">&#x27;love&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.find(<span class="string">&#x27;love&#x27;</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>21</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.find(<span class="string">&#x27;aaa&#x27;</span>)   <span class="comment">#查找一个不存在的字符时返回&#x27;-1&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>-1</code></pre><p>_rfind_方法，表示<code>从右往左</code>查找一个字符，若查找到了则返回相应的索引值，若没有查找到则返回’-1’，不会像index方法样会抛出异常，可指定范围查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10</span><br></pre></td></tr></table></figure><pre><code>'I love python,I also love linux'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.rfind(<span class="string">&#x27;love&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>21</code></pre><p>_replace_方法，表示替换指定的字符，可指定替换的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10</span><br></pre></td></tr></table></figure><pre><code>'I love python,I also love linux'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.replace(<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;like&#x27;</span>)   <span class="comment">#当不指定替换次数时，默认为替换全部</span></span><br></pre></td></tr></table></figure><pre><code>'I like python,I also like linux'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str10.replace(<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;like&#x27;</span>,<span class="number">1</span>)  <span class="comment">#指定替换次数为1</span></span><br></pre></td></tr></table></figure><pre><code>'I like python,I also love linux'</code></pre>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建CA及证颁发证书shell脚本</title>
      <link href="/2016/04/30/2016-04-30-built-CA-and-certificate/"/>
      <url>/2016/04/30/2016-04-30-built-CA-and-certificate/</url>
      
        <content type="html"><![CDATA[<p>自建CA及为证书颁发是一个复杂有繁琐的事情，所以这里写一个shell脚本来简化相应的工作。</p><a id="more"></a><p>以下shell脚本能简化手动搭建CA及证书颁发的操作，已在 <code>debian 8 x64</code>平台验证通过。</p><pre><code>  #!/bin/bash#Program: ca.sh#Author: Neal#E_mail: 419775240@qq.com#Date: 2016-4-30#platform: Debian 8 x86_64#Version 1.0# SUBJECT为CA服务的机构信息SUBJECT="/C=CN/ST=ChongQing/L=YuBei/O=SJKJ/OU=CA"# SUBJECT_REQUEST为需要申请证书的机构信息SUBJECT_REQUEST="/C=CN/ST=ChongQing/L=YuBei/O=SJKJ/OU=OP"#证书存放目录SSL_DIR="/usr/local/nginx18/conf/ssl"#apt-get -y install openssl  依赖包## 自建CA read -p "Enter your CA domain [www.example.com]: " DOMAINmkdir -pv /etc/ssl/demoCA/&#123;private,newcerts&#125; > /dev/nullcd /etc/ssl# 生成密钥对(umask 077;openssl genrsa -out ./demoCA/private/cakey.pem 2048)# 生成自签证书#手动输入ca机构信息时输入命令：openssl req -new -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650openssl req -new -subj "$&#123;SUBJECT&#125;/CN=$DOMAIN" -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650result=$?touch ./demoCA/index.txtecho 01 > ./demoCA/serial[ $result == 0 ] && echo -e "\033[33mCertificate services is created...\033[0m" || echo -e '\033[33mCertificate services is NOT created...\033[0m'#自建CA完成# 开始为你的域名申请证书read -p "Enter your domain [www.example.com]: " DOMAIN_GITLAB[ ! -d $&#123;SSL_DIR&#125; ] && mkdir -p $&#123;SSL_DIR&#125;cd $&#123;SSL_DIR&#125;# 生成私钥(umask 077;openssl genrsa -out $&#123;DOMAIN_GITLAB&#125;.key 1024)# 生成证书签署请求openssl req -new -subj "$SUBJECT_REQUEST/CN=$DOMAIN_GITLAB" -key $&#123;DOMAIN_GITLAB&#125;.key -out $&#123;DOMAIN_GITLAB&#125;.csr# CA签署证书cd /etc/sslopenssl ca -in $&#123;SSL_DIR&#125;/$&#123;DOMAIN_GITLAB&#125;.csr -out $&#123;SSL_DIR&#125;/$&#123;DOMAIN_GITLAB&#125;.crt -days 3650# 更改目录权限chmod 700 $&#123;SSL_DIR&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自建CA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python装饰器</title>
      <link href="/2016/04/07/2016-04-07-python-learn-decorator/"/>
      <url>/2016/04/07/2016-04-07-python-learn-decorator/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之装饰器</p><a id="more"></a><h1>高阶函数</h1><p>一个函数能接受另一个函数作为参数传入，这样的一个函数就是高阶函数。</p><p>在python中一切皆对象，函数也不例外，函数是可以赋予给一个变量的，看下边代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求绝对值函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">x</span>):</span></span><br><span class="line">    val = x <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -x</span><br><span class="line">    <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(<span class="number">-34</span>)</span><br></pre></td></tr></table></figure><pre><code>34</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><pre><code>20</code></pre><p>在上边的代码中定义了一个函数 <code>fn()</code>，这个函数接收一个参数，函数名是<code>fn</code>，<code>fn(-34)</code>和<code>fn(20)</code>是函数调用。函数名<code>fn</code>是什么呢？其实它就是指向能计算绝对值函数的一个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1 = fn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(f1)</span><br></pre></td></tr></table></figure><pre><code>function</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1(<span class="number">-12</span>)</span><br></pre></td></tr></table></figure><pre><code>12</code></pre><p>如上，变量<code>f1</code>已指向了<code>fn</code>函数，调用<code>fn()</code>与调用<code>f1()</code>是一样的效果。得到的结论是变量是可以指向一个函数。</p><p>那函数的参数能否接收一个变量呢？以代码来验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">-23</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(a)</span><br></pre></td></tr></table></figure><pre><code>23</code></pre><p>上边把变量<code>a</code>指向了<code>-23</code>，再调用<code>fn()</code>函数时把变量<code>a</code>传入，得到了正确的结果，所以函数的参数是能接收一个变量。</p><p><strong>总结：在python中，变量可以指向一个函数，函数的参数可以接收一个变量，那么函数的参数也就可以是一个函数。下边以实际代码来验证</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> y(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a ** <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num(<span class="number">4</span>,f)</span><br></pre></td></tr></table></figure><pre><code>16</code></pre><p>上边直接调用<code>num()</code>函数，把指向函数<code>f(a)</code>的函数名<code>f</code>，即<code>f</code>实质也是一个变量，作为一个变量传递给了<code>num(x,y)</code>函数中的参数<code>y</code>，这样也得到了正确的答案。所以函数中的参数可以接收一个函数。</p><p>总结：高阶函数的实质就是函数的参数能够接收另一个函数。</p><h1>装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">fn</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call myfun()&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f4 = deco(myfun) <span class="comment">#调用deco(fn)函数，把myfun函数作为参数传入，deco(fn)函数会先执行print语句，再返回fn函数，即这里的myfun函数。再让变量f4指向myfun()这个函数对象</span></span><br></pre></td></tr></table></figure><pre><code>ha ha ha</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f4()   <span class="comment">#f4是指向myfun()函数对象的一个变量，因为变量可以指向一个函数，所以执行f4()就可以调用myfun()这个函数</span></span><br></pre></td></tr></table></figure><pre><code>call myfun</code></pre><p>采用python的魔法也可以实现上边的相同效果，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call myfun&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>ha ha ha</code></pre><p><code>@deco</code>中的<code>@</code>是语法糖，表示下边定义的函数将会被<code>@</code>后的那个函数所修饰，即<code>myfun()</code>函数会被<code>deco(fn)</code>这个函数所修饰，实质就是执行了<code>myfun = deco(myfun)</code>，所以打印出了<code>ha ha ha</code>，并把原来的<code>myfun()</code>函数返回回来，下边执行<code>myfun()</code>时就调用了原来的<code>myfun()</code>函数，输出了<code>call myfun</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfun()</span><br></pre></td></tr></table></figure><pre><code>call myfun</code></pre><p>再对上边的deco函数进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;call &#123;0&#125; funtion&#x27;</span>.format(fn.__name__))</span><br><span class="line">        fn()</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call myfun&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfun()</span><br></pre></td></tr></table></figure><pre><code>ha ha hacall myfun funtioncall myfun</code></pre><p><code>myfun()</code>函数被<code>deco(fn)</code>函数进行修饰后，调用<code>myfun()</code>时就像被施加了魔法一样在执行此函数前附加的执行了一些操作，当然也可以在执行函数后附加一些操作。</p><p>上边被装饰的<code>myfun()</code>函数是一个无参的函数，如果被装饰的函数需要接收参数呢？这时装饰器应该这样的来定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;call &#123;0&#125; funtion&#x27;</span>.format(fn.__name__))</span><br><span class="line">        <span class="keyword">return</span> fn(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><p>考虑到被装饰的函数可以接收的参数类型的不确定性，可以用可变位置参数和可变关键字参数来捕捉，即<code>(*args,**kwargs)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfun(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><pre><code>ha ha hacall myfun funtion25</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfun.__name__</span><br></pre></td></tr></table></figure><pre><code>'wrap'</code></pre><p><code>myfun(x)</code>函数被<code>deco(fn)</code>函数装饰后，函数对象的<code>__name__</code>属性会发生改变，发上输出。因为<code>@deco</code>就相当于执行了<code>myfun = deco(myfun)</code>，即变量<code>myfun</code>已经指向了<code>wrap(*args,**kwargs)</code>函数，这时<code>myfun</code>变量指向函数的<code>__name__</code>属性就是<code>wrap</code>，不再是原来的<code>myfun()</code>函数的<code>__name__</code>属性。如果要修正这个问题，可以直接引用python内置的<code>functools.wraps</code>方法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;ha ha ha&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;call &#123;0&#125; funtion&#x27;</span>.format(fn.__name__))</span><br><span class="line">        <span class="keyword">return</span> fn(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfun(<span class="number">25</span>)</span><br></pre></td></tr></table></figure><pre><code>ha ha hacall myfun funtion625</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfun.__name__</span><br></pre></td></tr></table></figure><pre><code>'myfun'</code></pre><p>总结：装饰器其实也是一个函数，此函数可以接收一个函数作为参数，并返回一个函数，即也是一个高阶函数。装饰器这个函数能让一个函数在调用时的前或后额外的执行一些操作来修改原调用的函数。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器，decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用shell部署gitlab</title>
      <link href="/2016/04/06/2016-04-06-deploy-gitlab-use-shell/"/>
      <url>/2016/04/06/2016-04-06-deploy-gitlab-use-shell/</url>
      
        <content type="html"><![CDATA[<p>在51cto的博文<a href="http://zhaochj.blog.51cto.com/368705/1737738">《企业级GitLab仓库环境构建》</a>中已全面的介绍过怎样搭建一个gitlab，这里把整个环境的搭建过程整理后用shell脚本的方式组织起来。</p><a id="more"></a><p>gitlab软件包安装和基础配置：</p><pre><code> gitlab@gitlab-01:~/tools$ cat install_config_gitlab.sh #!/bin/bash#Program: configure gitlab#Author: Neal#E_mail: 419775240@qq.com#Date: 2015-12-04#platform: Debian 8 x86_64#Version 1.0# 通用安装包到http://mirror.tuna.tsinghua.edu.cn/gitlab-ce/进行下载sudo dpkg -i gitlab-ce_8.2.1-ce.0_amd64.deb# 修改gitlab数据存放目录sudo vim /var/opt/gitlab/gitlab-shell/config.yml    # repos_path: "/data/git-data/repositories"sudo vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml#satellites:#     path: /data/git-data/gitlab-satellites#     ...#gitlab_shell:#     path: /opt/gitlab/embedded/service/gitlab-shell/#     repos_path: /data/git-data/repositories# 创建数据存放目录并修改权限sudo mkdir  -pv /data/git-data/gitlab-satellitessudo mkdir -pv /data/git-data/repositoriessudo chown -R git.git /data/git-data/sudo chmod 2770 /data/git-data/repositories# restart gitlab servicesudo gitlab-ctl restart</code></pre><p>启用https的安全访问：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: open gitbal https access</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2015-12-04</span></span><br><span class="line"><span class="comment">#platform: Debian 8 x86_64</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SUBJECT为CA服务的机构信息</span></span><br><span class="line">SUBJECT=<span class="string">&quot;/C=CN/ST=ChongQing/L=YuBei/O=SJKJ/OU=CA&quot;</span></span><br><span class="line"><span class="comment"># SUBJECT_GITLAB为gitlab主机的机构信息</span></span><br><span class="line">SUBJECT_GITLAB=<span class="string">&quot;/C=CN/ST=ChongQing/L=YuBei/O=SJKJ/OU=OP&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get -y install openssl</span></span><br><span class="line"><span class="comment">## 自建CA </span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your CA domain [www.example.com]: &quot;</span> DOMAIN</span><br><span class="line">sudo bash -c <span class="string">&#x27;mkdir -pv /etc/ssl/demoCA/&#123;private,newcerts&#125; &gt; /dev/null&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> /etc/ssl</span><br><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;(umask 077;openssl genrsa -out ./demoCA/private/cakey.pem 2048)&#x27;</span></span><br><span class="line"><span class="comment">#sudo bash -c &#x27;ln -s /etc/ssl/demoCA/private/cakey.pem /etc/ssl/demoCA/cakey.pem&#x27;</span></span><br><span class="line"><span class="comment"># 生成自签证书</span></span><br><span class="line"><span class="comment">#sudo bash -c &#x27;openssl req -new -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&quot;openssl req -new -subj &quot;</span><span class="variable">$&#123;SUBJECT&#125;</span>/CN=<span class="variable">$DOMAIN</span><span class="string">&quot; -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650&quot;</span></span><br><span class="line">result=$?</span><br><span class="line">sudo touch ./demoCA/index.txt</span><br><span class="line">sudo bash -c <span class="string">&quot;echo 01 &gt; ./demoCA/serial&quot;</span></span><br><span class="line">[ <span class="variable">$result</span> == 0 ] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">&quot;\033[33mCertificate services is created...\033[0m&quot;</span> || <span class="built_in">echo</span> -e <span class="string">&#x27;\033[33mCertificate services is NOT created...\033[0m&#x27;</span></span><br><span class="line"><span class="comment">##自建CA完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为gitlab主机创建存放私钥和证书的目录，这是一个固定目录，不能更改，请参考：</span></span><br><span class="line"><span class="comment"># https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#enable-https</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your gitlab domain [www.example.com]: &quot;</span> DOMAIN_GITLAB</span><br><span class="line">sudo bash -c <span class="string">&#x27;mkdir -p /etc/gitlab/ssl&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> /etc/gitlab/ssl</span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">sudo bash -c <span class="string">&quot;(umask 077;openssl genrsa -out <span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.key 1024)&quot;</span></span><br><span class="line"><span class="comment"># 生成证书签署请求</span></span><br><span class="line">sudo bash -c <span class="string">&quot;openssl req -new -subj &quot;</span><span class="string">&quot;<span class="variable">$SUBJECT_GITLAB</span>/CN=<span class="variable">$DOMAIN_GITLAB</span>&quot;</span><span class="string">&quot; -key <span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.key -out <span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.csr&quot;</span></span><br><span class="line"><span class="comment"># CA签署证书</span></span><br><span class="line"><span class="built_in">cd</span> /etc/ssl</span><br><span class="line">sudo bash -c <span class="string">&quot;openssl ca -in /etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.csr -out /etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.crt -days 3650&quot;</span></span><br><span class="line"><span class="comment"># 更改目录权限</span></span><br><span class="line">sudo chmod 700 /etc/gitlab/ssl</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">## 开启gitlab的https支持</span></span><br><span class="line">sudo vim /etc/gitlab/gitlab.rb <span class="comment">#external_url &#x27;https://$&#123;DOMAIN_GITLAB&#125;:2443&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&quot;cat &lt;&lt;- EOF &gt;&gt; /etc/gitlab/gitlab.rb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ##### open htts #####################</span></span><br><span class="line"><span class="string">    nginx[&#x27;redirect_http_to_https&#x27;] = true</span></span><br><span class="line"><span class="string">    nginx[&#x27;ssl_certificate&#x27;] = \&quot;/etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.crt\&quot;</span></span><br><span class="line"><span class="string">    nginx[&#x27;ssl_certificate_key&#x27;] = \&quot;/etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.key\&quot;</span></span><br><span class="line"><span class="string">EOF&quot;</span></span><br><span class="line"></span><br><span class="line">sudo gitlab-ctl reconfigure <span class="comment"># 使配置生效</span></span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>启用smtp邮箱功能：</p><pre><code class="language-sh">gitlab@gitlab-01:~/tools$ cat open_gitlab_smtp.sh #!/bin/bash#Program: open gitlab smtp#Author: Neal#E_mail: 419775240@qq.com#Date: 2015-12-04#platform: Debian 8 x86_64#Version 1.0#以163邮箱为例sudo bash -c &quot;cat &lt;&lt;- EOF &gt;&gt; /etc/gitlab/gitlab.rb##### open smtp #####################gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = \&quot;smtp.163.com\&quot;gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = \&quot;XXXXX@163.com\&quot;gitlab_rails['smtp_password'] = \&quot;***********\&quot;gitlab_rails['smtp_domain'] = \&quot;163.com\&quot;gitlab_rails['smtp_authentication'] = \&quot;login\&quot;gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = truegitlab_rails['gitlab_email_from'] = \&quot;XXXX@163.com\&quot;EOF&quot;sudo gitlab-ctl reconfigure</code></pre><p>end…</p>]]></content>
      
      
      <categories>
          
          <category> gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible playbook定义redis-cluster</title>
      <link href="/2016/03/28/2016-03-28-deploy-redis-cluster-use-ansible/"/>
      <url>/2016/03/28/2016-03-28-deploy-redis-cluster-use-ansible/</url>
      
        <content type="html"><![CDATA[<p>利用ansible工具完成redis-cluster环境部署主要包括两个部份，第一部份是针对linux主机一些内核参数的优化配置，第二部份是redis实例的部署。如果想了解更多关于redis的手动安装知识请参考<a href="http://zhaochj.blog.51cto.com/368705/1700892">这里</a>。这次基于ansible工具完成redis-cluster环境的搭建所涉及到的系统、软件版本如下：</p><a id="more"></a><pre><code>linux系统的： Debian 8.1 x64reids版本： 3.0.5</code></pre><h1>系统初始化</h1><p>系统初始化时的通用设置不会在此文中体现，如果想了解系统的初化时做了哪些基础的配置请参考<a href="http://zhaochj.github.io/system-initialization-use-ansible/">这里</a>，此文只是会说明要redis-cluster环境系统需要做哪些配置和优化。</p><p>redis-system 模块的目录结构如下：</p><pre><code>ansible@ansible:/tmp/playbook$ pwd/tmp/playbookansible@ansible:/tmp/playbook$ lltotal 8drwxr-xr-x 3 ansible ansible 4096 Mar 28 15:18 deployment_environmentdrwxr-xr-x 3 ansible ansible 4096 Mar 28 15:18 system-initializeansible@ansible:/tmp/playbook$ tree system-initialize/system-initialize/├── hosts├── roles│   └── redis_system│       ├── files│       │   ├── rc.local│       │   ├── redis-3.2.2.gem│       │   └── sysctl.conf│       └── tasks│           └── main.yml└── site.yml4 directories, 6 files</code></pre><p>rc.local文件增加了以下两语句，使开机关闭透明内存和执行时间同步命令：</p><pre><code>echo never > /sys/kernel/mm/transparent_hugepage/enabled/usr/sbin/ntpdate -u 192.168.0.254 > /tmp/cron_time.txt</code></pre><p>sysctl.conf文件增加了以下几个内核优化参数：</p><pre><code>#最大队列长度，应付突发的大并发连接请求net.core.somaxconn = 65535#半连接队列长度，此值受限于内存大小net.ipv4.tcp_max_syn_backlog = 20480#内存分配策略vm.overcommit_memory = 1</code></pre><p>main.yml文件内容如下：</p><h2 id="pre-code-ansible-ansible-tmp-playbook-cat-system-initialize-roles-redis-system-tasks-main-yml"><pre><code><br>ansible@ansible:/tmp/playbook$ cat system-initialize/roles/redis_system/tasks/main.yml</h2><p>#redis特有</p><ul><li><p>name: 配置sysctl.conf<br>copy: src=sysctl.conf dest=/etc backup=yes<br>when: ansible_distribution == “Debian” and ansible_distribution_major_version == “8”</p></li><li><p>name: run sysctl -p<br>shell: sysctl -p<br>when: ansible_distribution == “Debian” and ansible_distribution_major_version == “8”</p></li><li><p>name: close Transparent Huge Pages(THP)<br>shell: echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br>when: ansible_distribution == “Debian” and ansible_distribution_major_version == “8”</p></li><li><p>name: exec shell after system runed<br>copy: src=rc.local dest=/etc/ backup=yes</p></li><li><p>name: install ruby<br>apt: name=ruby-full force=yes state=present<br>when: ansible_distribution == “Debian” and ansible_distribution_major_version == “8”<br>tags: install_ruby-full</p></li><li><p>name: under the ruby install redis interface for shell script<br>copy: src=redis-3.2.2.gem dest=/tmp<br>when: ansible_distribution == “Debian” and ansible_distribution_major_version == “8”<br>tags: copy_redis322.gem</p></li><li><p>name: add a user<br>user: name=&#123;&#123; user &#125;&#125; password=&#123;&#123; passwd &#125;&#125; shell=/bin/bash<br>tags: add_user</p></li><li><p>name: rsync authorized keys<br>authorized_key:<br>key: “&#123;&#123; lookup('file', '/home/ansible/.ssh/id_rsa.pub') &#125;&#125;”<br>user: “&#123;&#123; user &#125;&#125;”<br>state: present<br>tags: rsync_key</p></li><li><p>name: change root password<br>user: name=root password=$6$2Qdfjdkfjdaleeuriereruejrieru&amp;&amp;&amp;R234(/dkfjdkf<br>tags: chg_root_passwd_production<br></code></pre></p></li></ul><p>site.yml文件内容如下：</p><pre><code>---- hosts: mod_server  remote_user: root  roles:     - redis_system</code></pre><p>hosts文件里存放了哪些主机是需要初始化的主机列表，内容如下：</p><pre><code>[mode_server]192.168.10.22192.168.10.23192.168.10.24192.168.10.25192.168.10.26192.168.10.27</code></pre><p>ansible的playbook已书写完整，那如何使用？只需要执行以下命令，并输入远程主机root用户密码就可对hosts文件中的主机列表完成系统初始化工作：</p><pre><code>ansible@ansible:/tmp/playbook/system-initialize$ ansible-playbook site.yml -i hosts -u root -kSSH password: </code></pre><h1>redis实例部署和集群配置</h1><p>dep_redis-3.0.5模块目录结构如下：</p><pre><code>ansible@ansible:/tmp/playbook$ pwd/tmp/playbookansible@ansible:/tmp/playbook$ lltotal 8drwxr-xr-x 3 ansible ansible 4096 Mar 28 15:18 deployment_environmentdrwxr-xr-x 3 ansible ansible 4096 Mar 28 15:18 system-initializeansible@ansible:/tmp/playbook$ tree deployment_environment/deployment_environment/├── hosts├── roles│   └── dep_redis-3.0.5│       ├── files│       │   └── redis-3.0.5│       │       ├── bin│       │       │   ├── config_redis_cluster.sh│       │       │   ├── redis-benchmark│       │       │   ├── redis-check-aof│       │       │   ├── redis-check-dump│       │       │   ├── redis-cli│       │       │   ├── redis-sentinel│       │       │   ├── redis-server│       │       │   └── redis-trib.rb│       │       └── redis.conf│       ├── tasks│       │   └── main.yml│       └── templates│           └── redis.conf.j2└── site.yml7 directories, 13 files</code></pre><p>main.yml内容如下：</p><h2 id="pre-code-ansible-ansible-tmp-playbook-cat-deployment-environment-roles-dep-redis-3-0-5-tasks-main-yml"><pre><code><br>ansible@ansible:/tmp/playbook$ cat deployment_environment/roles/dep_redis-3.0.5/tasks/main.yml</h2><ul><li><p>name: 远程同步redis-3.0.5二进制包<br>synchronize: src=redis-3.0.5/ dest=&#123;&#123; ansible_env.HOME &#125;&#125;/7000  checksum=yes compress=yes perms=yes<br>tags: cpoy_packages</p></li><li><p>name: 生成redis.conf文件<br>template: src=redis.conf.j2 dest=&#123;&#123; ansible_env.HOME &#125;&#125;/7000/redis.conf<br>tags: sync_redis.conf</p></li><li><p>name: 启动redis实例<br>shell: bin/redis-server redis.conf<br>args:<br>chdir: “&#123;&#123; ansible_env.HOME &#125;&#125;/7000”<br>tags: start_redis<br></code></pre></p></li></ul><p>config_redis_cluster.sh脚本内容如下：</p><pre><code>ansible@ansible:/tmp/playbook/roles$ cat deployment_environment/roles/dep_redis-3.0.5/files/redis-3.0.5/bin/config_redis_cluster.sh #!/bin/bash#Program: config_redis_cluster.sh#Author: Neal#E_mail: 419775240@qq.com#Date: 2016-2-23#Version 1.0#安装ruby下的redis接口，配置cluster-redis# 本脚本用root用户运行#本地redis.gemruby_redis=/tmp/redis-3.2.2.gem#集群节点信息，请根据实际情况进行修改node_0=192.168.x.xport_0=7000node_1=192.168.x.xport_1=7000node_2=192.168.x.xport_2=7000node_3=192.168.x.xport_3=7000node_4=192.168.x.xport_4=7000node_5=192.168.x.xport_5=7000#安装redis-3.2.2.gemcheck_result=`/usr/bin/gem list --local | grep redis` > /dev/null 2>&1if [[ $&#123;check_result&#125; == "redis (3.2.2)" ]];then    echo "redis 接口已存在，不需要安装"else    if [ -f $&#123;ruby_redis&#125; ];then        /usr/bin/gem install --local $&#123;ruby_redis&#125; > /dev/null 2>&1        [ $? -eq 0 ] && echo "ruby下的redis接口安装成功" || echo "ruby下的redis安装出现问题，请检查"    else        echo "$&#123;ruby_redis&#125;文件不存在"    fifi#配置集群/bin/su - redis -c "/home/redis/7000/bin/redis-trib.rb create --replicas 1 $&#123;node_0&#125;:$&#123;port_0&#125; $&#123;node_1&#125;:$&#123;port_1&#125; $&#123;node_2&#125;:$&#123;port_2&#125; $&#123;node_3&#125;:$&#123;port_3&#125; $&#123;node_4&#125;:$&#123;port_4&#125; $&#123;node_5&#125;:$&#123;port_5&#125;"</code></pre><p><strong>注意</strong></p><blockquote><p>config_redis_cluster.sh脚本完成ruby环境下redis接口的安装及redis cluster的创建，此脚本必须由root用户运行。</p></blockquote><p>redis.conf.j2文件是一个模板文件，此文件中启用的配置参数如下：</p><pre><code>ansible@ansible:/tmp/playbook$ egrep -v "#|^$" deployment_environment/roles/dep_redis-3.0.5/templates/redis.conf.j2daemonize yespidfile /var/run/redis7000.pidport 7000tcp-backlog 511bind &#123;&#123; ansible_eth0.ipv4.address &#125;&#125;timeout 0tcp-keepalive 150loglevel noticelogfile "redis.log"databases 16save ""stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir ./slave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay norepl-backlog-size 512mbslave-priority 100maxclients 60000appendonly yesappendfilename "appendonly.aof"appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 60000cluster-require-full-coverage noslowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events ""hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-entries 512list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 0 0 0client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes</code></pre><p>site.yml文件内容如下：</p><pre><code>- hosts: mod_server  remote_user: '&#123;&#123; user &#125;&#125;'  roles:     - dep_redis-3.0.5</code></pre><p>此处的hosts文件的格式与_系统初始化_时一样，</p><p>至此，redis实例的部署脚本准备妥当，那如何使用？命令如下：</p><pre><code>ansible@ansible:/tmp/playbook/deployment_environment$ pwd/tmp/playbook/deployment_environmentansible@ansible:/tmp/playbook/deployment_environment$ ansible-playbook site.yml -i hosts -e "user=redis"</code></pre><p>到这里，各个节点上的redis的实例应该已启动起来了，并监听在7000端口，此时各节点的redis之间没有任何关系，现在需要修改 <em>config_redis_cluster.sh</em> 脚本文件，把各个节点的IP地址修改成实际节点的IP地址，并切换到root用户运行此脚本完成redis cluster集群配置。</p>]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible编写系统初始化playbook</title>
      <link href="/2016/03/24/2016-03-24-system-initialization-use-ansible/"/>
      <url>/2016/03/24/2016-03-24-system-initialization-use-ansible/</url>
      
        <content type="html"><![CDATA[<p>刚到公司时，从基础组同事那里拿到的虚拟主机的系统环境并不符合应用的要求，这时就需要应用运维的同事安装一些软件和配置一些环境变量，而这些事情往往是反复操作，极大的浪费时间。这里介绍使用ansible这个神器来解决系统初始化的操作。</p><a id="more"></a><h1>目的</h1><p>系统初始化工作是一个简单、繁复的工作，从基础组得到的虚拟主机只是一个最最基础的系统环境，有许多安装包和环境所需要的配置都没有进行相应的设置，应用运维组的同事<br>需要针对虚拟主机担任角色不同而需要进行一此初始化工作，为了让应用组人员从完全人肉方式初始化系统中解脱出来，所以用ansible工具编写playbook来完成系统初始化工作。提<br>高系统初始化效率，减少主机上线时间，减少因人肉初始化系统带的操作失误。</p><h1>主机角色及任务梳理</h1><p>实际环境中因主机担任的角色不同而所需要初始化的操作也有所不同，需要整理出几个大类的主机角色，以及各种主机角色所在做的操作，关联到ansible上就所要做的就是task。</p><h2 id="主机角色分类">主机角色分类</h2><pre><code>1. 纯JDK运行环境2. Tomcat运行环境3. redis-cluster集群环境4. Nginx环境5. HAproxy环境6. lvs环境......</code></pre><h2 id="主机所需执行task">主机所需执行task</h2><p>根据主机所担任的角色不同所需要执行的task也有所不同，而有一些task是需要在所有主机执行。</p><ul><li><strong>基础task</strong></li></ul><p>基础stsk是所有主机都需要执行的task，task整理如下：</p><pre><code>1. 禁用ssh登陆DNS解析2. 启用开机执行时间同步3. 配置apt源4. 安装基础软件包5. 时间同步设置成crontab6. 执行计划任务时启用日志功能7. 设置主机网关（若无就设置网关）8. 设置常用命令别名9. 设置主机DNS10. 修改主机openfile11. 增加业务用户，设置密码，建立无密码验证12. 修改root用户密码......</code></pre><ul><li><strong>JDK运行环境所执行task</strong></li></ul><p>JDK环境只需要安装JDK包和配置必要的JAVA环境变量即可，针对JAVA的环境变量不会去编辑 <code>/etc/profile</code> 这个系统级的环境文件，只修改用户家目录下的 <code>.bashrc</code> 和 <code>.bash_profile</code> 文件。所执行task整理如下：</p><pre><code>1. 拷贝JAVA二进制程序到远程主机的用户家目录2. 拷贝.bashrc和.bash_profile文件到用户家目录</code></pre><ul><li><strong>Tomcat运行环境执行task</strong></li></ul><p>Tomcat环境除了需要JDK外，还需要上传一个Tomcat包到远程主机，再配置Tomcat相应的环境变量，在配置环境变量时同样不会去改变系统级的环境变量，只是修改<code>.bashrc</code>和<code>.bash_profile</code>用户级的环境变量文件。需要执行的task整理如下：</p> <pre><code>1. 拷贝JAVA二进制包到远程主机的用户家目录2. 拷贝Tomcat二进制包到远程主机的用户家目录3. 拷贝.bashrc和.bash_profile文件到用户家目录4. 根据远程主机的内存大小来配置catalina.sh文件中的JVM的内存大小......</code></pre><ul><li><strong>redis-cluster集群环境需执行task</strong></li></ul><p>redis cluster集群基于3.0.5编译而成，redis cluster手动编译配置过程请参考<a href="http://zhaochj.blog.51cto.com/368705/1700892">这里</a>。task整理如下：</p><pre><code>1. 拷贝redis二进制包到远程主机2. 生成redis.conf文件3. 启动redis实例... ...</code></pre><ul><li><strong>Nginx环境需执行task</strong></li></ul><p>Nginx环境的部署采用自编译后的二进制包，编译过程请参考<a href="http://zhaochj.github.io/make-nginx-template/">这里</a>，需要执行的task大致如下：</p><pre><code>1. 安装依赖包2. 把已编译好的二进制包拷贝到目标主机并解压到相应目录3. 增加运行nginx的用户4. 增加systemctl方式管理的nginx.service脚本5. 提供样例配置文件6. 配置nginx日志滚动7. 提供常用的网络优化参数8. 导出nginx的二进制文件9. 开启nginx配置文件的语法高亮......</code></pre><ul><li><strong>HAproxy环境所需执行task</strong></li></ul><p>HAproxy的环境部署直接采用apt-get的安装，版本是1.5.8，需要执行的task整理如下：</p><pre><code>1. 安装haproxy软件包2. 提供样例配置文件3. 开启haproxy配置文件的语法高亮4. 开启haproxy的日志功能......</code></pre><p>上边把生产环境中常见的环境罗列出来，下边以几个实际的例子说明ansible怎样把这些操作关联到一个个task上，这里恐怕不能涉及到所有的操作，只是列举一些常见的或者是容易出错的模块操作。</p><h1>举例</h1><p>ansible的所有操作都是基于模块，在使用ansible时一定要建立起这个概念，比如你要新建一个文件或目录是使用file模块，拷贝一个文件到远程主机可使用copy模块或synchronize模块，要执行一个命令是使用shell模块或raw模块等等。</p><h2 id="基础task执行示例">基础task执行示例</h2><p>以安装基础性的软件包为例，在上代码前先来说明一下ansible模块的目录组成结构，ansible把多个需要执行的task编排组织起来就组织成ansible的playbook，一个playbook的格式如下：</p><pre><code>---- hosts: webservers  vars:    http_port: 80    max_clients: 200  remote_user: root  tasks:  - name: ensure apache is at the latest version    yum: name=httpd state=latest  - name: write the apache config file    template: src=/srv/httpd.j2 dest=/etc/httpd.conf    notify:    - restart apache  - name: ensure apache is running (and enable it at boot)    service: name=httpd state=started enabled=yes  handlers:    - name: restart apache      service: name=httpd state=restarted</code></pre><p>把上边的代码保存为一个以<code>.yml</code>或<code>.yaml</code>结尾的文件就可以完成软件安装等工作。以上代码来源<a href="http://docs.ansible.com/ansible/playbooks_intro.html">这里</a>。</p><p>简单的编写一个playbook就能胜任许多工作，但andible的roles特性把playbook变得更为灵活，roles使ansible适应更为复杂的环境。要使用ansible的roles特性你得要遵守它的目录组成方式，类似如下：</p><pre><code>ansible@ansible:~/playbooks/base/basic_setings_root$ tree ..├── hosts├── roles│   ├── add_route│   │   └── tasks│   │       └── main.yml│   ├── chg_root_passwd│   │   └── tasks│   │       └── main.yml│   ├── cron_service│   │   └── tasks│   │       └── main.yml│   ├── cron_timesync│   │   └── tasks│   │       └── main.yml│   └── install_pkg│       └── tasks│           └── main.yml└── site.yml</code></pre><p>更详细关于anisble roles的说明请参考<a href="http://docs.ansible.com/ansible/playbooks_roles.html">这里</a></p><p>下边我们就编写一个roles来完成软件包的安装，操作如下：</p><pre><code>ansible@ansible:/tmp/playbook/install_pkg$ pwd/tmp/playbook/install_pkgansible@ansible:/tmp/playbook/install_pkg$ mkdir -pv roles/install_pkg/&#123;task,files&#125;mkdir: created directory ‘roles’mkdir: created directory ‘roles/install_pkg’mkdir: created directory ‘roles/install_pkg/task’mkdir: created directory ‘roles/install_pkg/files’ansible@ansible:/tmp/playbook/install_pkg$ touch site.ymlansible@ansible:/tmp/playbook/install_pkg$ lsroles  site.ymlansible@ansible:/tmp/playbook/install_pkg$ tree ..├── roles│   └── install_pkg│       ├── files│       └── task└── site.yml4 directories, 1 fileansible@ansible:/tmp/playbook/install_pkg$ vim roles/install_pkg/task/main.yml---- name: install some pkg  apt: name=&#123;&#123; items &#125;&#125; state=present  with_item:     - vim     - ntpdate  tags: ins_pkgansible@ansible:/tmp/playbook/install_pkg$ vim site.yml---- hosts: server  remote_user: root  roles:    - install_pkgansible@ansible:/tmp/playbook/install_pkg$ vim hosts  [server]172.31.11.71# 执行以下命令就可以执行我们定义的taskansible@ansible:/tmp/playbook/install_pkg$ ansible-playbook site.yml -i hosts -kSSH password: PLAY ***************************************************************************TASK [setup] *******************************************************************ok: [172.31.11.71]PLAY RECAP *********************************************************************172.31.11.71               : ok=1    changed=0    unreachable=0    failed=0 # 我这里的目标主机上已安装过vim和ntpdate两个软件包，所以输出状态changed是0  </code></pre><p>如果在使用ansible时不熟悉命令,可以用<code>ansible --help</code>查看ansible命令的帮助信息，用<code>ansible-playbook --help</code>查看ansible-playbook命令的帮助信息，用<code>ansible-doc module-name</code>来查看某个模块的使用帮助信息，<code>ansible-doc -l</code>可以列出可用的模块。善于使用这些命令可以让你更快熟悉ansible的使用。</p><h2 id="nginx部署">nginx部署</h2><p>在<a href="http://zhaochj.github.io/make-nginx-template/">nginx模板制作</a>中讲述了源码编译安装一个nginx并导入几个优秀的第三方模块，后期的批量部署会以此为模板，利用ansible工具部署nginx环境。</p><p>同样采用roles的方式来组织部署nginx环境的这个roles，目录结构如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx$ pwd/tmp/playbook/dep_nginxansible@ansible:/tmp/playbook/dep_nginx$ lshosts  roles  site.ymlansible@ansible:/tmp/playbook/dep_nginx$ tree ..├── hosts├── roles│   └── dep_nginx                     # 角色名称│       ├── files│       │   ├── nginx                 # 日志滚动时的配置文件│       │   ├── nginx18.sh            # 导出nginx二进制时配置文件│       │   ├── nginx18.tar.gz        # 打包后的二进制包│       │   ├── nginx.service         # systemctl风格的启动脚本│       │   └── sysctl.conf           # 网络优化参数配置文件│       ├── tasks│       │   └── main.yml              # 任务执行的主文件│       └── vars│           └── main.yml              # 存放变量的主文件└── site.yml                          # ansible-playbook的入口文件5 directories, 9 files</code></pre><p>nginx文件内容如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx/roles/dep_nginx/files$ cat nginx/usr/local/nginx18/logs/*.log &#123;        daily        missingok        rotate 30        compress        delaycompress        notifempty        create 640 nginx staff        sharedscripts        postrotate                [ -f /var/run/nginx18.pid ] && kill -USR1 `cat /var/run/nginx18.pid`        endscript&#125;</code></pre><p>nginx18.sh文件如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx/roles/dep_nginx/files$ cat nginx18.sh export PATH=/usr/local/nginx18/sbin:$PATH</code></pre><p>nginx.service文件内容如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx/roles/dep_nginx/files$ cat nginx.service [Unit]Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/After=network.target[Service]Type=forkingPIDFile=/var/run/nginx18.pidExecStartPre=/usr/local/nginx18/sbin/nginx -t -c /usr/local/nginx18/conf/nginx.confExecStart=/usr/local/nginx18/sbin/nginx -c /usr/local/nginx18/conf/nginx.confExecReload=/usr/local/nginx18/sbin/nginx -s reloadExecStop=/usr/local/nginx18/sbin/nginx -s stopTimeoutStopSec=5KillMode=mixed[Install]WantedBy=multi-user.target</code></pre><p>sysctl.conf文件增加的优化参数如下：</p><pre><code># 调高系统的 IP 以及端口数据限制，从可以接受更多的连接net.ipv4.ip_local_port_range = 1500 65400#timewait 的数量net.ipv4.tcp_max_tw_buckets = 10000#关闭timewait 快速回收。TIME_WAIT状态的socket是否被快速回收是由tcp_tw_recycle和tcp_timestamps两个配置项共同决定的，#tcp_timestamps默认一般就是开启的net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 0#开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接net.ipv4.tcp_tw_reuse = 1#开启SYN Cookies，当出现SYN 等待队列溢出时，启用cookies 来处理。net.ipv4.tcp_syncookies = 1#net.ipv4.tcp_max_syn_backlog参数决定了SYN_RECV状态队列的数量，一般默认值为512或者1024，即超过这个数量，系统将不再接受新的TCP连接请#求，一定程度上可以防止系统资源耗尽。可根据情况增加该值以接受更多的连接请求。#这个就是你说的tcp支持的队列数，tcp 连接超过这个队列长度，就不允许连接.net.ipv4.tcp_max_syn_backlog = 10240#web 应用中listen 函数的backlog 默认会给我们内核参数的net.core.somaxconn 限制到128，而nginx 定义的NGX_LISTEN_BACKLOG 默认为511，所以有必要调整这个值。net.core.somaxconn = 2048#当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2小时net.ipv4.tcp_keepalive_time = 30#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。net.ipv4.tcp_fin_timeout = 20</code></pre><p>tasks目录下的main.yml文件内容如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx/roles/dep_nginx$ cat tasks/main.yml---- name: 安装nginx依赖包  apt: name=&#123;&#123; item &#125;&#125; state=present  with_items:       - openssl       - libssl1.0.0       - libssl-dev       - zlib1g       - libpcre3        - libpcre3-dev  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: depend_pkg- name: copy nginx18.tar.gz to remote host  synchronize: src=nginx18.tar.gz dest=/usr/local checksum=yes compress=yes perms=yes  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: copy_nginx18- name: Unpack the nginx18.tar.gz  shell: tar xf nginx18.tar.gz  args:    chdir: "&#123;&#123; nginx_work_dir &#125;&#125;"  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: unpack_nginx- name: 创建临时目录  file: path=/var/tmp/nginx18/&#123;&#123; item &#125;&#125; group=root owner=root mode=0755 state=directory  with_items:       - proxy       - fastcgi       - uwsgi       - scgi  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: create_dir- name: add nginx user  user: name=nginx shell=/usr/sbin/nologin state=present  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: adduser_nginx- name: export binary file  copy: src=nginx18.sh dest=/etc/profile.d group=root owner=root mode=0644  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: export_binary- name: systemctl way manage nginx  copy: src=nginx.service dest=/lib/systemd/system group=root owner=root mode=0644  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: nginx.service- name: nginx.conf syntax highlighting  copy: src=.vim dest=&#123;&#123; ansible_env.HOME &#125;&#125; group=root owner=root mode=0644  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: nginx.vim- name: 配置日志滚动，默认保留30天的日志备份  copy: src=nginx dest=/etc/logrotate.d group=root owner=root mode=0644  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: log_rotate- name: copy sysctl.conf,网络优化  copy: src=sysctl.conf dest=/etc group=root owner=root mode=0644 backup=yes  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: copy_sysctl.conf- name: exec sysctl -p  shell: /sbin/sysctl -p  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: reload_sysctl.conf  - name: nginx service power up  service: name=nginx.service state=started enabled=yes  when: ansible_distribution == "Debian" and ansible_distribution_major_version == "8"  tags: start_nginx</code></pre><p>vars目录下的main.yml文件内容如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx/roles/dep_nginx$ cat vars/main.yml---nginx_work_dir: /usr/local</code></pre><p>site.yml文件内容如下：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx$ cat site.yml---- hosts: server  remote_user: root  roles:        - dep_nginx</code></pre><p>hosts文件的内容类似这样：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx$ cat hosts [server]192.168.0.67192.168.0.68</code></pre><p>hosts文件是的主机就是所要部署nginx环境的主。</p><p>运行这个以roles组织起的anisble-playbook，只需要运行如下命令，输入远程主机的root密码：</p><pre><code>ansible@ansible:/tmp/playbook/dep_nginx$ ansible-playbook site.yml -i hosts -k SSH password: </code></pre><h1>总结</h1><p>示例就列举上边两个，各种环境下的需求各样，不可能面面俱到。利用ansible的roles特性能完成许多任务，要想熟练使用ansible这个工具只有多练习，善于运用anisble的帮助信息。</p>]]></content>
      
      
      <categories>
          
          <category> ansible playbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量替换文件中指定字符串</title>
      <link href="/2016/03/18/2016-03-18-text-process/"/>
      <url>/2016/03/18/2016-03-18-text-process/</url>
      
        <content type="html"><![CDATA[<p>一个文本处理的实际需求，用shell和python分别完成</p><a id="more"></a><h1>业务需求</h1><p>现有两个文件，文件1里有两列，第一列为字符串A，第二列为字符串B；文件2中有大量的sql语句，单个文件<br>上百兆，现需要把文件1中的第一列的每行的字符串A拿到文件2中去查找，如果能查找到则替换为这一行中的字符<br>串B。</p><p>两个文件内的内容大致如下：<br>　　<br><img src="/images/2016-03-18-text-process-01.jpg" alt=""></p><h1>shell实现</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: process.sh</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2016-3.16</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"></span><br><span class="line">source_file=source.txt.bak</span><br><span class="line">chang_file=chang_file.txt.bak</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line;<span class="keyword">do</span></span><br><span class="line">    raw=`<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">    now=`<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">    process_now=`<span class="built_in">echo</span> <span class="variable">$&#123;now%^M&#125;</span>`   <span class="comment">#处理now变量最后有^M符号,此符号是“Ctrl+v + Ctrl+m”组合键的结果</span></span><br><span class="line">    grep <span class="string">&quot;<span class="variable">$raw</span>&quot;</span> <span class="variable">$&#123;source_file&#125;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">        <span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;已匹配到<span class="variable">$raw</span>，会更换为<span class="variable">$process_now</span>&quot;</span></span><br><span class="line">            sed -i <span class="string">&quot;s/<span class="variable">$&#123;raw&#125;</span>/<span class="variable">$&#123;process_now&#125;</span>/g&quot;</span> <span class="variable">$&#123;source_file&#125;</span> &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$&#123;chang_file&#125;</span></span><br></pre></td></tr></table></figure><h1>python实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/home/ansible/.pyenv/versions/python_3.5.1/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_source_file</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    read the source file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;source.txt.bak&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        source_file = f.read()</span><br><span class="line">    <span class="keyword">return</span> source_file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(x[<span class="number">0</span>],x[<span class="number">1</span>],y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rw</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    write str to new file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;result.txt&#x27;</span>,mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> chg:</span><br><span class="line">        chg.write(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    str_source_file = read_source_file()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;chang_file.txt.bak&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            line_list = line.split()</span><br><span class="line">            str_source_file = replace(line_list,str_source_file)</span><br><span class="line">    rw(str_source_file)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文本处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell，python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python函数</title>
      <link href="/2016/03/17/2016-03-17-python-learn-function/"/>
      <url>/2016/03/17/2016-03-17-python-learn-function/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之函数</p><a id="more"></a><h1>函数</h1><p>个人理解，函数是为了实现特定功能而编写在一起的代码语句，这些代码组织成了代码块，并给予这个代码块一个名称，以便在其他地方调用。<br>那为什么要使用函数呢？使用函数是降低编程的难度，函数能够把大的问题分解成一个个小的问题，只要小的问题解决了那大的问题也迎刃而解；再者是为了能让代码重用，把在编程中经常用到的代码组织成函数，在当需要使用时直接调用函数，而不必再去编写相应的代码。</p><ul><li>怎样定义一个函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 函数以def开头，后接函数名，紧接着一个小括号，小括号内是传入函数的参数;</span><br><span class="line">2. 函数定义后的第一行可以选择性的加入函数的说明性文档，说明文档若是一行用一对双引号，如果会换行，那用三对双引号或三对单引号；</span><br><span class="line">3. 函数最后一般会返回一个结果，若不返回结果那会返回一个None值。</span><br><span class="line">def function_name(parameters):</span><br><span class="line">    &quot;&quot;&quot;函数说明文档&quot;&quot;&quot;</span><br><span class="line">    function_suite</span><br><span class="line">    return [expression]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;求一个数的绝对值&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x,(int,float)):         <span class="comment">#做传入函数的参数做类型判断，只有整形或浮点型的数才能求绝对值</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">print(<span class="string">&#x27;这是&#123;0&#125;,的说明性文档：&#123;1&#125;&#x27;</span>.format(my_abs.__name__,my_abs.__doc__))    </span><br></pre></td></tr></table></figure><pre><code>这是my_abs,的说明性文档：求一个数的绝对值</code></pre><ul><li>调用函数</li></ul><p>直接键入“functionname([patameters])”即可调用函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_abs(<span class="number">29</span>)</span><br></pre></td></tr></table></figure><pre><code>29</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_abs(<span class="number">-23.8</span>)</span><br></pre></td></tr></table></figure><pre><code>23.8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_abs(<span class="string">&#x27;ab&#x27;</span>)   <span class="comment">#当传入的参数不能通过类型检查时触发raise异常语句</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-20-3c363f4bf733&gt; in &lt;module&gt;()----&gt; 1 my_abs('ab')&lt;ipython-input-17-90b4c1d5d37c&gt; in my_abs(x)      2     &quot;求一个数的绝对值&quot;      3     if not isinstance(x,(int,float)):         #做传入函数的参数做类型判断，只有整形或浮点型的数才能求绝对值----&gt; 4         raise TypeError('bad type')      5     if x &gt;= 0:      6         return xTypeError: bad type</code></pre><ul><li>函数的参数</li></ul><p>在python中函数的定义非常简单，只要确定函数的名称，参数的名称，这样函数的定义就完成了，而调用者只需要知道怎样向这个函数传递参数以及此函数返回什么样的值就Ok了，而函数体调用都无需了解。</p><p>函数中的参数有多种，有必选参数、命名参数、默认参数、可变参数和关键字参数。</p><ol><li>必选参数</li></ol><p>函数的必选参数要求在调用函数时一定得按照在定义函数时的参数位置传入，传入的参数数量也一定要与定义时参数的数量相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_abs(<span class="number">-39</span>)   <span class="comment">#上边定义的my_abs函数就定义了一个必选参数x，在调用时必须正确的传入一个参数</span></span><br></pre></td></tr></table></figure><pre><code>39</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_abs(<span class="number">23</span>,<span class="number">-3</span>)   <span class="comment">#当传入的参数数量与定义的不同时会抛出异常</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-25-0af413d28136&gt; in &lt;module&gt;()----&gt; 1 my_abs(23,-3)TypeError: my_abs() takes 1 positional argument but 2 were given</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;你的姓名是&#123;0&#125;,你的年龄是&#123;1&#125;&#x27;</span>.format(name,age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info(<span class="string">&#x27;Neal&#x27;</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><pre><code>'你的姓名是Neal,你的年龄是30'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info(<span class="number">30</span>,<span class="string">&#x27;Neal&#x27;</span>)   <span class="comment">#当实参传入的位置发生改变后，得到了如下结果</span></span><br></pre></td></tr></table></figure><pre><code>'你的姓名是30,你的年龄是Neal'</code></pre><p>2．命名参数</p><p>当函数调用时用参数的名字确定传入的参数值，参数名与参数值间用等号连接，命名参数不再像必选参数一样对实参传入的位置敏感。以上边的定义的info函数来说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info(age=<span class="number">30</span>,name=<span class="string">&#x27;Neal&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'你的姓名是Neal,你的年龄是30'</code></pre><p>3.　默认参数</p><p>所谓默认参数，就是在调用函数时参数的值没有显示的传入时，那参数就被赋予一个默认的值，如果参数被赋予了一个值时，那就用传入的值赋予此参数。默认参数在定义函数时以“参数名 = 参数值”的方式定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infomations</span>(<span class="params">name,age,add = <span class="string">&#x27;ChongQing&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;你的姓名是&#123;0&#125;,你好年龄是&#123;1&#125;,你的家庭住址是：&#123;2&#125;&#x27;</span>.format(name,age,add)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infomations(<span class="string">&#x27;Neal&#x27;</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><pre><code>'你的姓名是Neal,你好年龄是30,你的家庭住址是：ChongQing'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infomations(<span class="string">&#x27;Neal&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;BeiJin&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>'你的姓名是Neal,你好年龄是30,你的家庭住址是：BeiJin'</code></pre><p>3．可变参数</p><p>可变参数，从字面上理解就是传递给函数的参数的个数是变化的，可以是1个、2个或多个。在不使用可变参数来定义时要想实现类似的功能就需要向参数传递时传递的主是一个list或tuple。</p><p>定义一个可变参数只需要在必选参数前加上*号即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">var</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])      <span class="comment">#当上边定义的var函数是需要传入一个必选参数时，以列表的形式传入参数</span></span><br></pre></td></tr></table></figure><pre><code>1234</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vars</span>(<span class="params">*n</span>):</span></span><br><span class="line">    print(type(n))</span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)     <span class="comment">#函数中的可变参数接收到传递的实参时，都会把实参组装成一个元组</span></span><br></pre></td></tr></table></figure><pre><code>&lt;class 'tuple'&gt;(1, 2, 3, 4)1234</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(<span class="number">22</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)   <span class="comment">#当n是一个可变参数时，调用函数传入的参数个数是可变的</span></span><br></pre></td></tr></table></figure><pre><code>&lt;class 'tuple'&gt;(22, 'a', 'b')22ab</code></pre><p>4.　关键字参数</p><p>可变参数是在必须参数前加了一个星号，关键字参数则是加两个星号，关键参数在函数内部被组装成一个字典。而调用方式与“命名的参数”相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_var</span>(<span class="params">**keyword</span>):</span></span><br><span class="line">    print(keyword)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_var(name=<span class="string">&#x27;Neal&#x27;</span>,age=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><pre><code>&#123;'age': 30, 'name': 'Neal'&#125;</code></pre><p>5．参数的混合使用</p><p>在实际使用中函数的各种参数可能会混合使用，当混合使用时，在定义函数的参数时是有顺序的，从左到右依次是：必选参数–默认参数–可选参数–关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blend</span>(<span class="params">name,gender=<span class="string">&#x27;F&#x27;</span>,*args,**kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;你的姓名是&#123;n&#125;,你的姓别是&#123;g&#125;，你的年龄是&#123;e&#125;，你的地址是&#123;a&#125;&#x27;</span>.format(n=name,g=gender,e=args,a=kwargs))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blend(<span class="string">&#x27;Neal&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="number">30</span>,add=<span class="string">&#x27;ChonQing&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>你的姓名是Neal,你的姓别是M，你的年龄是(30,)，你的地址是&#123;'add': 'ChonQing'&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blend(<span class="string">&#x27;Neal&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>你的姓名是Neal,你的姓别是F，你的年龄是()，你的地址是&#123;&#125;</code></pre><ul><li>匿名函数</li></ul><p>匿名函数即没有函数名称的函数，用lambda来表示，lambda函数是一个表达式。</p><p>语法如下：</p><p>lambda [arg1 [,arg2,…argn]]:expression</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x,(int,float)) <span class="keyword">and</span> isinstance(y,(int,float)):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad type&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">5</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure><pre><code>14</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="keyword">lambda</span> x,y: x + y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">3</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure><pre><code>11</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">2</span>,<span class="string">&#x27;r&#x27;</span>)   <span class="comment">#lambda函数在python中使用有局限性，这里怎么才能检查传入参数是整形或是浮点型呢？</span></span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-78-0d64ee959b5f&gt; in &lt;module&gt;()----&gt; 1 sum(2,'r')&lt;ipython-input-75-8a59f5f93a03&gt; in &lt;lambda&gt;(x, y)----&gt; 1 sum = lambda x,y: x + yTypeError: unsupported operand type(s) for +: 'int' and 'str'</code></pre>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的列表与元组</title>
      <link href="/2016/03/16/2016-03-16-python-learn-list-and-tuple/"/>
      <url>/2016/03/16/2016-03-16-python-learn-list-and-tuple/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之列表和元组。</p><a id="more"></a><h1>List</h1><p>序列是Python中最基本的数据结构，列表是一种序列。列表是python的一种内置的数据类型，是一种容器类，list是一种任意对象的有序集合，通过索引访问其中的元素，可以随时添加和删除其中的元素，可以任意嵌套(元素可以是另一个列表或元组等)的一种异构类型(各个元素类型可不同)，所以是一种可变对象。<br>序列都可以进行的操作包括索引，切片，加，乘，检查成员，此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p><ul><li>创建列表</li></ul><p>创建一个列表，只要把逗号分隔的不同的各个元素用中括号括起来即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;Neal&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;Cora&#x27;</span>]</span><br><span class="line">list3 = [<span class="string">&#x27;Neal&#x27;</span>,<span class="string">&#x27;Hello&#x27;</span>,<span class="number">30</span>]   <span class="comment">#元素的类型可以不同</span></span><br><span class="line">list4 = [<span class="string">&#x27;a&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">&#x27;b&#x27;</span>]   <span class="comment">#列表中可以嵌套</span></span><br></pre></td></tr></table></figure><ul><li>访问列表中的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list2</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cora&#x27;</span>]</span><br><span class="line">list2[<span class="number">0</span>]   <span class="comment">#以索引访问列表中的元素</span></span><br><span class="line">    <span class="string">&#x27;Neal&#x27;</span></span><br><span class="line">list2[<span class="number">2</span>]</span><br><span class="line">    <span class="string">&#x27;Cora&#x27;</span></span><br><span class="line">list2[<span class="number">3</span>]    <span class="comment">#索引值超出范围时抛出IndexError异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    IndexError                                Traceback (most recent call last)</span><br><span class="line"></span><br><span class="line">    &lt;ipython-input<span class="number">-10</span><span class="number">-3737e39</span>fc5b9&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">    ----&gt; 1 list2[3]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    IndexError: list index out of range</span><br></pre></td></tr></table></figure><ul><li>修改列表中的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list3</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="number">30</span>]</span><br><span class="line">list3[<span class="number">2</span>] = <span class="number">40</span></span><br><span class="line">list3</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure><ul><li>删除元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list2</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cora&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> list2[<span class="number">0</span>]  <span class="comment">#del操作是对列表原处修改</span></span><br><span class="line">list2</span><br><span class="line">    [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cora&#x27;</span>]</span><br><span class="line">list2.pop(<span class="number">1</span>)  <span class="comment"># pop方法表示弹出指定索引的元素，此方法回返回弹出的元素</span></span><br><span class="line">    <span class="string">&#x27;Cora&#x27;</span></span><br><span class="line">list2</span><br><span class="line">    [<span class="string">&#x27;Tom&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>增加元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list3</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="number">30</span>]</span><br><span class="line">list3.insert(<span class="number">1</span>,<span class="string">&#x27;Tome&#x27;</span>)   <span class="comment"># insert操作在指定索引值前插入元素</span></span><br><span class="line">list3</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Tome&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="number">30</span>]</span><br><span class="line">list3.append(<span class="number">100</span>)    <span class="comment">#append方法在列表最后增加元素</span></span><br><span class="line">list3</span><br><span class="line">    [<span class="string">&#x27;Neal&#x27;</span>, <span class="string">&#x27;Tome&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="number">30</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><ul><li>列表切片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list1[<span class="number">0</span>:]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list1[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 取得从索引1开始到3的元素，但不包括索引为3的元素，顾头不顾尾</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list1[<span class="number">-1</span>]</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">list1[<span class="number">-4</span>:<span class="number">-1</span>]</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list1   <span class="comment">#列表的切片操作不会修改列表本身</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>列表操作符号</li></ul><p>列表可以进行+、*运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list2</span><br><span class="line">    [<span class="string">&#x27;Tom&#x27;</span>]</span><br><span class="line">list1 + list2</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;Tom&#x27;</span>]</span><br><span class="line">list22 = list2 * <span class="number">4</span></span><br><span class="line">print(list22)</span><br><span class="line">    [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>]</span><br><span class="line">id(list22[<span class="number">0</span>])</span><br><span class="line">    <span class="number">140193645244688</span></span><br><span class="line">id(list22[<span class="number">1</span>])</span><br><span class="line">    <span class="number">140193645244688</span></span><br><span class="line">id(list22[<span class="number">2</span>])   <span class="comment">#通过*号相乘得到列表中各元素都是指向同一内存地址</span></span><br><span class="line">    <span class="number">140193645244688</span></span><br></pre></td></tr></table></figure><ul><li>成员判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> list1</span><br><span class="line">    <span class="literal">True</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">in</span> list1</span><br><span class="line">    <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>常用函数和方法</li></ul><ol><li>函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">len(list1)   <span class="comment">#计算列表的元素个数</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">max(list1)  <span class="comment">#返回列表中元素的最大值</span></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">min(list1)   <span class="comment">#返回列表中元素的最小值</span></span><br><span class="line">    <span class="number">1</span></span><br></pre></td></tr></table></figure><p>2.方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list11 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">list1.append(list11)  <span class="comment">#append把list11当作一个元素附加到list1上</span></span><br><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">list1.extend(list11)   <span class="comment">#extend方法把list11中的元素附加到list1上</span></span><br><span class="line">list1</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">list1.sort()   <span class="comment">#sort方法对列表进行排序，前提是列表中的元素类型相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    TypeError                                 Traceback (most recent call last)</span><br><span class="line"></span><br><span class="line">    &lt;ipython-input<span class="number">-83</span><span class="number">-05e4223</span>c8627&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">    ----&gt; 1 list1.sort()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    TypeError: unorderable types: list() &lt; int()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">list1.sort()</span><br><span class="line">list1   <span class="comment">#sort方法是对列表进行原处修改</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">list1.reverse()   <span class="comment">#reverse方法对元素进行反转</span></span><br><span class="line">list1</span><br><span class="line">    [<span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1>Tuple</h1><p>元组与list类似，是任意对象的有序集合，通过索引访问其中的元素，元素支持异构，但一旦元组创建后，里面的元素不可更改，是不可变对象，即没有像list那样有append()这样类似的方法来对元组进行修改。</p><ul><li>元组定义与获取元组</li></ul><p>元组的定义与列表几乎一样，只是把列表的[]改为()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = (<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">tuple1</span><br><span class="line">    (<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">tuple2 = <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="string">&#x27;Tom&#x27;</span>  <span class="comment">#这样也可以定义一个元组</span></span><br><span class="line">tuple2</span><br><span class="line">    (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">tuple3 = (<span class="string">&#x27;one&#x27;</span>,)   <span class="comment">#定义只有一个元素的元组时在元素后要跟上一个逗号</span></span><br><span class="line">tuple3</span><br><span class="line">    (<span class="string">&#x27;one&#x27;</span>,)</span><br><span class="line">tuple4 = (<span class="string">&#x27;one&#x27;</span>)   <span class="comment">#如果在元素后边没有逗号，那定义的就不是元组，而是一个字符串</span></span><br><span class="line">tuple4</span><br><span class="line">    <span class="string">&#x27;one&#x27;</span></span><br><span class="line">type(tuple4)</span><br><span class="line">    str</span><br></pre></td></tr></table></figure><ul><li>元组间的操作符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">22</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">t2 = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">t1 + t2   <span class="comment">#元组间的相加与列表间的相加，得到一个拥有两个元组的所有元素的元组</span></span><br><span class="line">    (<span class="number">22</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">t1 * <span class="number">3</span></span><br><span class="line">    (<span class="number">22</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><ul><li>成员关系测试</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1</span><br><span class="line">    (<span class="number">22</span>, <span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> t1</span><br><span class="line">    <span class="literal">True</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">in</span> t1</span><br><span class="line">    <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>元组的可变性</li></ul><p>元组本身是一种不可变对象，但它的元素可以是一个可变对象，这样就河以构建成一个看似可以被修改的元组。但元组自身的内存地址是不会发生改变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,list1)</span><br><span class="line">t1      <span class="comment">#元组的第三个元素是一个列表</span></span><br><span class="line">    (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">id(t1)   <span class="comment">#获取元组的内存地址</span></span><br><span class="line">    <span class="number">140193645110976</span></span><br><span class="line">t1[<span class="number">2</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">t1[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">t1[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">22</span>  <span class="comment">#修改值</span></span><br><span class="line">t1</span><br><span class="line">    (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">22</span>])</span><br><span class="line">id(t1)  <span class="comment">#元组中一个列表中的一个元素值被修改，但内存地址没有改变</span></span><br><span class="line">    <span class="number">140193645110976</span></span><br></pre></td></tr></table></figure><ul><li>元组的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1</span><br><span class="line">    (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">22</span>])</span><br><span class="line">t1.count(<span class="string">&#x27;a&#x27;</span>)   <span class="comment">#count方法统计一个元素出现在次数</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">t1.index([<span class="number">1</span>,<span class="number">2</span>,<span class="number">22</span>]) <span class="comment">#index方法返回元素的索引号</span></span><br><span class="line">    <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 列表，元组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python条件判断及循环语句</title>
      <link href="/2016/03/16/2016-03-16-python-learn-conditional-and-circulation/"/>
      <url>/2016/03/16/2016-03-16-python-learn-conditional-and-circulation/</url>
      
        <content type="html"><![CDATA[<p>python学习笔记之条件判断及循环语句。</p><a id="more"></a><h1>条件判断和循环</h1><h2 id="条件判断">条件判断</h2><ul><li>单分支条件判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">if  条件表达式:</span><br><span class="line">    执行命令1</span><br><span class="line">    执行命令2</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的年龄是&#123;0&#125;&#x27;</span>.format(age))</span><br><span class="line">    print(<span class="string">&#x27;你是一个成年人&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>你的年龄是20你是一个成年人</code></pre><ul><li>双分支条件判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">if 条件表达示:</span><br><span class="line">    执行命令1</span><br><span class="line">    执行命令2</span><br><span class="line">else:</span><br><span class="line">    执行命令3</span><br><span class="line">    执行命令4</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的年龄是&#123;0&#125;&#x27;</span>.format(age))</span><br><span class="line">    print(<span class="string">&#x27;你是一个成年人&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的年龄是&#123;age&#125;&#x27;</span>.format(age=age))</span><br><span class="line">    print(<span class="string">&#x27;你是一个未成年人。&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>你的年龄是16你是一个未成年人。</code></pre><ul><li>多分支条件判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">if 条件表达示1:</span><br><span class="line">    执行命令1</span><br><span class="line">elif 条件表达示2:</span><br><span class="line">    执行命令2</span><br><span class="line">elif 条件表达示3:</span><br><span class="line">    执行命令3</span><br><span class="line">.......</span><br><span class="line">else:</span><br><span class="line">    执行命令4</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的年龄是&#123;0&#125;&#x27;</span>.format(age))</span><br><span class="line">    print(<span class="string">&#x27;你是一个成年人&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的年龄是&#123;age&#125;&#x27;</span>.format(age=age))</span><br><span class="line">    print(<span class="string">&#x27;你是少年&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;你的年龄是&#123;0&#125;&#x27;</span>.format(age))</span><br><span class="line">    print(<span class="string">&#x27;你是一个小孩子&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>你的年龄是5你是一个小孩子</code></pre><h2 id="循环">循环</h2><h3 id="for循环">for循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">for i in 可迭代对象:</span><br><span class="line">    执行语句1</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><ul><li>打印出列表中的所有元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classmates = [<span class="string">&#x27;Neal&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;Cora&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> classmates:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><pre><code>NealTomCora</code></pre><ul><li>计算“1+2+…+100”的和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum = sum + n</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><pre><code>5050</code></pre><h3 id="while循环">while循环</h3><p>给出的条件只要满足就一直循环，一旦条件不满足就退出循环。</p><ul><li>计算100内所有奇数之和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n + <span class="number">2</span></span><br><span class="line">print(sum)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><pre><code>2500</code></pre><ul><li>计算100内所有偶数之和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n + <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><pre><code>2550</code></pre>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 条件判断，循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx编译安装并引入优秀的第三方模块</title>
      <link href="/2016/03/09/2016-03-09-make-nginx-template/"/>
      <url>/2016/03/09/2016-03-09-make-nginx-template/</url>
      
        <content type="html"><![CDATA[<p>nginx是一个特别受欢迎的开源软件，但它有一些特性只有在商业版里才有，所以就有了一些好事者自己编写了一些和商业版相似功能的模块，这才开源的nginx功能更能接近商业版。这里介绍nginx源码编译安装并引入了一些优秀的第三方模块的编译过程，可供参考。</p><a id="more"></a><h1>前言</h1><p>线上环境有多套nginx作为应用的负载均衡器，因历史原因，nginx存在各种遗留问题，版本不统一，调度算法单一，未实现对上游服务器的健康检测，配置缩进不规范，所有的<br>upstream，server都配置在nginx.conf文件中，看起配置比较冗长。为了实现环境部署的规范化，需要规范nginx的目录结构、配置文件的缩进，并制作一个nginx环境的部署模板，<br>在当有需要一个nginx环境需求时能通过简单的操作就能部署一个功能完整的nginx环境。</p><h1>源码编译安装nginx</h1><p>目前nginx的稳定版本为“nginx-1.8.1”，以此版本来编译安装。nginx有许多非常好的特性，在查看官方帮助文档时，有时看到一个功能特别强大的指令时，正当你在欢喜时，你<br>又会发现有如下的说明:</p><blockquote><p>This directive is available as part of our <a href="http://nginx.com/products/?_ga=1.198063855.1530886050.1455804017">commercial subscription</a>.</p></blockquote><p>不知道此你有何感想。好在开源的力量是不可估量的，nginx许多商业化版本中才支持的功能在github上都能找到类似的开源项目。这次制作nginx为模板时也加进了几个第三方模块，<br>使nginx的功能更完善。</p><p>我的编译平台如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools<span class="comment"># uname -r</span></span><br><span class="line">3.16.0-4-amd64</span><br><span class="line">root@nginx-02:~/tools<span class="comment"># uname -v</span></span><br><span class="line"><span class="comment">#1 SMP Debian 3.16.7-ckt20-1+deb8u1 (2015-12-14)</span></span><br></pre></td></tr></table></figure><p>引入的第三方模块列表如下：</p><ul><li><a href="https://github.com/yaoweibin/nginx_upstream_check_module">nginx_upstream_check_module</a></li></ul><p>此模块能实现对上游服务器的基于tcp、http、ssl、hello、mysql、ajp、fastcgi的健康检测，并能把被标记为down的主机踢出负载调度。</p><ul><li><a href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module</a></li></ul><p>此模块实现nginx的四层调度，nginx-1.9已原生支持四层调度了，但目前不是稳定版本。此模块还提供了一个对四层调试的状态监控页面。</p><ul><li><a href="https://github.com/gnosek/nginx-upstream-fair">nginx-upstream-fair</a></li></ul><p>此模块增强了round-robin负载均衡算法，可以跟踪后端服务器的负载来分发请求，觉得有点类似least_conn算法。</p><ul><li><a href="https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/get/master.tar.gz">nginx-sticky-module</a></li></ul><p>此模块实现了session保持，比ip_hash的粒度更小，它是基于用户浏览器cookie来保持会话。</p><ul><li><a href="https://github.com/cfsego/ngx_log_if/">ngx_log_if</a></li></ul><p>此模块实现日志过虑功能，此模块是做好模板后才有这样的功能需求，所以下边的演示没有加入此模块。</p><h2 id="第三方模块安装">第三方模块安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools<span class="comment"># pwd</span></span><br><span class="line">/root/tools</span><br><span class="line">root@nginx-02:~/tools<span class="comment"># ls</span></span><br><span class="line">nginx-1.8.1  nginx-1.8.1.tar.gz  part3</span><br><span class="line">root@nginx-02:~/tools/part3<span class="comment"># pwd</span></span><br><span class="line">/root/tools/part3</span><br><span class="line">root@nginx-02:~/tools/part3<span class="comment"># ls -l</span></span><br><span class="line">total 524</span><br><span class="line">drwxrwxr-x 4 root root   4096 Aug  6  2015 nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d</span><br><span class="line">-rw-r--r-- 1 root root 120553 Mar  8 09:53 nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d.tar.gz</span><br><span class="line">drwxr-xr-x 7 root root   4096 Aug 18  2015 nginx_tcp_proxy_module-master</span><br><span class="line">-rw-r--r-- 1 root root 213069 Mar  8 10:28 nginx_tcp_proxy_module-master.zip</span><br><span class="line">drwxr-xr-x 6 root root   4096 Jul  1  2015 nginx_upstream_check_module-master</span><br><span class="line">-rw-r--r-- 1 root root 167495 Mar  8 16:50 nginx_upstream_check_module-master.zip</span><br><span class="line">drwxr-xr-x 2 root root   4096 Apr  8  2012 nginx-upstream-fair-master</span><br><span class="line">-rw-r--r-- 1 root root  10845 Mar  8 09:28 nginx-upstream-fair-master.zip</span><br></pre></td></tr></table></figure><p><strong>特别注意</strong></p><p>各个模块的安装方法请参数源码目录下的帮助文档，经过反复验证，在安装以上第三方模块时，有些坑是值得注意的。nginx_upstream_check_module与nginx_tcp_proxy_module<br>不能同时导入到nginx源码，不然在make时会报错，所以请严格按照以下顺序来安装。</p><ul><li>第一步：先解决编译安装nginx的依赖并创建运行nginx work进程的用户</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># apt-get -y install openssl libssl-dev libpcre3 libpcre3-dev</span></span><br></pre></td></tr></table></figure><blockquote><p>libpcre3 libpcre3-dev    HTTP rewrite module requires the PCRE library</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># useradd -m -d /home/nginx -s /bin/bash nginx   #可不配置密码</span></span><br></pre></td></tr></table></figure><ul><li>第二步：导入第三方nginx_upstream_check_module模块</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># patch -p1 &lt; ../part3/nginx_upstream_check_module-master/check_1.7.5+.patch </span></span><br><span class="line">patching file src/http/modules/ngx_http_upstream_hash_module.c</span><br><span class="line">Hunk <span class="comment">#3 succeeded at 528 (offset 10 lines).</span></span><br><span class="line">patching file src/http/modules/ngx_http_upstream_ip_hash_module.c</span><br><span class="line">patching file src/http/modules/ngx_http_upstream_least_conn_module.c</span><br><span class="line">patching file src/http/ngx_http_upstream_round_robin.c</span><br><span class="line">patching file src/http/ngx_http_upstream_round_robin.h</span><br></pre></td></tr></table></figure><ul><li>第三步：编译安装nginx</li></ul><p>nginx-upstream-fair-master和nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d模块不需要做额外处理，只需要在编译时用–add-module指令加入即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># ./configure --prefix=/usr/local/nginx18 \</span></span><br><span class="line">--user=nginx \</span><br><span class="line">--group=nginx \</span><br><span class="line">--with-file-aio \</span><br><span class="line">--pid-path=/var/run/nginx18.pid \</span><br><span class="line">--lock-path=/var/lock/subsys/nginx18 \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_mp4_module \</span><br><span class="line">--with-http_gunzip_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_auth_request_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-http_secure_link_module \</span><br><span class="line">--http-client-body-temp-path=/var/tmp/nginx18/client \</span><br><span class="line">--http-proxy-temp-path=/var/tmp/nginx18/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/tmp/nginx18/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/tmp/nginx18/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/tmp/nginx18/scgi \</span><br><span class="line">--add-module=../part3/nginx-upstream-fair-master \</span><br><span class="line">--add-module=../part3/nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d \</span><br><span class="line">--add-module=../part3/nginx_upstream_check_module-master</span><br><span class="line"> </span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># make</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># make install</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># mkdir -pv /var/tmp/nginx18/&#123;proxy,fastcgi,uwsgi,scgi&#125;</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># tree /usr/local/nginx18/</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx18/</span><br><span class="line">├── conf</span><br><span class="line">│   ├── fastcgi.conf</span><br><span class="line">│   ├── fastcgi.conf.default</span><br><span class="line">│   ├── fastcgi_params</span><br><span class="line">│   ├── fastcgi_params.default</span><br><span class="line">│   ├── koi-utf</span><br><span class="line">│   ├── koi-win</span><br><span class="line">│   ├── mime.types</span><br><span class="line">│   ├── mime.types.default</span><br><span class="line">│   ├── nginx.conf</span><br><span class="line">│   ├── nginx.conf.default</span><br><span class="line">│   ├── scgi_params</span><br><span class="line">│   ├── scgi_params.default</span><br><span class="line">│   ├── uwsgi_params</span><br><span class="line">│   ├── uwsgi_params.default</span><br><span class="line">│   └── win-utf</span><br><span class="line">├── html</span><br><span class="line">│   ├── 50x.html</span><br><span class="line">│   └── index.html</span><br><span class="line">├── logs</span><br><span class="line">└── sbin</span><br><span class="line">    └── nginx</span><br></pre></td></tr></table></figure><p>查看nginx编辑进的模块：</p><p><img src="/images/2016-03-09-nginx-module-1.jpg" alt=""></p><ul><li>第四步：导入第三方nginx_tcp_proxy_module模块</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># patch -p1 &lt; ../part3/nginx_tcp_proxy_module-master/tcp.patch </span></span><br><span class="line">patching file src/core/ngx_log.c</span><br><span class="line">Hunk <span class="comment">#1 succeeded at 86 (offset 20 lines).</span></span><br><span class="line">patching file src/core/ngx_log.h</span><br><span class="line">Hunk <span class="comment">#1 succeeded at 30 (offset 1 line).</span></span><br><span class="line">Hunk <span class="comment">#2 succeeded at 38 (offset 1 line).</span></span><br><span class="line">patching file src/event/ngx_event_connect.h</span><br><span class="line">Hunk <span class="comment">#1 succeeded at 33 (offset 1 line).</span></span><br><span class="line">Hunk <span class="comment">#2 succeeded at 45 with fuzz 2 (offset 2 lines).</span></span><br></pre></td></tr></table></figure><ul><li>第五步：重新编译nginx</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># ./configure --prefix=/usr/local/nginx18 \</span></span><br><span class="line">--user=nginx \</span><br><span class="line">--group=nginx \</span><br><span class="line">--with-file-aio \</span><br><span class="line">--pid-path=/var/run/nginx18.pid \</span><br><span class="line">--lock-path=/var/lock/subsys/nginx18 \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_mp4_module \</span><br><span class="line">--with-http_gunzip_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_auth_request_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-http_secure_link_module \</span><br><span class="line">--http-client-body-temp-path=/var/tmp/nginx18/client \</span><br><span class="line">--http-proxy-temp-path=/var/tmp/nginx18/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/tmp/nginx18/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/tmp/nginx18/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/tmp/nginx18/scgi \</span><br><span class="line">--add-module=../part3/nginx-upstream-fair-master \</span><br><span class="line">--add-module=../part3/nginx-goodies-nginx-sticky-module-ng-c78b7dd79d0d \</span><br><span class="line">--add-module=../part3/nginx_upstream_check_module-master \</span><br><span class="line">--add-module=../part3/nginx_tcp_proxy_module-master             <span class="comment">#增加了nginx_tcp_proxy_module-master模块</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># make   #make后一定不要make install操作</span></span><br></pre></td></tr></table></figure><p>拷贝重新编译好的nginx二进制文件到nginx的安装目录，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># ls</span></span><br><span class="line">auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  Makefile  man  objs  README  src</span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># ls objs/</span></span><br><span class="line">addon  autoconf.err  Makefile  nginx  nginx.8  ngx_auto_config.h  ngx_auto_headers.h  ngx_modules.c  ngx_modules.o  src</span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># cp objs/nginx /usr/local/nginx18/sbin/</span></span><br></pre></td></tr></table></figure><p>再次查看编译进nginx的模块：</p><p><img src="/images/2016-03-09-nginx-module-2.jpg" alt=""></p><p>很明显多了nginx_tcp_proxy_module这个模块。</p><ul><li>第六步：提供systemctl控制的启动脚本及收尾工作</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># vim /lib/systemd/system/nginx.service </span></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/var/run/nginx18.pid</span><br><span class="line">ExecStartPre=/usr/<span class="built_in">local</span>/nginx18/sbin/nginx -t -c /usr/<span class="built_in">local</span>/nginx18/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx18/sbin/nginx -c /usr/<span class="built_in">local</span>/nginx18/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/nginx18/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/nginx18/sbin/nginx -s stop</span><br><span class="line">TimeoutStopSec=5</span><br><span class="line">KillMode=mixed</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"> </span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># systemctl enable nginx.service </span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /lib/systemd/system/nginx.service.</span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># systemctl start nginx.service  #启动</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># ss -tnlp | grep nginx</span></span><br><span class="line">LISTEN     0      128                       *:80                       *:*      users:((<span class="string">&quot;nginx&quot;</span>,pid=10935,fd=6),(<span class="string">&quot;nginx&quot;</span>,pid=10934,fd=6))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># mkdir -pv /var/tmp/nginx18/&#123;proxy,client,fastcgi,uwsgi,scgi&#125;   #创建临时目录</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># vim /etc/profile.d/nginx18.sh  #导出二进制文件</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/nginx18/sbin:<span class="variable">$PATH</span></span><br><span class="line">root@nginx-02:~/tools/nginx-1.8.1<span class="comment"># source /etc/profile.d/nginx18.sh</span></span><br></pre></td></tr></table></figure><h2 id="关于线程池">关于线程池</h2><p>线程池在nginx-1.8是支持的，但在当我启用了“–with-threads”功能，并加增加“–add-module=…/part3/nginx_tcp_proxy_module-master”模块后，make时会报如下错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">../part3/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.c: In <span class="keyword">function</span> ‘ngx_tcp_upstream_get_round_robin_peer’:</span><br><span class="line">../part3/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.c:459:16: error: ‘ngx_event_t’ has no member named ‘lock’</span><br><span class="line">         c-&gt;<span class="built_in">read</span>-&gt;lock = c-&gt;<span class="built_in">read</span>-&gt;own_lock;</span><br><span class="line">                ^</span><br><span class="line">../part3/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.c:459:32: error: ‘ngx_event_t’ has no member named ‘own_lock’</span><br><span class="line">         c-&gt;<span class="built_in">read</span>-&gt;lock = c-&gt;<span class="built_in">read</span>-&gt;own_lock;</span><br><span class="line">                                ^</span><br><span class="line">../part3/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.c:460:17: error: ‘ngx_event_t’ has no member named ‘lock’</span><br><span class="line">         c-&gt;write-&gt;lock = c-&gt;write-&gt;own_lock;</span><br><span class="line">                 ^</span><br><span class="line">../part3/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.c:460:34: error: ‘ngx_event_t’ has no member named ‘own_lock’</span><br><span class="line">         c-&gt;write-&gt;lock = c-&gt;write-&gt;own_lock;</span><br><span class="line">                                  ^</span><br><span class="line">objs/Makefile:1298: recipe <span class="keyword">for</span> target <span class="string">&#x27;objs/addon/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.o&#x27;</span> failed</span><br><span class="line">make[1]: *** [objs/addon/nginx_tcp_proxy_module-master/ngx_tcp_upstream_round_robin.o] Error 1</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/root/tools/nginx-1.8.1&#x27;</span></span><br><span class="line">Makefile:8: recipe <span class="keyword">for</span> target <span class="string">&#x27;build&#x27;</span> failed</span><br><span class="line">make: *** [build] Error 2</span><br></pre></td></tr></table></figure><p>只好作罢，如果真的业务需要启用threads，再去掉“nginx_tcp_proxy_module”模块后重新编译。</p><h1>规范</h1><p>至此，我们编译安装的nginx已准备好。在生产环境中，gninx的配置文件改动得比较频繁，如果没有规划好配置文件该怎么修改？各个目录该存放什么文件？缩进是否要严格要求？<br>随时间的推移，nginx的配置文件将变得不易维护，所以约定如下：</p><ul><li>nginx.conf配置文件只启用nginx健康检测的页面的虚拟主机，并使用include语句把“/usr/local/nginx18/conf”目录下的&quot;layer4&quot;和“layer7”目录下的任何以“.conf”结尾的文件<br>包含进来，目录结构如下：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx18/conf</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf<span class="comment"># ll</span></span><br><span class="line">total 68</span><br><span class="line">-rw-r--r-- 1 root staff 1034 Mar  9 22:03 fastcgi.conf</span><br><span class="line">-rw-r--r-- 1 root staff 1034 Mar  9 22:03 fastcgi.conf.default</span><br><span class="line">-rw-r--r-- 1 root staff  964 Mar  9 22:03 fastcgi_params</span><br><span class="line">-rw-r--r-- 1 root staff  964 Mar  9 22:03 fastcgi_params.default</span><br><span class="line">-rw-r--r-- 1 root staff 2837 Mar  9 22:03 koi-utf</span><br><span class="line">-rw-r--r-- 1 root staff 2223 Mar  9 22:03 koi-win</span><br><span class="line">drwxr-sr-x 2 root staff 4096 Mar  9 22:03 layer4</span><br><span class="line">drwxr-sr-x 2 root staff 4096 Mar  9 22:03 layer7</span><br><span class="line">-rw-r--r-- 1 root staff 3957 Mar  9 22:03 mime.types</span><br><span class="line">-rw-r--r-- 1 root staff 3957 Mar  9 22:03 mime.types.default</span><br><span class="line">-rw-r--r-- 1 root staff 3480 Mar  9 22:03 nginx.conf</span><br><span class="line">-rw-r--r-- 1 root staff 2656 Mar  9 22:03 nginx.conf.default</span><br><span class="line">-rw-r--r-- 1 root staff  596 Mar  9 22:03 scgi_params</span><br><span class="line">-rw-r--r-- 1 root staff  596 Mar  9 22:03 scgi_params.default</span><br><span class="line">-rw-r--r-- 1 root staff  623 Mar  9 22:03 uwsgi_params</span><br><span class="line">-rw-r--r-- 1 root staff  623 Mar  9 22:03 uwsgi_params.default</span><br><span class="line">-rw-r--r-- 1 root staff 3610 Mar  9 22:03 win-utf</span><br></pre></td></tr></table></figure><ul><li>上边规划的layer4和layer7两个目录是分别放置4层调度和7层调度时各配置文件，文件以“.conf”结尾；</li><li>各虚拟主机的配置文件名称以“server_name”中的值来命名，点号转换成“_”，如“server_name <a href="http://www.test.cn">www.test.cn</a>”，那相应的配置文件为“www_test_cn.conf”，在layer4目录下的文件也<br>类似，只是它没有“server_name”字段，以upstream字段的值来命名配置文件，如“upstream cmdserver”，那配置文件为“cmdserver.conf”;</li><li>layer7目录下各虚拟主机产生的访问日志和错误日志名称单独规划，参照配置文件的名称，日志名称如“www_test_cn.access.log”和&quot;www_test_cn.error.log&quot;；</li><li>配置文件中的代码缩进严格按照各代码块的层级关系缩进。</li></ul><h1>配置示例</h1><ul><li>nginx.conf配置示例</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx18/conf</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf<span class="comment"># cat nginx.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line">pid        /var/run/nginx18.pid;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#worker_connections  1024;</span></span><br><span class="line">    worker_connections  65535;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># $upstream_cache_status 记录缓存命中率</span></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$upstream_cache_status&quot;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line">    proxy_temp_path /usr/<span class="built_in">local</span>/nginx18/proxy_temp;</span><br><span class="line">    proxy_cache_path /usr/<span class="built_in">local</span>/nginx18/proxy_cache levels=1:2 keys_zone=cache_one:100m inactive=2d max_size=2g;</span><br><span class="line"> </span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># http://nginx.org/en/docs/http/server_names.html</span></span><br><span class="line">    proxy_headers_hash_max_size 512;</span><br><span class="line">    proxy_headers_hash_bucket_size 128;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"> </span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /layer4-status &#123;</span><br><span class="line">            tcp_check_status;</span><br><span class="line">            access_log off;</span><br><span class="line">        &#125;</span><br><span class="line">        location /layer7-status &#123;</span><br><span class="line">            check_status;</span><br><span class="line">            access_log off;</span><br><span class="line">        <span class="comment">#    allow 172.16.0.0/24;</span></span><br><span class="line">        <span class="comment">#    deny all;</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    include       layer7/*.conf;</span><br><span class="line">&#125;</span><br><span class="line">include       layer4/*.conf;</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf<span class="comment"># </span></span><br></pre></td></tr></table></figure><ul><li>四层调度配置示例</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer4<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx18/conf/layer4</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer4<span class="comment"># ls</span></span><br><span class="line">cmdserver.conf</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer4<span class="comment"># cat cmdserver.conf </span></span><br><span class="line">tcp &#123;</span><br><span class="line">        upstream cmdserver &#123;</span><br><span class="line">            ip_hash;</span><br><span class="line">            <span class="comment"># simple round-robin</span></span><br><span class="line">            server 172.31.11.70:9100;</span><br><span class="line">            server 172.31.11.71:9100;</span><br><span class="line">            check interval=3000 rise=2 fall=5 timeout=1000 <span class="built_in">type</span>=tcp;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        server &#123;</span><br><span class="line">            listen 8500;</span><br><span class="line">            proxy_pass cmdserver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer4<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>七层调度配置示例</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer7<span class="comment"># pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx18/conf/layer7</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer7<span class="comment"># ls</span></span><br><span class="line">www_test_cn.conf</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer7<span class="comment"># cat www_test_cn.conf </span></span><br><span class="line">upstream test_server &#123;</span><br><span class="line">    sticky;  <span class="comment"># or round-robin or fair</span></span><br><span class="line">    server 172.31.0.10:80 weight=1;</span><br><span class="line">    server 172.31.11.96:80 weight=1 down;</span><br><span class="line">    <span class="comment"># interval表示健康检查发送的间隔时间，单位为ms，rise表示把服务器标记为up状态前需要检查成功的次数，</span></span><br><span class="line">    <span class="comment"># fall表示把服务器标记为down状态前需要检查失败的次数，timeout表示健康检查时的超时时间，超过此时间就标记为一次检查失败.</span></span><br><span class="line">    check interval=5000 rise=2 fall=5 timeout=1000 <span class="built_in">type</span>=http port=80;</span><br><span class="line">    check_http_send <span class="string">&quot;HEAD / HTTP/1.0\r\n\r\n&quot;</span>;</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    client_max_body_size 50M;</span><br><span class="line">    server_name www.test.cn;</span><br><span class="line">    access_log  logs/www_test_cn.access.log  main;</span><br><span class="line">    error_log logs/www_test_cn.error.log debug;</span><br><span class="line"> </span><br><span class="line">    location ~ .*\.(gif|jpg|html|css|js|ico|swf|pdf)(.*) &#123;</span><br><span class="line">        proxy_pass http://test_server;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line"> </span><br><span class="line">        proxy_cache cache_one;</span><br><span class="line">        add_header Nginx-Cache <span class="variable">$upstream_cache_status</span>;</span><br><span class="line">        proxy_cache_valid 200 304 301 302 8h;</span><br><span class="line">        proxy_cache_valid 404 500 1m;</span><br><span class="line">        proxy_cache_valid any 2d;</span><br><span class="line">        proxy_cache_key <span class="variable">$host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">        expires 30d;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://test_server;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 配置nginx转发客户端IP</span></span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="comment"># needed for HTTPS</span></span><br><span class="line">        <span class="comment"># proxy_set_header X_FORWARDED_PROTO https;</span></span><br><span class="line">        </span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># NginxHttpRealIpModule，指向上一级反向代理服务器(HAproxy or nginx or other)</span></span><br><span class="line">        <span class="comment"># 把从172.31.0.0/16网段来的请求全部使用X-Forwarded-For里的头信息作为remote_addr,</span></span><br><span class="line">        set_real_ip_from 172.31.0.0/16;</span><br><span class="line">        set_real_ip_from 172.31.0.100;</span><br><span class="line">        real_ip_header X-Real-IP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">root@nginx-02:/usr/<span class="built_in">local</span>/nginx18/conf/layer7<span class="comment">#</span></span><br></pre></td></tr></table></figure><h1>总结</h1><p>以后若有nginx环境的需要，可以直接把“/usr/local/nginx18”目录拷贝到目标主机，再把“/lib/systemd/system/nginx.service”文件拷贝到目标主机，一个nginx环境就可以运行了。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志数据删除脚本v3</title>
      <link href="/2016/03/03/2016-03-02-logs-del-shell-v3/"/>
      <url>/2016/03/03/2016-03-02-logs-del-shell-v3/</url>
      
        <content type="html"><![CDATA[<p>在第二版中，备份目录是以保留天数的方式进行删除，当一个项目版本迭代的不是那么频繁，有可能会把备份目录下的所有备份删除，<br>而在备份服务器上删除备份数据也是按只保留多少天的数据，所以备份服务器上此项目的备份数据也有可能会被删除，所以在第三版中把备<br>份目录中备份项目的删除方式进行了修改，可以以传入参数来指定保留多少个备份，这样更为安全。</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: logs_clear.sh</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2016-02-15</span></span><br><span class="line"><span class="comment">#description: 清理日志数据和备份数据</span></span><br><span class="line"><span class="comment">#使用：/bin/bash logs_clear.sh $1 $2 $3，$1表示根目录被占用的百分比值,$2表示日志保留的天数，$3表示备份目录中备份文件保留份数</span></span><br><span class="line"><span class="comment">#Version 3.0</span></span><br><span class="line"><span class="comment">#变量请根据实际环境进行修改</span></span><br><span class="line">log_dir=/home/tomcat/tomcat-7.0.54/logs.bak</span><br><span class="line">bak_dir=/home/tomcat/bak</span><br><span class="line">project_name=iov_mcms</span><br><span class="line">log_record_file=/tmp/logs_clear.log</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin</span><br><span class="line"><span class="comment">#获取系统根目录使用率</span></span><br><span class="line">root_rate=`df -h | egrep --color=auto <span class="string">&#x27;/$&#x27;</span> | sed -e <span class="string">&#x27;s/[=/%]/ /g&#x27;</span> | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>`</span><br><span class="line">[ -f <span class="variable">$&#123;log_record_file&#125;</span> ] || touch <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;root_rate&#125;</span> -ge <span class="variable">$1</span> ];<span class="keyword">then</span></span><br><span class="line">    [ -f /tmp/tmp.tmp ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /tmp/tmp.tmp || touch /tmp/tmp.tmp</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;数据开始清理时间：<span class="subst">$(date +%F_%T)</span>&quot;</span> &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">    <span class="comment">#清理日志文件</span></span><br><span class="line">    find <span class="variable">$&#123;log_dir&#125;</span> -<span class="built_in">type</span> f -mtime +<span class="variable">$2</span> | tee /tmp/tmp.tmp &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span>  <span class="comment">#tee是重定向操作，不是追加操作</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -s /tmp/tmp.tmp ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;日志目录没有可删除的文件。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/tmp.tmp`;<span class="keyword">do</span></span><br><span class="line">            rm -f <span class="variable">$i</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment">#清理备份文件</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">&quot;bak_keep_num= <span class="variable">$3</span> + 1&quot;</span>  <span class="comment">#备份保留份数加1才能进行tail过虑</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -td <span class="variable">$&#123;bak_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>* | wc -l` -ge <span class="variable">$&#123;bak_keep_num&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">        ls -td <span class="variable">$&#123;bak_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>* | tail -n +<span class="variable">$&#123;bak_keep_num&#125;</span> | tee /tmp/tmp.tmp &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">        <span class="keyword">if</span> [ ! -s /tmp/tmp.tmp ];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;备份目录没有可删除的文件。&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/tmp.tmp`;<span class="keyword">do</span></span><br><span class="line">                rm -rf <span class="variable">$i</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;备份目录没有可删除的文件。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment">#清理空目录</span></span><br><span class="line">    find <span class="variable">$&#123;log_dir&#125;</span> -<span class="built_in">type</span> d -empty | egrep -v <span class="string">&quot;(debug$|trace$|info$|error$|warn$)&quot;</span> | tee /tmp/tmp.tmp &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -s /tmp/tmp.tmp ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;日志目录中没有空目录可清理。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/tmp.tmp`;<span class="keyword">do</span></span><br><span class="line">            rmdir <span class="variable">$i</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;数据清理完成时间：<span class="subst">$(date +%F_%T)</span>\n&quot;</span> &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell script </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logs del </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本部署gitlab环境</title>
      <link href="/2016/03/03/2016-03-03-deploy-gitlib/"/>
      <url>/2016/03/03/2016-03-03-deploy-gitlib/</url>
      
        <content type="html"><![CDATA[<p>部署一套gitlab环境比较复杂，这里把部署的过程写成了shell脚本，这大大简化的gitlab部署的成本。</p><a id="more"></a><h1>前言</h1><p>在51cto的博客上已介绍过<a href="http://zhaochj.blog.51cto.com/368705/1737738">企业级GitLab仓库环境构建</a>，这里利用两个shell脚本来完成gitlib的部署。</p><h1>shell scripts</h1><p>以下脚本已在debian 8 x64系统下测试通过。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: config_gitlab.sh</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2015-12-04</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"><span class="comment">#安装，包下载地址 http://mirror.tuna.tsinghua.edu.cn/gitlab-ce/</span></span><br><span class="line">sudo dpkg -i gitlab-ce_8.2.1-ce.0_amd64.deb</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 修改gitlab数据存放目录</span></span><br><span class="line">sudo vim /var/opt/gitlab/gitlab-shell/config.yml    <span class="comment"># repos_path: &quot;/data/git-data/repositories&quot;</span></span><br><span class="line">sudo vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml</span><br><span class="line"><span class="comment">#satellites:</span></span><br><span class="line"><span class="comment">#     path: /data/git-data/gitlab-satellites</span></span><br><span class="line"><span class="comment">#     ...</span></span><br><span class="line"><span class="comment">#gitlab_shell:</span></span><br><span class="line"><span class="comment">#     path: /opt/gitlab/embedded/service/gitlab-shell/</span></span><br><span class="line"><span class="comment">#     repos_path: /data/git-data/repositories</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 创建数据存放目录并修改权限</span></span><br><span class="line">sudo mkdir  -pv /data/git-data/gitlab-satellites</span><br><span class="line">sudo mkdir -pv /data/git-data/repositories</span><br><span class="line">sudo chown -R git.git /data/git-data/</span><br><span class="line">sudo chmod 2770 /data/git-data/repositories</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># restart gitlab service</span></span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><ul><li>open gitlab https access</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: open gitbal https access</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2015-12-04</span></span><br><span class="line"><span class="comment">#此脚本适用于Debian 8 amd64，其他平台未做测试</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SUBJECT为CA服务的机构信息</span></span><br><span class="line">SUBJECT=<span class="string">&quot;/C=CN/ST=ChongQing/L=YuBei/O=SJKJ/OU=CA/CN=<span class="variable">$DOMAIN</span>&quot;</span></span><br><span class="line"><span class="comment"># SUBJECT_GITLAB为gitlab主机的机构信息</span></span><br><span class="line">SUBJECT_GITLAB=<span class="string">&quot;/C=CN/ST=ChongQing/L=YuBei/O=SJKJ/OU=OP/CN=<span class="variable">$DOMAIN_GITLAB</span>&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#处理依赖</span></span><br><span class="line"><span class="comment">#apt-get -y install openssl</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">## 自建CA </span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your CA domain [www.example.com]: &quot;</span> DOMAIN</span><br><span class="line">sudo bash -c <span class="string">&#x27;mkdir -pv /etc/ssl/demoCA/&#123;private,newcerts&#125; &gt; /dev/null&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> /etc/ssl</span><br><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">sudo bash -c <span class="string">&#x27;(umask 077;openssl genrsa -out ./demoCA/private/cakey.pem 2048)&#x27;</span></span><br><span class="line"><span class="comment">#sudo bash -c &#x27;ln -s /etc/ssl/demoCA/private/cakey.pem /etc/ssl/demoCA/cakey.pem&#x27;</span></span><br><span class="line"><span class="comment"># 生成自签证书</span></span><br><span class="line"><span class="comment">#sudo bash -c &#x27;openssl req -new -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&quot;openssl req -new -subj <span class="variable">$SUBJECT</span> -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650&quot;</span></span><br><span class="line">sudo touch ./demoCA/index.txt</span><br><span class="line">sudo bash -c <span class="string">&quot;echo 01 &gt; ./demoCA/serial&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33mCertificate services is created...\033[0m&quot;</span></span><br><span class="line"><span class="comment">##自建CA完成</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 为gitlab主机创建存放私钥和证书的目录，/etc/gitlab/ssl是一个固定目录，不能更改，请参考：</span></span><br><span class="line"><span class="comment"># https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#enable-https</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your gitlab domain [www.example.com]: &quot;</span> DOMAIN_GITLAB</span><br><span class="line">sudo bash -c <span class="string">&#x27;mkdir -p /etc/gitlab/ssl&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> /etc/gitlab/ssl</span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">sudo bash -c <span class="string">&quot;(umask 077;openssl genrsa -out <span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.key 1024)&quot;</span></span><br><span class="line"><span class="comment"># 生成证书签署请求</span></span><br><span class="line">sudo bash -c <span class="string">&quot;openssl req -new -subj <span class="variable">$SUBJECT_GITLAB</span> -key <span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.key -out <span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.csr&quot;</span></span><br><span class="line"><span class="comment"># CA签署证书</span></span><br><span class="line"><span class="built_in">cd</span> /etc/ssl</span><br><span class="line">sudo bash -c <span class="string">&quot;openssl ca -in /etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.csr -out /etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.crt -days 3650&quot;</span></span><br><span class="line"><span class="comment"># 更改目录权限</span></span><br><span class="line">sudo chmod 700 /etc/gitlab/ssl</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">## 开启gitlab的https支持</span></span><br><span class="line">sudo vim /etc/gitlab/gitlab.rb <span class="comment">#external_url &#x27;https://$&#123;DOMAIN_GITLAB&#125;:2443&#x27;</span></span><br><span class="line">sudo bash -c <span class="string">&quot;cat &lt;&lt;- EOF &gt;&gt; /etc/gitlab/gitlab.rb</span></span><br><span class="line"><span class="string">##### open htts #####################</span></span><br><span class="line"><span class="string">nginx[&#x27;redirect_http_to_https&#x27;] = true</span></span><br><span class="line"><span class="string">nginx[&#x27;ssl_certificate&#x27;] = \&quot;/etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.crt\&quot;</span></span><br><span class="line"><span class="string">nginx[&#x27;ssl_certificate_key&#x27;] = \&quot;/etc/gitlab/ssl/<span class="variable">$&#123;DOMAIN_GITLAB&#125;</span>.key\&quot;</span></span><br><span class="line"><span class="string">EOF&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">sudo gitlab-ctl reconfigure <span class="comment"># 使配置生效</span></span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><h1>参考资料</h1><ul><li><a href="https://gist.github.com/jhjguxin/c1583284bb7a0bb2f117">https://gist.github.com/jhjguxin/c1583284bb7a0bb2f117</a></li><li><a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/backups.md">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/backups.md</a></li><li><a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md</a></li><li><a href="https://github.com/xxrenzhe/YYShare_Magedu/tree/master/Gitlab%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93_20151017/scripts">https://github.com/xxrenzhe/YYShare_Magedu/tree/master/Gitlab构建企业级代码仓库_20151017/scripts</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 版本管理工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志数据删除脚本v1</title>
      <link href="/2016/03/02/2016-03-02-logs-del-shell-v2/"/>
      <url>/2016/03/02/2016-03-02-logs-del-shell-v2/</url>
      
        <content type="html"><![CDATA[<p>在第一版中，设计的逻辑过于复杂，只要不是有特别的需求，生产环境下不必如此，只保留指定天数的数据即可，而日志和备份数据又在每天同步到备份服务器上，数据不会导致丢失。</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: logs_clear.sh</span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2016-02-15</span></span><br><span class="line"><span class="comment">#description: 清理日志数据和备份数据</span></span><br><span class="line"><span class="comment">#使用：/bin/bash logs_clear.sh $1 $2 $3，$1表示根目录被占用的百分比值,$2表示日志保留的天数，$3表示备份目录中备份文件保留天数</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"><span class="comment">#变量请根据实际环境进行修改</span></span><br><span class="line">log_dir=/home/tomcat/tomcat-7.0.54/logs</span><br><span class="line">bak_dir=/home/tomcat/bak</span><br><span class="line">log_record_file=/tmp/logs_clear.log</span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin</span><br><span class="line"><span class="comment">#获取系统根目录使用率</span></span><br><span class="line">root_rate=`df -h | egrep --color=auto <span class="string">&#x27;/$&#x27;</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | sed -e <span class="string">&#x27;s/[=/%]/ /g&#x27;</span>`</span><br><span class="line">[ -f <span class="variable">$&#123;log_record_file&#125;</span> ] || touch <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line"><span class="comment">#if [ $&#123;root_rate&#125; -ge $1 ];then</span></span><br><span class="line"><span class="comment">#    [ -f /tmp/tmp.tmp ] &amp;&amp; echo &quot;&quot; &gt; /tmp/tmp.tmp || touch /tmp/tmp.tmp</span></span><br><span class="line"><span class="comment">#    echo &quot;数据开始清理时间：$(date +%F_%T)&quot; &gt;&gt; $&#123;log_record_file&#125;   </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    #清理日志文件</span></span><br><span class="line"><span class="comment">#    find $&#123;log_dir&#125; -type f -mtime +$2 | tee /tmp/tmp.tmp &gt;&gt; $&#123;log_record_file&#125;</span></span><br><span class="line"><span class="comment">#    if [ ! -s /tmp/tmp.tmp ];then</span></span><br><span class="line"><span class="comment">#        echo &quot;日志目录没有可删除的文件。&quot;</span></span><br><span class="line"><span class="comment">#    else</span></span><br><span class="line"><span class="comment">#        for i in `cat /tmp/tmp.tmp`;do</span></span><br><span class="line"><span class="comment">#            rm -f $i</span></span><br><span class="line"><span class="comment">#        done</span></span><br><span class="line"><span class="comment">#    fi</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    #清理备份文件</span></span><br><span class="line"><span class="comment">#    find $&#123;bak_dir&#125; -maxdepth 1 -type d -mtime +$3 | grep -v &quot;/`basename $&#123;bak_dir&#125;`$&quot; | tee /tmp/tmp.tmp &gt;&gt; $&#123;log_record_file&#125;</span></span><br><span class="line"><span class="comment">#    if [ ! -s /tmp/tmp.tmp ];then</span></span><br><span class="line"><span class="comment">#        echo &quot;备份目录没有可删除的文件。&quot;</span></span><br><span class="line"><span class="comment">#    else</span></span><br><span class="line"><span class="comment">#        for i in `cat /tmp/tmp.tmp`;do</span></span><br><span class="line"><span class="comment">#            rm -rf $i</span></span><br><span class="line"><span class="comment">#        done</span></span><br><span class="line"><span class="comment">#    fi</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    #清理空目录</span></span><br><span class="line"><span class="comment">#    find $&#123;log_dir&#125; -type d -empty | egrep -v &quot;(debug$|trace$|info$|error$|warn$)&quot; | tee /tmp/tmp.tmp &gt;&gt; $&#123;log_record_file&#125;</span></span><br><span class="line"><span class="comment">#    if [ ! -s /tmp/tmp.tmp ];then</span></span><br><span class="line"><span class="comment">#        echo &quot;日志目录中没有空目录可清理。&quot;</span></span><br><span class="line"><span class="comment">#    else</span></span><br><span class="line"><span class="comment">#        for i in `cat /tmp/tmp.tmp`;do</span></span><br><span class="line"><span class="comment">#            rmdir $i</span></span><br><span class="line"><span class="comment">#        done</span></span><br><span class="line"><span class="comment">#    fi</span></span><br><span class="line"><span class="comment">#    echo -e &quot;数据清理完成时间：$(date +%F_%T)\n&quot; &gt;&gt; $&#123;log_record_file&#125;</span></span><br><span class="line"><span class="comment">#fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell script </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logs del </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志数据删除脚本v1</title>
      <link href="/2016/03/02/2016-03-02-logs-del-shell-v1/"/>
      <url>/2016/03/02/2016-03-02-logs-del-shell-v1/</url>
      
        <content type="html"><![CDATA[<p>线上的一些应用没有对日志进行清理，这里用一个shell脚本来完成日志清理工作。</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#Program: logs_clear.sh </span></span><br><span class="line"><span class="comment">#Author: Neal</span></span><br><span class="line"><span class="comment">#E_mail: 419775240@qq.com</span></span><br><span class="line"><span class="comment">#Date: 2016-02-15</span></span><br><span class="line"><span class="comment">#description: 清理日志数据和备份数据</span></span><br><span class="line"><span class="comment">#使用：/bin/bash logs_clear.sh N，N表示根目录被占用的百分比值</span></span><br><span class="line"><span class="comment">#Version 1.0</span></span><br><span class="line"><span class="comment">#使用此脚本前提：目录结构为$CATALINA_HOME/logs/Project_Name/&#123;info,debug,trace,warn,error&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变量请根据实际环境进行修改</span></span><br><span class="line">project_name=iov_mcms</span><br><span class="line">log_dir=/home/tomcat/tomcat-7.0.54/logs</span><br><span class="line">log_record_file=/tmp/logs_clear.log</span><br><span class="line"><span class="comment">#项目产生日志文件保留份数=num-1</span></span><br><span class="line">num=11</span><br><span class="line"><span class="comment">#备份目录</span></span><br><span class="line">bak_dir=/home/tomcat/bak</span><br><span class="line"><span class="comment">#版本保留份数,因升级前后会各备份一次，后边使用&quot;tail -n +N&quot; 的方式获取要删除的目录，所以版本保留份数=(bak_dir_num-1) * 2</span></span><br><span class="line">bak_dir_num=7</span><br><span class="line"><span class="comment">#tomcat自身日志保留份数为(tomcat_logs_num - 1)</span></span><br><span class="line">tomcat_logs_num=7</span><br><span class="line"><span class="comment">###########################part 1,日志清理########################################</span></span><br><span class="line"><span class="comment">#获取系统根目录使用率</span></span><br><span class="line">root_rate=`df -h | egrep --color=auto <span class="string">&#x27;/$&#x27;</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | sed -e <span class="string">&#x27;s/[=/%]/ /g&#x27;</span>`</span><br><span class="line"><span class="comment">#声明函数</span></span><br><span class="line"><span class="function"><span class="title">log_record</span></span> () &#123;</span><br><span class="line">    [ -f <span class="variable">$&#123;log_record_file&#125;</span> ] || touch <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在执行删除日志文件前做一些前置操作记录日志</span></span><br><span class="line"><span class="function"><span class="title">pre_del_log</span></span> () &#123;</span><br><span class="line">    <span class="comment">#过虑掉最新的(num - 1)个日志文件后再计数</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/<span class="variable">$1</span> | tail -n +<span class="variable">$&#123;num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;删除<span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/<span class="variable">$1</span>目录下的以下文件：&quot;</span> &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">        ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/<span class="variable">$1</span> | tail -n +<span class="variable">$&#123;num&#125;</span> &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>级别的日志中没有可删除的日志文件&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#tomcat启动时自身产生日志清理函数</span></span><br><span class="line"><span class="function"><span class="title">catalina_clear</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/catalina.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/catalina.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">host-<span class="function"><span class="title">manager_clear</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/host-manager.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/host-manager.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">localhost_clear</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/localhost.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/localhost.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">localhost_access_log_clear</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/localhost_access_log.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/localhost_access_log.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">manager_clear</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/manager.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/manager.* | tail -n +<span class="variable">$&#123;tomcat_logs_num&#125;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#工程产生各级别日志清理函数</span></span><br><span class="line"><span class="function"><span class="title">clear_info_log</span></span> () &#123;</span><br><span class="line">    <span class="comment">#过虑掉最新的(num - 1)个日志文件后再计数</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/info | tail -n +<span class="variable">$&#123;num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/info</span><br><span class="line">        <span class="comment">#以时间排序，保留最新的num-1份数据</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/info | tail -n +<span class="variable">$&#123;num&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;info日志删除成功&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">clear_debug_log</span></span> () &#123;</span><br><span class="line">    <span class="comment">#过虑掉最新的(num - 1)个日志文件后再计数</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/debug | tail -n +<span class="variable">$&#123;num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/debug</span><br><span class="line">        <span class="comment">#以时间排序，保留最新的num-1份数据</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/debug | tail -n +<span class="variable">$&#123;num&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;debug日志删除成功&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">clear_trace_log</span></span> () &#123;</span><br><span class="line">    <span class="comment">#过虑掉最新的(num - 1)个日志文件后再计数</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/trace | tail -n +<span class="variable">$&#123;num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/trace</span><br><span class="line">        <span class="comment">#以时间排序，保留最新的num-1份数据</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/trace | tail -n +<span class="variable">$&#123;num&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;trace日志删除成功&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">clear_warn_log</span></span> () &#123;</span><br><span class="line">    <span class="comment">#过虑掉最新的(num - 1)个日志文件后再计数</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/warn | tail -n +<span class="variable">$&#123;num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/warn</span><br><span class="line">        <span class="comment">#以时间排序，保留最新的num-1份数据</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/warn | tail -n +<span class="variable">$&#123;num&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;warn日志删除成功&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">clear_error_log</span></span> () &#123;</span><br><span class="line">    <span class="comment">#过虑掉最新的(num - 1)个日志文件后再计数</span></span><br><span class="line">    <span class="keyword">if</span> [ `ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/error | tail -n +<span class="variable">$&#123;num&#125;</span> | wc -l` -gt 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/error</span><br><span class="line">        <span class="comment">#以时间排序，保留最新的num-1份数据</span></span><br><span class="line">        rm -f $(ls -t <span class="variable">$&#123;log_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>/error | tail -n +<span class="variable">$&#123;num&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;error日志删除成功&quot;</span></span><br><span class="line">    <span class="keyword">fi</span>       </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#定义脚本触发条件,ge表示大于或等于</span></span><br><span class="line"><span class="comment">#if [ $root_rate -ge $1 ];then</span></span><br><span class="line"><span class="comment">#    #tomcat环境时调用清理自身产生的日志</span></span><br><span class="line"><span class="comment">#    catalina_clear</span></span><br><span class="line"><span class="comment">#    host-manager_clear</span></span><br><span class="line"><span class="comment">#    localhost_clear</span></span><br><span class="line"><span class="comment">#    localhost_access_log_clear</span></span><br><span class="line"><span class="comment">#    manager_clear</span></span><br><span class="line"><span class="comment">#    #打开日志记录</span></span><br><span class="line"><span class="comment">#    log_record</span></span><br><span class="line"><span class="comment">#    echo &quot;脚本执行开始时间：$(date +%F_%T)&quot; &gt;&gt; $&#123;log_record_file&#125;</span></span><br><span class="line"><span class="comment">#    #调用函数并传递参数</span></span><br><span class="line"><span class="comment">#    pre_del_log info</span></span><br><span class="line"><span class="comment">#    pre_del_log debug</span></span><br><span class="line"><span class="comment">#    pre_del_log trace</span></span><br><span class="line"><span class="comment">#    pre_del_log warn</span></span><br><span class="line"><span class="comment">#    pre_del_log error</span></span><br><span class="line"><span class="comment">#    #调用删各除级别日志函数</span></span><br><span class="line"><span class="comment">#    clear_info_log</span></span><br><span class="line"><span class="comment">#    clear_debug_log</span></span><br><span class="line"><span class="comment">#    clear_trace_log</span></span><br><span class="line"><span class="comment">#    clear_warn_log</span></span><br><span class="line"><span class="comment">#    clear_error_log</span></span><br><span class="line"><span class="comment">#fi</span></span><br><span class="line"><span class="comment">###########################part 2,备份文件删除########################################</span></span><br><span class="line"><span class="function"><span class="title">pre_del_bak</span></span> () &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;删除<span class="variable">$&#123;bak_dir&#125;</span>目录下的以下文件：&quot;</span> &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span></span><br><span class="line">    ls -td <span class="variable">$&#123;bak_dir&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>* | tail -n +<span class="variable">$&#123;bak_dir_num&#125;</span> &gt;&gt; <span class="variable">$&#123;log_record_file&#125;</span>   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#if [ `ls -td $&#123;bak_dir&#125;/$&#123;project_name&#125;* | wc -l` -ge $&#123;bak_dir_num&#125; ];then</span></span><br><span class="line"><span class="comment">#    pre_del_bak</span></span><br><span class="line"><span class="comment">#    #保留以时间排序后的最新的dir_num - 1个备份工程目录，即保留最新的三个版本</span></span><br><span class="line"><span class="comment">#    rm -rf $(ls -td $&#123;bak_dir&#125;/$&#123;project_name&#125;* | tail -n +$&#123;bak_dir_num&#125;)</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#    echo &quot;工程的备份版本数量不足，不会删除任何数据。&quot;</span></span><br><span class="line"><span class="comment">#fi</span></span><br><span class="line"><span class="comment">#echo -e &quot;脚本执行完毕，脚本结束时间：$(date +%F_%T)\n&quot; &gt;&gt; $&#123;log_record_file&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> shell script </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logs del </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
